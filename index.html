<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Animus Corridor Simulation - Non-Euclidean</title>
  <!-- Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    /* ===== Reset & Base Styles ===== */
    html, body {
      margin: 0; 
      padding: 0;
      overflow: hidden;
      background: #0d1b2a; /* Deep blue background */
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
    }

    /* ===== Navigation Bar ===== */
    nav {
      position: fixed;
      top: 0;
      width: 100%;
      background: rgba(0,0,0,0.4);
      padding: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0,204,255,0.5);
    }
    nav button {
      background: transparent;
      border: 2px solid rgba(0,204,255,0.7);
      color: #00ccff;
      margin: 0 10px;
      padding: 8px 16px;
      cursor: pointer;
      text-transform: uppercase;
      transition: background 0.3s, color 0.3s, transform 0.3s;
      outline: none;
    }
    nav button:hover,
    nav button.active {
      background: #00ccff;
      color: #000;
      transform: scale(1.05);
    }

    /* ===== Centered Content Card ===== */
    .content-card {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60%;
      max-width: 800px;
      padding: 30px;
      color: #fff;
      text-align: center;
      border: 2px solid rgba(0,204,255,0.3);
      border-radius: 20px;
      box-shadow: 0 0 20px rgba(0,204,255,0.2);
      background: rgba(0,0,0,0.3);
      backdrop-filter: blur(8px);
      z-index: 10;
    }
    .content-card h1 {
      font-size: 2em;
      margin-bottom: 0.5em;
      color: #00ccff;
    }
    .content-card p {
      font-size: 1.1em;
      line-height: 1.6em;
    }
    /* Only show Inventory by default */
    #map, #email, #codex, #scanner {
      display: none;
    }
  </style>
</head>
<body>
  <!-- ===== Navigation ===== -->
  <nav>
    <button data-section="inventory" class="active">Inventory</button>
    <button data-section="map">Map</button>
    <button data-section="email">Email</button>
    <button data-section="codex">Codex</button>
    <button data-section="scanner">Scanner</button>
  </nav>

  <!-- ===== Content Cards ===== -->
  <div id="inventory" class="content-card">
    <h1>Inventory</h1>
    <p>Inventory details go here.</p>
  </div>
  <div id="map" class="content-card">
    <h1>Map</h1>
    <p>Map details go here.</p>
  </div>
  <div id="email" class="content-card">
    <h1>Email</h1>
    <p>Email details go here.</p>
  </div>
  <div id="codex" class="content-card">
    <h1>Codex</h1>
    <p>Codex details go here.</p>
  </div>
  <div id="scanner" class="content-card">
    <h1>Scanner</h1>
    <p>Scanner details go here.</p>
  </div>

  <!-- ===== Three.js Scene ===== -->
  <script>
    let scene, camera, renderer;
    let corridor;              // main corridor group
    let corridorTexture;       // our scrolling texture
    let techShapesGroup;       // tech panels along the sides
    let motionLinesGroup;      // horizontal motion lines on the floor
    let glyphs = [];           // interactive glyph sprites

    // Configurations
    const CORRIDOR_SIZE = 2000;
    const repulsionDistance = 120; // in screen pixels
    const repulsionForce = 1.5;      // push strength for glyphs
    const friction = 0.93;

    // Mouse & rotation targets
    let mouse = new THREE.Vector2(0, 0);
    let targetRotationX = 0, targetRotationY = 0;

    init();
    animate();

    function init() {
      /* ===== Scene & Fog ===== */
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0d1b2a);
      // Slightly lighter fog for better visibility of the warp
      scene.fog = new THREE.FogExp2(0x0d1b2a, 0.0008);

      /* ===== Camera ===== */
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 5000);
      // Position camera so that you "watch" the corridor coming toward you
      camera.position.set(0, 300, 1500);
      camera.lookAt(0, 0, 0);

      /* ===== Renderer ===== */
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      /* ===== Lights ===== */
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
      directionalLight.position.set(1, 1, 1).normalize();
      scene.add(directionalLight);

      /* ===== Corridor (Non-Euclidean) ===== */
      corridor = new THREE.Group();
      const half = CORRIDOR_SIZE / 2;
      // Create and store the techy texture so we can scroll it later.
      corridorTexture = createTechBackgroundTexture(512);
      corridorTexture.wrapS = corridorTexture.wrapT = THREE.RepeatWrapping;
      corridorTexture.repeat.set(2, 2);

      const corridorMat = new THREE.MeshPhongMaterial({
        map: corridorTexture,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.65
      });

      // Floor
      const floorGeo = new THREE.PlaneGeometry(CORRIDOR_SIZE, CORRIDOR_SIZE);
      const floor = new THREE.Mesh(floorGeo, corridorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -half;
      corridor.add(floor);
      addEdges(floorGeo, floor);

      // Ceiling
      const ceilingGeo = new THREE.PlaneGeometry(CORRIDOR_SIZE, CORRIDOR_SIZE);
      const ceiling = new THREE.Mesh(ceilingGeo, corridorMat);
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.y = half;
      corridor.add(ceiling);
      addEdges(ceilingGeo, ceiling);

      // Left Wall
      const leftWallGeo = new THREE.PlaneGeometry(CORRIDOR_SIZE, CORRIDOR_SIZE);
      const leftWall = new THREE.Mesh(leftWallGeo, corridorMat);
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.x = -half;
      corridor.add(leftWall);
      addEdges(leftWallGeo, leftWall);

      // Right Wall
      const rightWallGeo = new THREE.PlaneGeometry(CORRIDOR_SIZE, CORRIDOR_SIZE);
      const rightWall = new THREE.Mesh(rightWallGeo, corridorMat);
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.x = half;
      corridor.add(rightWall);
      addEdges(rightWallGeo, rightWall);

      // (No back wall so the corridor recedes into the fog)
      scene.add(corridor);

      /* ----- Scrolling Corridor Texture ----- */
      // In animate(), we'll continuously update corridorTexture.offset.y

      /* ===== Tech Shapes (Coherent Tech Panels) ===== */
      techShapesGroup = new THREE.Group();
      scene.add(techShapesGroup);
      // Create about 6 tech panels along the sides
      for (let i = 0; i < 6; i++) {
        const shape = createTechPanel();
        resetTechShape(shape);
        techShapesGroup.add(shape);
      }

      /* ===== Motion Lines (Simulate Walking Forward) ===== */
      motionLinesGroup = new THREE.Group();
      scene.add(motionLinesGroup);
      // Create 10 horizontal lines on the floor that move forward
      for (let i = 0; i < 10; i++) {
        const line = createMotionLine();
        // Random z position within corridor
        line.position.z = -Math.random() * CORRIDOR_SIZE;
        motionLinesGroup.add(line);
      }

      /* ===== Glyph Sprites (Interactive & Distributed) ===== */
      const glyphLetters = ["Λ", "Δ", "Ω", "ψ", "Σ", "Φ", "Ξ", "Π"];
      // Create 30 glyphs, positioned throughout the corridor volume
      for (let i = 0; i < 30; i++) {
        const letter = glyphLetters[Math.floor(Math.random() * glyphLetters.length)];
        const sprite = createGlyphSprite(letter);
        // Distribute in a 3D volume:
        sprite.position.set(
          (Math.random() - 0.5) * CORRIDOR_SIZE,
          (Math.random() - 0.5) * CORRIDOR_SIZE,
          -Math.random() * CORRIDOR_SIZE
        );
        sprite.userData = {
          basePosition: sprite.position.clone(),
          oscillationSpeed: Math.random() * 0.5 + 0.5,
          velocity: new THREE.Vector3(0, 0, 0),
          lifetime: 0,
          maxLifetime: 8 + Math.random() * 8  // lasts between 8-16 seconds
        };
        glyphs.push(sprite);
        scene.add(sprite);
      }

      /* ===== Event Listeners ===== */
      window.addEventListener("resize", onWindowResize, false);
      document.addEventListener("mousemove", onDocumentMouseMove, false);

      // Navigation button events for UI overlay
      const navButtons = document.querySelectorAll("nav button");
      const sections = ["inventory", "map", "email", "codex", "scanner"];
      navButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          const sectionId = btn.getAttribute("data-section");
          sections.forEach(s => {
            const el = document.getElementById(s);
            el.style.display = (s === sectionId) ? "block" : "none";
          });
          navButtons.forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
        });
      });
    }

    /* Create a techy background texture (circuit-like lines, arcs, hex codes) */
    function createTechBackgroundTexture(size) {
      const canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");

      // Dark base
      ctx.fillStyle = "#0d1b2a";
      ctx.fillRect(0, 0, size, size);

      // Draw random circuit lines
      const lineCount = 25;
      for (let i = 0; i < lineCount; i++) {
        ctx.strokeStyle = "rgba(0, 204, 255, 0.3)";
        ctx.lineWidth = Math.random() * 2 + 1;
        ctx.beginPath();
        let x1 = Math.random() * size;
        let y1 = Math.random() * size;
        let x2 = x1 + (Math.random() - 0.5) * 150;
        let y2 = y1 + (Math.random() - 0.5) * 150;
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }

      // Draw arcs/circles
      const arcCount = 15;
      for (let i = 0; i < arcCount; i++) {
        ctx.strokeStyle = "rgba(0, 204, 255, 0.3)";
        ctx.lineWidth = Math.random() * 2 + 1;
        ctx.beginPath();
        let cx = Math.random() * size;
        let cy = Math.random() * size;
        let r = Math.random() * 40 + 10;
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Random hex strings
      const textCount = 10;
      ctx.fillStyle = "rgba(0, 204, 255, 0.25)";
      ctx.font = "14px monospace";
      for (let i = 0; i < textCount; i++) {
        let tx = Math.random() * size;
        let ty = Math.random() * size;
        let hexString = Math.floor(Math.random() * 0xffffff).toString(16).toUpperCase();
        ctx.fillText(hexString, tx, ty);
      }

      return new THREE.CanvasTexture(canvas);
    }

    /* Helper: Add wireframe edges so the corridor is clearly defined */
    function addEdges(geometry, mesh) {
      const edgesGeo = new THREE.EdgesGeometry(geometry);
      const edgesMat = new THREE.LineBasicMaterial({ color: 0x00ccff, transparent: true, opacity: 0.4 });
      const edges = new THREE.LineSegments(edgesGeo, edgesMat);
      mesh.add(edges);
    }

    /* Create a coherent tech panel (chip-like shape with circuit lines) */
    function createTechPanel() {
      const group = new THREE.Group();

      // Create a chip-like rectangular shape using extruded geometry
      const shape = new THREE.Shape();
      shape.moveTo(-20, -15);
      shape.lineTo(20, -15);
      shape.lineTo(20, 15);
      shape.lineTo(-20, 15);
      shape.lineTo(-20, -15);
      const extrudeSettings = { depth: 4, bevelEnabled: false };
      const chipGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      const chipMat = new THREE.MeshBasicMaterial({ color: 0x00ccff, transparent: true, opacity: 0.8 });
      const chipMesh = new THREE.Mesh(chipGeo, chipMat);
      group.add(chipMesh);

      // Add a few consistent circuit lines on the panel
      for (let i = 0; i < 2; i++) {
        const start = new THREE.Vector3(-15, -10 + i * 10, 4);
        const end = new THREE.Vector3(15, -10 + i * 10, 4);
        const lineGeo = new THREE.BufferGeometry().setFromPoints([start, end]);
        const lineMat = new THREE.LineBasicMaterial({ color: 0x00ccff, transparent: true, opacity: 0.8 });
        const line = new THREE.Line(lineGeo, lineMat);
        group.add(line);
      }

      group.userData = { lifetime: 0, maxLifetime: 12 + Math.random() * 8 }; // lasts 12-20 seconds
      return group;
    }

    /* Reset a tech panel's position, rotation and lifetime */
    function resetTechShape(shape) {
      shape.userData.lifetime = 0;
      shape.userData.maxLifetime = 12 + Math.random() * 8;
      shape.position.set(
        (Math.random() - 0.5) * CORRIDOR_SIZE * 0.8,
        (Math.random() - 0.5) * CORRIDOR_SIZE * 0.8,
        -Math.random() * CORRIDOR_SIZE * 0.5
      );
      shape.rotation.set(
        Math.random() * Math.PI,
        Math.random() * Math.PI,
        Math.random() * Math.PI
      );
      // Reset opacities in the shape
      shape.traverse(child => {
        if (child.material) child.material.opacity = 0.8;
      });
    }

    /* Create an interactive glyph sprite with the given letter */
    function createGlyphSprite(letter) {
      const canvas = document.createElement("canvas");
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, 128, 128);
      ctx.font = "100px Arial";
      ctx.fillStyle = "rgba(0,204,255,0.8)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(letter, 64, 64);
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
      // Ensure sizeAttenuation is on so sprites scale with perspective
      material.sizeAttenuation = true;
      const sprite = new THREE.Sprite(material);
      // Initial scale; this will be updated based on depth in animate()
      sprite.scale.set(100, 100, 1);
      return sprite;
    }

    /* Create a motion line to simulate forward movement along the floor */
    function createMotionLine() {
      const geometry = new THREE.BufferGeometry();
      const vertices = new Float32Array([
        -CORRIDOR_SIZE / 2, 0, 0,
         CORRIDOR_SIZE / 2, 0, 0
      ]);
      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
      const material = new THREE.LineBasicMaterial({ color: 0x00ccff, transparent: true, opacity: 0.6 });
      const line = new THREE.Line(geometry, material);
      // Position the line on the floor (slightly above to avoid z-fighting)
      line.position.y = -CORRIDOR_SIZE / 2 + 1;
      return line;
    }

    /* ===== Window & Mouse Handlers ===== */
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onDocumentMouseMove(e) {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      const maxRotation = 0.1;
      targetRotationY = mouse.x * maxRotation;
      targetRotationX = mouse.y * maxRotation;
    }

    /* ===== Animation Loop ===== */
    function animate() {
      requestAnimationFrame(animate);

      const time = Date.now() * 0.001;

      // ---- Scroll the Corridor Texture (simulate moving forward) ----
      corridorTexture.offset.y += 0.002; // Adjust speed as desired

      // ---- Warp the corridor (non-euclidean effect) ----
      corridor.scale.z = 1 + 0.15 * Math.sin(time * 0.3);
      // Slowly rotate corridor based on mouse movement for a subtle shift
      corridor.rotation.y += (targetRotationY - corridor.rotation.y) * 0.05;
      corridor.rotation.x += (targetRotationX - corridor.rotation.x) * 0.05;

      // ---- Update Motion Lines (simulate forward movement) ----
      motionLinesGroup.children.forEach(line => {
        // Move line forward (increase z)
        line.position.z += 4;
        // When a line passes the camera, reposition it far back
        if (line.position.z > 200) {
          line.position.z = -CORRIDOR_SIZE;
        }
      });

      // ---- Update Glyphs (Interactive, Fade Out & Depth-Based Scaling) ----
      glyphs.forEach(sprite => {
        sprite.userData.lifetime += 0.016;
        // Fade out gradually over lifetime
        const fade = 1 - (sprite.userData.lifetime / sprite.userData.maxLifetime);
        sprite.material.opacity = Math.max(fade, 0);

        // When nearly faded out, reset the glyph
        if (fade <= 0.05) {
          sprite.userData.lifetime = 0;
          sprite.userData.maxLifetime = 8 + Math.random() * 8;
          sprite.position.set(
            (Math.random() - 0.5) * CORRIDOR_SIZE,
            (Math.random() - 0.5) * CORRIDOR_SIZE,
            -Math.random() * CORRIDOR_SIZE
          );
          sprite.userData.basePosition.copy(sprite.position);
          sprite.userData.velocity.set(0, 0, 0);
          sprite.material.opacity = 1.0;
        }

        // Oscillate slightly around the base position
        const t = Date.now() * 0.001 * sprite.userData.oscillationSpeed;
        sprite.position.x = sprite.userData.basePosition.x + Math.sin(t) * 10;
        sprite.position.y = sprite.userData.basePosition.y + Math.cos(t) * 10;

        // Convert glyph position to screen space for interactivity
        const pos = sprite.position.clone();
        pos.project(camera);
        const glyphScreenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
        const glyphScreenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
        const mouseScreenX = (mouse.x + 1) * 0.5 * window.innerWidth;
        const mouseScreenY = (-mouse.y + 1) * 0.5 * window.innerHeight;
        const dist = Math.hypot(glyphScreenX - mouseScreenX, glyphScreenY - mouseScreenY);

        // If mouse is close, push the glyph away
        if (dist < repulsionDistance) {
          const dx = glyphScreenX - mouseScreenX;
          const dy = glyphScreenY - mouseScreenY;
          const angle = Math.atan2(dy, dx);
          const pushX = Math.cos(angle) * repulsionForce;
          const pushY = Math.sin(angle) * repulsionForce;
          sprite.userData.velocity.x += pushX;
          sprite.userData.velocity.y += pushY;
        }
        // Apply velocity with friction
        sprite.userData.velocity.multiplyScalar(friction);
        sprite.position.x += sprite.userData.velocity.x;
        sprite.position.y += sprite.userData.velocity.y;

        // ---- Vary Glyph Scale Based on Distance ----
        let d = camera.position.distanceTo(sprite.position);
        // Interpolate scale between 200 (close, d <= 500) and 50 (far, d >= 1500)
        let f = THREE.MathUtils.clamp((d - 500) / 1000, 0, 1);
        let scaleVal = 200 * (1 - f) + 50 * f;
        sprite.scale.set(scaleVal, scaleVal, 1);
      });

      // ---- Update Tech Panels (Fade Out & Reset) ----
      techShapesGroup.children.forEach(shape => {
        shape.userData.lifetime += 0.016;
        const ratio = shape.userData.lifetime / shape.userData.maxLifetime;
        if (ratio >= 1) {
          resetTechShape(shape);
        } else {
          const fade = 1 - ratio;
          shape.traverse(child => {
            if (child.material) child.material.opacity = 0.8 * fade;
          });
        }
      });

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
