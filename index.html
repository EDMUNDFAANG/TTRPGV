<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <!-- Using title from original, but can be changed -->
    <title>Animus Corridor Simulation v1.0 Visuals + v2.3 UI</title>
    <!-- Load Orbitron font (bold needed for UI) -->
    <link href="https://fonts.googleapis.com/css?family=Orbitron:400,700" rel="stylesheet">
    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* --- UI Styles from v2.3 --- */
        :root {
            /* Core Palette from v2.3 */
            --bg-color-deep: #05080f;
            --bg-color-mid: #0d1b2a;
            --accent-primary: #00e5ff;
            --accent-secondary: #7f00ff;
            --text-color: rgba(0, 229, 255, 0.9);
            --text-color-muted: rgba(0, 229, 255, 0.6);

            /* UI Elements from v2.3 */
            --panel-bg: rgba(10, 25, 40, 0.55);
            --panel-border: rgba(0, 229, 255, 0.25);
            --panel-border-active: rgba(0, 229, 255, 0.6);
            --panel-shadow: rgba(0, 229, 255, 0.15);
            --panel-glow: rgba(0, 229, 255, 0.3);

            /* Interaction from v2.3 */
            --hover-bg: rgba(0, 229, 255, 0.1);
            --hover-border: rgba(0, 229, 255, 0.5);
            --active-bg: rgba(0, 229, 255, 0.2);
            --active-border: var(--accent-primary);
            --selected-glow: rgba(0, 229, 255, 0.5);

            /* Transitions & Animations from v2.3 */
            --transition-fast: 0.2s ease-out;
            --transition-med: 0.4s ease-in-out;
            --transition-slow: 0.6s ease-in-out;
            --transition-ui-panel: 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        /* ===== Reset & Base Styles ===== */
        html { height: 100%; box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }

        /* MODIFIED: Body background uses v1.0 logic but font/color from v2.3 */
        body {
          margin: 0; padding: 0; min-height: 100%; overflow: hidden;
          /* Background color from v1.0's scene background */
          background: #0d1b2a;
          /* Font and text color from v2.3 */
          font-family: 'Orbitron', sans-serif; color: var(--text-color);
          position: relative;
        }

        /* ===== Pre-Login Animated Background (from v1.0) ===== */
        body::before {
            content: ""; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 1;
            /* Using v1.0 accent colors for the gradients */
            background:
                radial-gradient(circle at 20% 30%, rgba(0, 204, 255, 0.2) 0%, transparent 40%), /* Lighter accent */
                radial-gradient(circle at 80% 70%, #00ccff 5%, transparent 50%), /* Main accent */
                linear-gradient(135deg, #0a1826 0%, #0d1b2a 70%); /* Darker blue gradient */
            background-size: 200% 200%; opacity: 0.6;
            animation: subtleGalaxyShift 45s linear infinite;
            transition: opacity 0.6s ease-out; pointer-events: none;
        }
        /* v1.0 Keyframes */
        @keyframes subtleGalaxyShift {
            0% { background-position: 0% 0%; } 25% { background-position: 30% 50%; }
            50% { background-position: 70% 100%; } 75% { background-position: 40% 50%; }
            100% { background-position: 0% 0%; }
        }
        body.hide-login-bg::before { opacity: 0; }

        /* ===== Three.js Canvas (from v1.0) ===== */
        canvas {
          display: block; position: fixed; top: 0; left: 0; z-index: -1;
        }

        /* ===== Holographic Text Style (from v2.3) ===== */
        .holo-text {
            font-family: 'Orbitron', sans-serif; font-weight: 700;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
            text-shadow:
                0 0 4px hsla(190, 100%, 70%, 0.9), 0 0 10px hsla(190, 100%, 60%, 0.6),
                0 0 18px hsla(270, 100%, 60%, 0.2);
            color: var(--text-color); opacity: 0.95;
        }

        /* ===== Login Panel Styling (from v2.3) ===== */
        #loginPanel {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(1);
            width: 320px; padding: 35px; border: 1px solid var(--panel-border); border-radius: 25px;
            background: var(--panel-bg); backdrop-filter: blur(12px) saturate(120%);
            box-shadow: 0 0 30px var(--panel-shadow); text-align: center; z-index: 400;
            opacity: 1; transition: opacity var(--transition-slow), transform var(--transition-slow);
            pointer-events: auto;
        }
        #loginPanel.hidden { opacity: 0; transform: translate(-50%, -50%) scale(0.9); pointer-events: none; }
        #loginPanel h1 { margin-bottom: 25px; font-size: 1.6em; }
        #loginPanel input {
            width: 95%; margin: 12px 0; padding: 10px; border: 1px solid var(--accent-primary);
            border-radius: 8px; background: rgba(0, 0, 0, 0.2); color: var(--accent-primary);
            font-family: 'Orbitron', sans-serif; font-size: 1em; text-align: center;
            transition: box-shadow var(--transition-fast), background var(--transition-fast); outline: none;
        }
        #loginPanel input::placeholder { color: var(--text-color-muted); opacity: 0.8; }
        #loginPanel input:focus { background: rgba(0, 0, 0, 0.3); box-shadow: 0 0 12px hsla(190, 100%, 60%, 0.4); }
        #loginPanel button {
            margin-top: 20px; padding: 10px 20px; border: 2px solid var(--accent-primary);
            border-radius: 8px; background: transparent; color: var(--accent-primary); cursor: pointer;
            transition: background var(--transition-fast), transform var(--transition-fast), box-shadow var(--transition-fast);
            font-family: 'Orbitron', sans-serif; font-weight: 700; text-transform: uppercase; letter-spacing: 1px;
        }
        #loginPanel button:hover { background: var(--hover-bg); box-shadow: 0 0 15px hsla(190, 100%, 60%, 0.5); transform: translateY(-2px); }
        #loginPanel button:active { background: var(--active-bg); transform: translateY(0px); box-shadow: 0 0 8px hsla(190, 100%, 60%, 0.3); }
        @keyframes shake { /* v2.3 */
            0%, 100% { transform: translate(-50%, -50%) translateX(0); }
            20%, 60% { transform: translate(-50%, -50%) translateX(-8px); }
            40%, 80% { transform: translate(-50%, -50%) translateX(8px); }
        }

        /* ===== Main Content (from v2.3) ===== */
        #mainContent { display: block; opacity: 0; transition: opacity 1.8s ease-in 0.6s; pointer-events: none; }
        #mainContent.visible { opacity: 1; pointer-events: auto; }

        /* ===== Intro Message Overlay (from v2.3) ===== */
        #introMessage {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2.8em;
            z-index: 300; opacity: 0; animation: introAnim 3.5s cubic-bezier(0.165, 0.84, 0.44, 1) forwards 1.0s;
            white-space: nowrap;
        }
        @keyframes introAnim {
            0% { opacity: 0; transform: translate(-50%, -60%) scale(0.6); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
            100% { opacity: 0; transform: translate(-50%, -45%) scale(1); }
        }

        /* ===== Navigation Bar (from v2.3) ===== */
        nav {
            position: fixed; top: 0; left: 50%; transform: translateX(-50%); width: auto; max-width: 90%;
            display: flex; justify-content: center; align-items: center; z-index: 200;
            background: rgba(10, 25, 40, 0.6); padding: 8px 20px; border-radius: 0 0 15px 15px;
            box-shadow: 0 4px 20px var(--panel-shadow); backdrop-filter: blur(10px) saturate(110%);
            opacity: 0; animation: navFadeIn 1.2s ease-out forwards 2.8s; transition: top var(--transition-med);
        }
        @keyframes navFadeIn { from { opacity: 0; transform: translate(-50%, -100%); } to { opacity: 1; transform: translate(-50%, 0); } }
        nav button {
            background: transparent; border: 1px solid var(--panel-border); margin: 0 8px; padding: 8px 18px;
            cursor: pointer; text-transform: uppercase; letter-spacing: 0.5px;
            transition: background var(--transition-fast), color var(--transition-fast), transform var(--transition-fast), border-color var(--transition-fast), box-shadow var(--transition-fast);
            outline: none; opacity: 0; transform: translateY(-15px); animation: buttonFadeIn 0.7s ease-out forwards;
            color: var(--text-color); font-weight: 700; border-radius: 6px;
        }
        nav button:nth-child(1) { animation-delay: 3.0s; } nav button:nth-child(2) { animation-delay: 3.1s; }
        nav button:nth-child(3) { animation-delay: 3.2s; } nav button:nth-child(4) { animation-delay: 3.3s; }
        nav button:nth-child(5) { animation-delay: 3.4s; } nav button:nth-child(6) { animation-delay: 3.5s; }
        @keyframes buttonFadeIn { from { opacity: 0; transform: translateY(-15px); } to { opacity: 1; transform: translateY(0); } }
        nav button:hover { background: var(--hover-bg); color: #FFF; border-color: var(--hover-border); transform: scale(1.03) translateY(0); box-shadow: 0 0 8px var(--panel-glow); }
        nav button.active { background: var(--active-bg); color: #FFF; border-color: var(--active-border); transform: scale(1.03) translateY(0); box-shadow: 0 0 12px var(--selected-glow); }

        /* ===== Content Panels Wrapper ===== */
        #contentWrapper { /* No specific styles */ }

        /* ===== Floating UI Panels (from v2.3) ===== */
        .content-card, #inventoryContainer {
            position: fixed; top: 55%; left: 50%; transform: translate(-50%, -50%) scale(0.95);
            border: 1px solid var(--panel-border); border-radius: 18px; box-shadow: 0 8px 35px var(--panel-shadow);
            background: var(--panel-bg); backdrop-filter: blur(12px) saturate(120%); z-index: 100;
            opacity: 0; pointer-events: none;
            transition: opacity var(--transition-ui-panel), transform var(--transition-ui-panel), top var(--transition-ui-panel);
            overflow: hidden; display: flex; flex-direction: column;
        }
        .content-card.active, #inventoryContainer.active { opacity: 1; pointer-events: auto; top: 50%; transform: translate(-50%, -50%) scale(1); }
        .content-card { width: clamp(300px, 75%, 950px); height: clamp(400px, 65vh, 650px); padding: 25px; }
        .content-card h1 {
            margin: 0 0 20px 0; padding-bottom: 15px; border-bottom: 1px solid var(--panel-border-active);
            text-align: center; flex-shrink: 0; font-size: 1.7em; letter-spacing: 1px;
        }
        .content-card .panel-content { flex-grow: 1; overflow-y: auto; padding-right: 15px; scrollbar-width: thin; scrollbar-color: var(--accent-primary) rgba(0,0,0,0.2); }

        /* Custom Webkit Scrollbar (from v2.3) */
        .panel-content::-webkit-scrollbar, .inventory-grid::-webkit-scrollbar, .item-details::-webkit-scrollbar, #emailList::-webkit-scrollbar, #emailContent::-webkit-scrollbar { width: 8px; }
        .panel-content::-webkit-scrollbar-track, .inventory-grid::-webkit-scrollbar-track, .item-details::-webkit-scrollbar-track, #emailList::-webkit-scrollbar-track, #emailContent::-webkit-scrollbar-track { background: rgba(0,0,0,0.15); border-radius: 4px; }
        .panel-content::-webkit-scrollbar-thumb, .inventory-grid::-webkit-scrollbar-thumb, .item-details::-webkit-scrollbar-thumb, #emailList::-webkit-scrollbar-thumb, #emailContent::-webkit-scrollbar-thumb { background-color: var(--accent-primary); border-radius: 4px; border: 2px solid transparent; background-clip: content-box; }
        .panel-content::-webkit-scrollbar-thumb:hover, .inventory-grid::-webkit-scrollbar-thumb:hover, .item-details::-webkit-scrollbar-thumb:hover, #emailList::-webkit-scrollbar-thumb:hover, #emailContent::-webkit-scrollbar-thumb:hover { background-color: #fff; }

        /* ===== Inventory Container Styling (from v2.3) ===== */
        #inventoryContainer { width: clamp(600px, 80%, 850px); height: clamp(450px, 60vh, 600px); padding: 20px; flex-direction: row; gap: 25px; z-index: 150; }
        .inventory-grid {
            flex: 2.5; display: grid; grid-template-columns: repeat(auto-fill, minmax(85px, 1fr));
            grid-auto-rows: 85px; gap: 12px; padding: 15px; border: 1px solid var(--panel-border);
            border-radius: 10px; overflow-y: auto; align-content: start; background: rgba(0,0,0, 0.1);
        }
        .inventory-slot {
            width: 100%; height: 100%; border: 2px solid var(--panel-border); border-radius: 10px;
            background: rgba(0,0,0,0.35); display: flex; align-items: center; justify-content: center;
            transition: border-color var(--transition-fast), background-color var(--transition-fast), box-shadow var(--transition-fast), transform var(--transition-fast);
            cursor: pointer; position: relative; overflow: hidden;
        }
        .inventory-slot:hover { border-color: var(--hover-border); background-color: var(--hover-bg); transform: scale(1.04); z-index: 10; }
        .inventory-slot.selected { border-color: var(--active-border); background-color: var(--active-bg); box-shadow: 0 0 12px var(--selected-glow), inset 0 0 10px rgba(0, 229, 255, 0.1); transform: scale(1.04); z-index: 11; }
        .inventory-slot img { max-width: 80%; max-height: 80%; object-fit: contain; transition: transform 0.3s ease-out; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4)); }

        /* Item Info Panel Styling (from v2.3) */
        .item-info {
            flex: 1.5; border: 1px solid var(--panel-border); border-radius: 10px; background: rgba(0,0,0,0.15);
            padding: 20px; display: flex; flex-direction: column; justify-content: space-between;
        }
        .item-details { flex-grow: 1; overflow-y: auto; margin-bottom: 20px; padding-right: 10px; }
        .item-info h2 { margin: 0 0 15px 0; font-size: 1.4em; color: var(--accent-primary); border-bottom: 1px solid var(--panel-border-active); padding-bottom: 8px; letter-spacing: 0.5px; }
        .item-info p { font-size: 1em; line-height: 1.6; color: var(--text-color); opacity: 0.9; }
        .item-actions { flex-shrink: 0; text-align: right; }
        .item-actions button {
            background: transparent; border: 2px solid var(--accent-secondary); color: var(--accent-secondary);
            margin-left: 12px; padding: 8px 18px; cursor: pointer; text-transform: uppercase;
            transition: all var(--transition-fast); font-family: 'Orbitron', sans-serif; font-weight: 700;
            border-radius: 6px; letter-spacing: 1px;
        }
        .item-actions button:hover:not(:disabled) { background: rgba(127, 0, 255, 0.15); color: #eee; border-color: var(--accent-secondary); box-shadow: 0 0 10px rgba(127, 0, 255, 0.4); transform: translateY(-1px); }
        .item-actions button:disabled { border-color: rgba(127, 0, 255, 0.2); color: rgba(127, 0, 255, 0.3); cursor: not-allowed; background: transparent; box-shadow: none; transform: none; }

        /* ===== Email Section Styling (from v2.3) ===== */
        #email .panel-content { display: flex; gap: 20px; padding: 20px 0 0 0; }
        #emailList {
            flex: 1; list-style: none; padding: 0; margin: 0; border-right: 1px solid var(--panel-border);
            overflow-y: auto; padding-right: 20px; max-height: calc(65vh - 120px); /* Adjusted from 60vh */
        }
        #emailList li {
            padding: 12px 15px; border: 1px solid transparent; border-bottom: 1px solid rgba(0, 229, 255, 0.1);
            margin-bottom: 6px; border-radius: 8px; cursor: pointer;
            transition: background-color var(--transition-fast), border-color var(--transition-fast), box-shadow var(--transition-fast);
            position: relative;
        }
        #emailList li:hover { background-color: var(--hover-bg); border-color: var(--hover-border); }
        #emailList li.active { background-color: var(--active-bg); border-color: var(--active-border); box-shadow: 0 0 10px var(--selected-glow); }
        #emailList li .sender { font-weight: 700; display: block; margin-bottom: 4px; color: var(--accent-primary); font-size: 1.05em; }
        #emailList li .subject { font-size: 0.95em; color: var(--text-color); opacity: 0.9; }
        #emailList li.read .subject { opacity: 0.65; }
        #emailList li.unread::before {
            content: ''; position: absolute; left: 6px; top: 50%; transform: translateY(-50%);
            width: 7px; height: 7px; background-color: var(--accent-primary); border-radius: 50%;
            box-shadow: 0 0 6px var(--accent-primary);
        }
        #emailContent { flex: 2.5; padding: 0 15px; overflow-y: auto; max-height: calc(65vh - 120px); /* Adjusted */ }
        #emailContent h2 { font-size: 1.5em; color: var(--accent-primary); margin: 0 0 15px 0; padding-bottom: 8px; border-bottom: 1px solid var(--panel-border-active); }
        #emailContent .email-meta { font-size: 0.9em; color: var(--text-color-muted); margin-bottom: 25px; border-left: 2px solid var(--accent-secondary); padding-left: 10px; opacity: 0.8; }
        #emailContent .email-meta span { display: block; line-height: 1.4; }
        #emailContent .email-body { font-size: 1em; line-height: 1.7; white-space: pre-wrap; color: var(--text-color); opacity: 0.95; }
        #emailPlaceholder { text-align: center; margin-top: 60px; font-size: 1.2em; color: var(--text-color-muted); font-style: italic; }

        /* ===== Ripple Effect (from v2.3) ===== */
        .ripple {
            position: fixed; border-radius: 50%;
            background: radial-gradient(circle, hsla(190, 100%, 70%, 0.25) 5%, hsla(190, 100%, 60%, 0.15) 25%, hsla(270, 100%, 60%, 0.08) 50%, transparent 65%);
            transform: scale(0); pointer-events: none; animation: ripple-effect 0.6s cubic-bezier(0.25, 0.8, 0.25, 1); z-index: 50;
        }
        @keyframes ripple-effect { 0% { transform: scale(0); opacity: 0.7; } 70% { transform: scale(1.8); opacity: 0.2; } 100% { transform: scale(2.2); opacity: 0; } }

        /* ===== Other Section Placeholders (from v2.3) ===== */
        #map .panel-content p, #codex .panel-content p, #scanner .panel-content p, #vitals .panel-content p { padding-top: 30px; font-size: 1.2em; text-align: center; color: var(--text-color-muted); font-style: italic; }

    </style>
</head>
<body>
    <!-- UI Elements (Login, Main Content, Nav, Panels, Inventory) from v2.3 -->
    <!-- ===== Login Panel ===== -->
    <div id="loginPanel">
        <!-- Using v2.3 Text -->
        <h1 class="holo-text">Corridor Access</h1>
        <input type="text" id="username" placeholder="Designation" value="Vesta" autocomplete="off"/>
        <input type="password" id="passcode" placeholder="Neural Key" value="password" autocomplete="new-password"/>
        <button id="loginButton" class="holo-text">Synchronize</button>
    </div>

    <!-- ===== Main Content (structure from v2.3) ===== -->
    <div id="mainContent">
        <!-- Intro Message -->
        <div id="introMessage" class="holo-text">Sync Complete: Welcome, Vesta</div>

        <!-- Navigation -->
        <nav>
            <button data-section="inventory" class="holo-text">Cargo</button>
            <button data-section="map" class="holo-text">NavGrid</button>
            <button data-section="email" class="holo-text">Comms</button>
            <button data-section="codex" class="holo-text">Codex</button>
            <button data-section="scanner" class="holo-text">Scan</button>
            <button data-section="vitals" class="holo-text">Vitals</button>
        </nav>

        <!-- Content Panels Wrapper -->
        <div id="contentWrapper">
            <div id="map" class="content-card">
                <h1 class="holo-text">Navigation Grid</h1>
                <div class="panel-content"> <p class="holo-text">Sector Cartography Unavailable // Signal Obstructed</p> </div>
            </div>
            <div id="email" class="content-card">
                <h1 class="holo-text">Communications Terminal</h1>
                 <div class="panel-content">
                    <ul id="emailList"> <!-- Populated by JS --> </ul>
                    <div id="emailContent">
                         <div id="emailPlaceholder" class="holo-text">Awaiting Transmission Selection...</div>
                         <h2 id="emailSubject" style="display: none;" class="holo-text"></h2>
                         <div id="emailMeta" style="display: none;"> <span id="emailSender"></span> <span id="emailDate"></span> </div>
                         <div id="emailBody" style="display: none;"></div>
                    </div>
                 </div>
            </div>
            <div id="codex" class="content-card">
                <h1 class="holo-text">Data Codex Archive</h1>
                <div class="panel-content"> <p class="holo-text">No Valid Archive Connection // Seek Network Node</p> </div>
            </div>
            <div id="scanner" class="content-card">
                <h1 class="holo-text">Integrated Scanner Suite</h1>
                 <div class="panel-content"> <p class="holo-text">Scanner Dormant // Calibrating Sensors...</p> </div>
            </div>
            <div id="vitals" class="content-card">
                <h1 class="holo-text">Biometric Feed</h1>
                 <div class="panel-content"> <p class="holo-text">Telemetry Disrupted // Check Neural Interface Integrity</p> </div>
            </div>
        </div>

      <!-- Inventory Container -->
      <div id="inventoryContainer">
        <div class="inventory-grid">
          <!-- v2.3 placeholder method: slots are empty, JS adds images -->
          <div class="inventory-slot" data-itemid="health_potion_1"></div>
          <div class="inventory-slot" data-itemid="keycard_alpha"></div>
          <div class="inventory-slot" data-itemid="data_fragment_1"></div>
          <div class="inventory-slot"></div> <div class="inventory-slot"></div> <div class="inventory-slot"></div>
          <div class="inventory-slot"></div> <div class="inventory-slot"></div> <div class="inventory-slot"></div>
          <div class="inventory-slot"></div> <div class="inventory-slot"></div> <div class="inventory-slot"></div>
          <div class="inventory-slot"></div> <div class="inventory-slot"></div> <div class="inventory-slot"></div> <div class="inventory-slot"></div>
        </div>
        <div class="item-info">
          <div class="item-details">
            <h2 class="holo-text" id="itemInfoTitle">Cargo Hold</h2>
            <p class="holo-text" id="itemInfoDesc">Select an item for detailed analysis.</p>
          </div>
          <div class="item-actions">
            <button id="itemUseButton" class="holo-text" disabled>Engage</button>
            <button id="itemDropButton" class="holo-text" disabled>Jettison</button>
          </div>
        </div>
      </div>
    </div><!-- End #mainContent -->

    <!-- Three.js canvas element will be prepended here by JS -->

    <script>
        // ----- Global DOM Elements (from v2.3) -----
        const loginPanel = document.getElementById("loginPanel");
        const loginButton = document.getElementById("loginButton");
        const mainContent = document.getElementById("mainContent");
        const navButtons = document.querySelectorAll("nav button[data-section]");
        const contentCards = document.querySelectorAll("#contentWrapper .content-card");
        const inventoryContainer = document.getElementById("inventoryContainer");
        const inventorySlots = document.querySelectorAll(".inventory-slot");
        const itemInfoTitle = document.getElementById("itemInfoTitle");
        const itemInfoDesc = document.getElementById("itemInfoDesc");
        const itemUseButton = document.getElementById("itemUseButton");
        const itemDropButton = document.getElementById("itemDropButton");
        const emailList = document.getElementById("emailList");
        const emailContent = document.getElementById("emailContent");
        const emailPlaceholder = document.getElementById("emailPlaceholder");
        const emailSubjectEl = document.getElementById("emailSubject");
        const emailMetaEl = document.getElementById("emailMeta");
        const emailSenderEl = document.getElementById("emailSender");
        const emailDateEl = document.getElementById("emailDate");
        const emailBodyEl = document.getElementById("emailBody");

        let loadingStartTime; // Used by both UI and Three.js animation timing
        let selectedSlot = null;
        let threeInitialized = false;

        // ----- Dummy Data (Using v2.3 data which includes icons) -----
        const inventoryItems = {
            "health_potion_1": { name: "Medi-Gel (Synth)", description: "Synthetic regenerative compound. Accelerates localized tissue repair for moderate trauma. Single application.", usable: true, icon: 'medigel.svg' },
            "keycard_alpha": { name: "Access Chip: G-Sec", description: "Encoded authorization chip. Permits access to Gamma Sector restricted zones and primary conduits.", usable: false, icon: 'keycard.svg' },
            "data_fragment_1": { name: "Corrupted Data Fragment", description: "A fractured piece of encrypted data. Shows signs of temporal distortion. Requires specialized decryption.", usable: false, icon: 'data_frag.svg' }
        };
        const emails = [ // Using v2.3 emails
             { id: 1, sender: "SysAdmin Core", subject: "Interface Synchronization Complete", date: "Cycle 77.4", body: "Designation: VST-VYN,\n\nYour neural link to the Corridor Interface is stable. Primary systems online.\n\nReminder: Consult integrated Codex protocols before engaging unknown variables. Safety parameters active.\n\nLog anomalies via designated Comms channel.\n\n> SysAdmin Core // Secure Channel", read: false },
             { id: 2, sender: "Logistics Hub 3B", subject: "Standard Issue Loadout Confirmation", date: "Cycle 77.3", body: "Attn: Vesta Vyntarion,\n\nConfirmed dispatch of standard operational kit:\n- Pulse Emitter [Check Scanner Slot - Requires Calibration]\n- Medi-Gel (Synth) x1\n- Access Chip: G-Sec x1\n- Data Fragment (Corrupted) x1 [Origin Unknown - Flagged]\n\nVerify manifest integrity.\n\n> LogHub-3B Automated Dispatch", read: false },
             { id: 3, sender: "ALERT // Security Net", subject: "Anomaly Detected - Sector Gamma - Sub-level 4", date: "Cycle 77.1", body: "PRIORITY ALERT:\n\nUnidentified Chroniton Signature detected - Gamma Sector, Sub-level 4.\n\nWaveform exceeds established safety thresholds by 3 sigmas.\n\nCaution Advisory: Avoid designated zone. Hazard Containment dispatched. Awaiting Threat Assessment.\n\nRECORD ID: CHR-ANOM-9104-G4", read: true },
             { id: 4, sender: "Aris Thorne", subject: "RE: Prosthetic Resonance Query", date: "Cycle 76.9", body: "Vesta,\n\nFollow-up on your query regarding the resonance within your prosthetic housing. My simulations indicate a potential external harmonic influence, likely non-local in origin. The data is incomplete.\n\nKeep your scanner array active. Prioritize logging any exotic energy signatures, *especially* those with temporal characteristics. Forward logs directly to my secure address.\n\nThe answers might be closer than we think.\n\nStay vigilant,\n- Aris", read: false },
        ];

         // ----- Placeholder SVGs (from v2.3) -----
         const svgPlaceholders = { // Using v2.3 SVGs
             empty: `<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 100 100"><rect width="100" height="100" fill="rgba(0,229,255,0.02)"/><path d="M30 70 L70 30 M30 30 L70 70" stroke="rgba(0, 229, 255, 0.1)" stroke-width="3"/><circle cx="50" cy="50" r="25" fill="none" stroke="rgba(0, 229, 255, 0.15)" stroke-width="3" stroke-dasharray="8 4"/></svg>`,
             medigel: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="60" height="60"><defs><linearGradient id="g1" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:hsl(190, 80%, 80%);"/><stop offset="100%" style="stop-color:hsl(190, 90%, 60%);"/></linearGradient><filter id="f1" x="-0.2" y="-0.2" width="1.4" height="1.4"><feGaussianBlur stdDeviation="1"/></filter></defs><path d="M20 10 H44 L50 18 V54 H14 V18 Z" fill="url(#g1)" stroke="hsl(190, 100%, 90%)" stroke-width="1.5"/><path d="M24 22 h16 m-16 6 h16 m-16 6 h10" stroke="hsl(190, 50%, 40%)" stroke-width="3" stroke-linecap="round"/><circle cx="32" cy="48" r="4" fill="hsl(0, 80%, 60%)" filter="url(#f1)"/><circle cx="32" cy="48" r="3" fill="hsl(0, 90%, 70%)" stroke="#fff" stroke-width="0.5"/></svg>`,
             keycard: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="60" height="60"><defs><linearGradient id="g2" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:hsl(270, 70%, 70%);"/><stop offset="100%" style="stop-color:hsl(270, 80%, 50%);"/></linearGradient></defs><rect x="12" y="18" width="40" height="28" rx="4" fill="url(#g2)" stroke="hsl(270, 90%, 80%)" stroke-width="1.5"/><rect x="18" y="24" width="12" height="8" fill="hsl(210, 80%, 70%)" opacity="0.7"/><path d="M34 26 h12 M34 30 h12 M34 34 h8" stroke="hsl(270, 30%, 30%)" stroke-width="2" stroke-linecap="round"/></svg>`,
             data_frag: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="60" height="60"><defs><filter id="f2"><feGaussianBlur stdDeviation="1.5"/></filter></defs><path d="M20 15 L44 15 L50 32 L44 49 L20 49 L14 32 Z" fill="hsl(220, 40%, 25%)" stroke="hsl(220, 60%, 70%)" stroke-width="1.5"/><path d="M20 15 L32 32 L20 49 M44 15 L32 32 L44 49 M24 32 H40" fill="none" stroke="hsl(190, 100%, 60%)" stroke-width="2" stroke-dasharray="3 2" opacity="0.7" filter="url(#f2)"/><path d="M20 15 L44 15 L50 32 L44 49 L20 49 L14 32 Z" fill="none" stroke="hsl(190, 100%, 80%)" stroke-width="0.5" opacity="0.5"/></svg>`
         };
        function getSvgDataUri(svgString) { return `data:image/svg+xml;base64,${btoa(svgString)}`; }

        // ----- UI Logic (Login, Navigation, Inventory, Email - from v2.3) -----
        // Login Handling (incorporates v2.3 shake animation call)
        loginButton.addEventListener("click", function() {
            const username = document.getElementById("username").value.trim();
            const passcode = document.getElementById("passcode").value.trim();
            if (username && passcode) {
                document.body.classList.add("hide-login-bg"); // Uses v1.0 ::before transition
                loginPanel.classList.add("hidden"); // Uses v2.3 #loginPanel transition

                loginPanel.addEventListener('transitionend', () => {
                    if (loginPanel.classList.contains('hidden')) {
                        loginPanel.style.display = "none";
                        mainContent.classList.add("visible"); // Uses v2.3 #mainContent transition

                        if (!threeInitialized) {
                            // loadingStartTime is used by v1.0 animateThreeJS now
                            loadingStartTime = Date.now() * 0.001;
                            if (typeof initThreeJS === 'function') {
                                initThreeJS(); // Call v1.0 init
                                threeInitialized = true;
                            }
                            if (typeof animateThreeJS === 'function') {
                                requestAnimationFrame(animateThreeJS); // Call v1.0 animate
                            }
                        }
                    }
                }, { once: true });

            } else {
                // Use v2.3 shake animation
                loginPanel.style.animation = 'shake 0.5s ease-in-out';
                setTimeout(() => loginPanel.style.animation = '', 500);
            }
        });

        // Navigation & Panel Switching Logic (from v2.3 - Toggle logic)
        navButtons.forEach(btn => {
            btn.addEventListener("click", () => {
                const section = btn.getAttribute("data-section");
                const isInventory = section === "inventory";
                const targetPanel = isInventory ? inventoryContainer : document.getElementById(section);
                if (!targetPanel) return;
                const isAlreadyActive = targetPanel.classList.contains("active");
                navButtons.forEach(b => b.classList.remove("active"));
                contentCards.forEach(card => card.classList.remove("active"));
                inventoryContainer.classList.remove("active");
                if (!isAlreadyActive) {
                    btn.classList.add("active");
                    targetPanel.classList.add("active"); // Uses v2.3 panel transitions
                    if (section === "email") { populateEmailList(); resetEmailContent(); }
                    else if (section === "inventory") { updateInventorySlots(); resetItemInfo(); }
                } else {
                     if (section === "inventory") { resetItemInfo(); selectedSlot = null; }
                     else if (section === "email") { resetEmailContent(); }
                }
            });
        });

        // Inventory Interaction Logic (from v2.3 - uses SVGs)
        function updateInventorySlots() {
            inventorySlots.forEach(slot => {
                const itemId = slot.getAttribute("data-itemid");
                const currentImg = slot.querySelector('img');
                if (itemId && inventoryItems[itemId]) {
                    const item = inventoryItems[itemId];
                    const iconKey = item.icon ? item.icon.split('.')[0] : null;
                    const svgString = svgPlaceholders[iconKey] || svgPlaceholders.empty;
                    if (!currentImg || currentImg.getAttribute('data-current-item') !== itemId) {
                        if (currentImg) slot.removeChild(currentImg);
                        const img = document.createElement('img');
                        img.src = getSvgDataUri(svgString); img.alt = item.name; img.style.opacity = "1";
                        img.setAttribute('data-current-item', itemId); slot.appendChild(img);
                    }
                    slot.style.cursor = 'pointer';
                } else {
                    if (!currentImg || currentImg.getAttribute('data-current-item') !== 'empty') {
                        if (currentImg) slot.removeChild(currentImg);
                        const img = document.createElement('img');
                        img.src = getSvgDataUri(svgPlaceholders.empty); img.alt = "Empty Slot"; img.style.opacity = "0.3";
                        img.setAttribute('data-current-item', 'empty'); slot.appendChild(img);
                    }
                    slot.style.cursor = 'default';
                }
                 if (!itemId && slot.classList.contains('selected')) {
                     slot.classList.remove('selected');
                     if (selectedSlot === slot) { selectedSlot = null; resetItemInfo(); }
                 }
            });
        }
        function resetItemInfo() {
            itemInfoTitle.textContent = "Cargo Hold Analysis"; itemInfoDesc.textContent = "Select an item from the grid for details.";
            itemUseButton.disabled = true; itemDropButton.disabled = true;
            if (selectedSlot) { selectedSlot.classList.remove("selected"); selectedSlot = null; }
        }
        inventorySlots.forEach(slot => {
            slot.addEventListener("click", () => {
                const itemId = slot.getAttribute("data-itemid");
                if (!itemId) { if (selectedSlot) { selectedSlot.classList.remove("selected"); resetItemInfo(); selectedSlot = null; } return; }
                if (slot.classList.contains("selected")) { slot.classList.remove("selected"); selectedSlot = null; resetItemInfo(); }
                else {
                    if (selectedSlot) { selectedSlot.classList.remove("selected"); }
                    slot.classList.add("selected"); selectedSlot = slot;
                    if (inventoryItems[itemId]) {
                        const item = inventoryItems[itemId]; itemInfoTitle.textContent = item.name; itemInfoDesc.textContent = item.description;
                        itemUseButton.disabled = !item.usable; itemDropButton.disabled = false;
                    } else { resetItemInfo(); itemInfoDesc.textContent = "Error: Item data not found."; }
                }
            });
        });
        itemUseButton.addEventListener("click", () => { // v2.3 logic
            if (selectedSlot && !itemUseButton.disabled) {
                const itemId = selectedSlot.getAttribute("data-itemid");
                if (itemId && inventoryItems[itemId]) {
                    console.log(`Used ${inventoryItems[itemId].name}!`);
                    delete inventoryItems[itemId]; selectedSlot.removeAttribute("data-itemid");
                    updateInventorySlots(); resetItemInfo();
                }
            }
        });
        itemDropButton.addEventListener("click", () => { // v2.3 logic
            if (selectedSlot && !itemDropButton.disabled) {
                const itemId = selectedSlot.getAttribute("data-itemid");
                const item = itemId ? inventoryItems[itemId] : null;
                const itemName = item ? item.name : "the selected content";
                if (confirm(`Confirm Jettison: ${itemName}? This action is irreversible.`)) {
                    console.log(`Jettisoned ${itemName}.`);
                    if (itemId) { delete inventoryItems[itemId]; selectedSlot.removeAttribute("data-itemid"); updateInventorySlots(); resetItemInfo(); }
                }
            }
        });

        // Email Section Logic (from v2.3)
        function populateEmailList() {
            emailList.innerHTML = ''; emails.sort((a, b) => b.id - a.id);
            emails.forEach(email => {
                const li = document.createElement('li'); li.setAttribute('data-email-id', email.id);
                li.classList.toggle('read', email.read); li.classList.toggle('unread', !email.read);
                const senderSpan = document.createElement('span'); senderSpan.className = 'sender holo-text'; senderSpan.textContent = email.sender;
                const subjectSpan = document.createElement('span'); subjectSpan.className = 'subject holo-text'; subjectSpan.textContent = email.subject;
                li.appendChild(senderSpan); li.appendChild(subjectSpan);
                li.addEventListener('click', () => {
                    displayEmailContent(email.id);
                    document.querySelectorAll('#emailList li.active').forEach(item => item.classList.remove('active'));
                    li.classList.add('active');
                });
                emailList.appendChild(li);
            });
        }
        function displayEmailContent(emailId) {
            const email = emails.find(e => e.id === emailId);
            if (email) {
                emailPlaceholder.style.display = 'none'; emailSubjectEl.style.display = 'block';
                emailMetaEl.style.display = 'block'; emailBodyEl.style.display = 'block';
                emailSubjectEl.textContent = email.subject;
                // Using v2.3 labels
                emailSenderEl.textContent = `Origin: ${email.sender}`;
                emailDateEl.textContent = `Timestamp: ${email.date}`;
                emailBodyEl.textContent = email.body;
                if (!email.read) {
                    email.read = true; const listItem = emailList.querySelector(`li[data-email-id="${emailId}"]`);
                    if (listItem) { listItem.classList.remove('unread'); listItem.classList.add('read'); }
                }
                emailContent.scrollTop = 0;
            }
        }
        function resetEmailContent() {
            emailPlaceholder.style.display = 'block'; emailSubjectEl.style.display = 'none';
            emailMetaEl.style.display = 'none'; emailBodyEl.style.display = 'none';
            emailSubjectEl.textContent = ''; emailSenderEl.textContent = ''; emailDateEl.textContent = ''; emailBodyEl.textContent = '';
            document.querySelectorAll('#emailList li.active').forEach(item => item.classList.remove('active'));
        }

        // ----- Ripple Effect on Click (from v2.3) -----
        document.addEventListener("click", function(e) {
             if (e.target.closest('button, .inventory-slot, #emailList li, input, .panel-content')) { return; }
            const ripple = document.createElement("div"); ripple.classList.add("ripple");
            const size = Math.max(window.innerWidth, window.innerHeight) * 0.15;
            ripple.style.width = ripple.style.height = size + "px";
            ripple.style.left = e.clientX - size / 2 + "px"; ripple.style.top = e.clientY - size / 2 + "px";
            document.body.appendChild(ripple); ripple.addEventListener("animationend", () => { ripple.remove(); });
        });

        // ----- Three.js Scene & Animation Code (from v1.0) -----
        let scene, camera, renderer;
        let corridor;
        let ceilingMesh, leftWallMesh, rightWallMesh;
        let glyphs = [];
        let globalGlyphFade = 0; // Used by v1.0 updateGlyphs
        const CORRIDOR_SIZE = 2500; // v1.0 size
        let mouse = new THREE.Vector2(0, 0); // Used by v1.0 mouse move
        let targetRotationX = 0, targetRotationY = 0; // Used by v1.0 animate
        let floorTexture, ceilingTexture, leftWallTexture, rightWallTexture; // v1.0 textures
        const SCROLL_SPEED_FLOOR = 0.0007; // v1.0 speed
        const SCROLL_SPEED_CODE = 0.0005; // v1.0 speed
        let plexusGroup; // v1.0 plexus
        // v1.0 repulsion values
        const repulsionDistance = 120;
        const repulsionForce = 1.5;
        const friction = 0.93;

        function initThreeJS() { // v1.0 Function
          scene = new THREE.Scene();
          // v1.0 background and fog
          scene.background = new THREE.Color(0x0d1b2a);
          scene.fog = new THREE.FogExp2(0x0d1b2a, 0.0007); // Using v1.0 fog settings
          camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
          camera.position.set(0, 0, 1800); // v1.0 position
          camera.lookAt(0, 0, 0);

          renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          // v1.0 canvas positioning (already set in CSS)
          // renderer.domElement.style.position = 'fixed';
          // renderer.domElement.style.top = '0';
          // renderer.domElement.style.left = '0';
          // renderer.domElement.style.zIndex = '-1';
          renderer.domElement.id = 'threeCanvas'; // Assign ID for CSS
          document.body.insertBefore(renderer.domElement, document.body.firstChild);

          // v1.0 lighting
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight);
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3); directionalLight.position.set(1, 1, 1).normalize(); scene.add(directionalLight);

          corridor = new THREE.Group(); scene.add(corridor); // v1.0 group

          // v1.0 Textures
          leftWallTexture = createCodeTexture(512); leftWallTexture.wrapS = leftWallTexture.wrapT = THREE.RepeatWrapping; leftWallTexture.repeat.set(4, 5);
          rightWallTexture = createCodeTexture(512); rightWallTexture.wrapS = rightWallTexture.wrapT = THREE.RepeatWrapping; rightWallTexture.repeat.set(4, 5);
          floorTexture = createCodeTexture(512); floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; floorTexture.repeat.set(4, 10);
          ceilingTexture = createCircuitTexture(512); ceilingTexture.wrapS = ceilingTexture.wrapT = THREE.RepeatWrapping; ceilingTexture.repeat.set(2, 2);

          // v1.0 Materials (Phong)
          const leftWallMat = new THREE.MeshPhongMaterial({ map: leftWallTexture, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
          const rightWallMat = new THREE.MeshPhongMaterial({ map: rightWallTexture, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
          const floorMat = new THREE.MeshPhongMaterial({ map: floorTexture, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
          const ceilingMat = new THREE.MeshPhongMaterial({ map: ceilingTexture, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });

          // v1.0 Geometry
          const planeGeo = new THREE.PlaneGeometry(CORRIDOR_SIZE, CORRIDOR_SIZE);
          ceilingMesh = new THREE.Mesh(planeGeo, ceilingMat); ceilingMesh.rotation.x = Math.PI / 2; ceilingMesh.position.y = CORRIDOR_SIZE / 2; corridor.add(ceilingMesh);
          // Note: Walls start off-screen and animate in v1.0 animateThreeJS
          leftWallMesh = new THREE.Mesh(planeGeo, leftWallMat); leftWallMesh.rotation.y = Math.PI / 2; leftWallMesh.position.x = -CORRIDOR_SIZE / 2 - 500;
          corridor.add(leftWallMesh);
          rightWallMesh = new THREE.Mesh(planeGeo, rightWallMat); rightWallMesh.rotation.y = -Math.PI / 2; rightWallMesh.position.x = CORRIDOR_SIZE / 2 + 500;
          corridor.add(rightWallMesh);

          // v1.0 Plexus
          plexusGroup = createScrollingPlexus(); plexusGroup.rotation.x = -0.2; plexusGroup.renderOrder = 1; plexusGroup.scale.set(0, 0, 0); // Start scaled down
          scene.add(plexusGroup);

          // v1.0 Glyphs
          const glyphLetters = ["ᚠ","ᚢ","ᚦ","ᚨ","ᚱ","ᚲ","ᛉ","ᛏ","ᛒ","ᛖ","ᛞ","ᛟ","𐎠","𐎣","𐎫"];
          glyphs = [];
          for (let i = 0; i < 30; i++) {
             const letter = glyphLetters[Math.floor(Math.random() * glyphLetters.length)];
             const sprite = createGlyphSprite(letter); // Uses v1.0 createGlyphSprite
             // v1.0 spawning logic
             if (Math.random() < 0.5) spawnGlyphOnWall(sprite);
             else sprite.position.set((Math.random() - 0.5) * CORRIDOR_SIZE, Math.random() * 1950 - 700, -Math.random() * CORRIDOR_SIZE);
             sprite.userData = { basePosition: sprite.position.clone(), oscillationSpeed: Math.random() * 0.5 + 0.5, velocity: new THREE.Vector3(0, 0, 0), lifetime: 0, maxLifetime: 12 + Math.random() * 12 };
             glyphs.push(sprite); scene.add(sprite);
          }

          // Event listeners (use v1.0 handlers)
          window.addEventListener("resize", onWindowResize, false);
          document.addEventListener("mousemove", onDocumentMouseMove, false);
        }

        function animateThreeJS() { // v1.0 Function
          if (!renderer) return; // Safety check

          requestAnimationFrame(animateThreeJS);
          const time = Date.now() * 0.001;

           // ADAPTED: Use loadingStartTime from UI logic for elapsedTime calculation
           const elapsedTime = threeInitialized && typeof loadingStartTime === 'number' ? (time - loadingStartTime) : 0;

           // Skip updates if not enough time has passed (or first frame after login)
           // Using v1.0 delay check, slightly different threshold
           if (!threeInitialized || elapsedTime <= 0.1) return;

          // v1.0 Glyph fade based on elapsedTime
          const glyphStartDelay = 3.5; globalGlyphFade = (elapsedTime < glyphStartDelay) ? 0 : Math.min((elapsedTime - glyphStartDelay) / 1.5, 1);

          // v1.0 Corridor rotation based on mouse
          corridor.rotation.y += (targetRotationY - corridor.rotation.y) * 0.05;
          corridor.rotation.x += (targetRotationX - corridor.rotation.x) * 0.05;

          // v1.0 Wall animation based on elapsedTime
          const wallAnimDuration = 2.0; const wallStartDelay = 0.5;
          if (elapsedTime >= wallStartDelay && elapsedTime < wallStartDelay + wallAnimDuration) {
            const progress = (elapsedTime - wallStartDelay) / wallAnimDuration; const easeProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);
            leftWallMesh.position.x = (-CORRIDOR_SIZE/2 - 500) + easeProgress * 500;
            rightWallMesh.position.x = (CORRIDOR_SIZE/2 + 500) - easeProgress * 500;
          } else if (elapsedTime >= wallStartDelay + wallAnimDuration) {
            leftWallMesh.position.x = -CORRIDOR_SIZE/2; rightWallMesh.position.x = CORRIDOR_SIZE/2;
          }

          // v1.0 Texture scrolling
          if(floorTexture) floorTexture.offset.y += SCROLL_SPEED_FLOOR;
          if(leftWallTexture) leftWallTexture.offset.y += SCROLL_SPEED_CODE;
          if(rightWallTexture) rightWallTexture.offset.y += SCROLL_SPEED_CODE;
          if(ceilingTexture) ceilingTexture.offset.y -= SCROLL_SPEED_FLOOR * 0.5;

          // v1.0 Plexus animation based on elapsedTime
          const plexusStartDelay = 2.5; const plexusAnimDuration = 1.5;
          if (plexusGroup) {
             if (elapsedTime < plexusStartDelay) { plexusGroup.scale.set(0, 0, 0); }
             else if (elapsedTime < plexusStartDelay + plexusAnimDuration) {
                const s = (elapsedTime - plexusStartDelay) / plexusAnimDuration; const easeS = 0.5 - 0.5 * Math.cos(s * Math.PI); plexusGroup.scale.set(easeS, easeS, easeS);
             } else { plexusGroup.scale.set(1, 1, 1); }
             // Update plexus lines (v1.0 version)
             if (plexusGroup.children.length > 0) { updateScrollingPlexus(plexusGroup.children[0], time); }
          }

          // v1.0 Glyph update
          updateGlyphs();

          renderer.render(scene, camera);
        }

        // --- Helper functions for Three.js (ALL from v1.0) ---
        function createScrollingPlexus(){ // v1.0 ShaderMaterial version
            const group = new THREE.Group(); const nodeCount = 160, threshold = 435, scrollSpeed = 1.0;
            const regionMinX = -1100, regionMaxX = 1100, regionMinY = -1100, regionMaxY = -700; const regionMinZ = -3000, regionMaxZ = 1200;
            const regionWidth = regionMaxX - regionMinX, regionDepth = regionMaxZ - regionMinZ; const nodes = [];
            for (let i = 0; i < nodeCount; i++) { const x = THREE.MathUtils.randFloat(regionMinX, regionMaxX); const y = THREE.MathUtils.randFloat(regionMinY, regionMaxY); const z = THREE.MathUtils.randFloat(regionMinZ, regionMaxZ); const v = new THREE.Vector3(x, y, z); v.userData = { phase: Math.random() * Math.PI * 2, amplitude: 20 + Math.random() * 10, scrollSpeed }; nodes.push(v); }
            const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3)); geometry.setAttribute('uv', new THREE.Float32BufferAttribute([], 2));
            const material = new THREE.ShaderMaterial({ uniforms: { lineColor: { value: new THREE.Color(0x00ccff) }, center: { value: new THREE.Vector2(0.5, 0.5) }, maxDist: { value: 1.0 } }, vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`, fragmentShader: `uniform vec3 lineColor; uniform vec2 center; uniform float maxDist; varying vec2 vUv; void main() { float d = distance(vUv, center); float alpha = 1.0 - smoothstep(0.0, maxDist, d); gl_FragColor = vec4(lineColor, alpha * 0.6); }`, transparent: true, depthTest: true, depthWrite: false });
            const plexusLines = new THREE.LineSegments(geometry, material); plexusLines.frustumCulled = false; plexusLines.renderOrder = 1; plexusLines.userData = { nodes, regionMinX, regionMaxX, regionMinZ, regionMaxZ, regionWidth, regionDepth, threshold }; group.add(plexusLines); return group;
        }
        function updateScrollingPlexus(plexusLines, time) { // v1.0 version
            const geometry = plexusLines.geometry; const { nodes, regionMinX, regionMaxX, regionMinZ, regionMaxZ, regionWidth, regionDepth, threshold } = plexusLines.userData; const positions = []; const uvs = [];
            for (let i = 0; i < nodes.length; i++) { const n = nodes[i]; n.y += Math.sin(time * 0.5 + n.userData.phase) * 0.2; n.z += n.userData.scrollSpeed; if (n.z > regionMaxZ + 200) n.z = regionMinZ - 50; }
            for (let i = 0; i < nodes.length; i++) { for (let j = i + 1; j < nodes.length; j++) { const dist = nodes[i].distanceTo(nodes[j]); if (dist < threshold) { positions.push(nodes[i].x, nodes[i].y, nodes[i].z); positions.push(nodes[j].x, nodes[j].y, nodes[j].z); const u1 = (nodes[i].x - regionMinX) / regionWidth; const v1 = (nodes[i].z - regionMinZ) / regionDepth; const u2 = (nodes[j].x - regionMinX) / regionWidth; const v2 = (nodes[j].z - regionMinZ) / regionDepth; uvs.push(u1, v1); uvs.push(u2, v2); } } }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2)); geometry.attributes.position.needsUpdate = true; geometry.attributes.uv.needsUpdate = true; geometry.computeBoundingSphere();
        }
        function createCodeTexture(size) { // v1.0 version
            const canvas = document.createElement("canvas"); canvas.width = size; canvas.height = size; const ctx = canvas.getContext("2d"); ctx.fillStyle = "#0d1b2a"; ctx.fillRect(0, 0, size, size); ctx.fillStyle = "rgba(0, 204, 255, 0.4)"; ctx.font = "10px monospace"; const codeChars = ["0","1","∑","∆","≈","≠","Ω","π","Σ","Δ","¤","¥","µ","∂","ƒ","Ξ","Ψ","Φ","Λ","Ω"]; const columns = 40, rows = 50; const colWidth = size / columns, rowHeight = size / rows; for (let c = 0; c < columns; c++) { for (let r = 0; r < rows; r++) { const char = codeChars[Math.floor(Math.random() * codeChars.length)]; let x = c * colWidth + colWidth * 0.1; let y = r * rowHeight + rowHeight * 0.8; ctx.fillText(char, x, y); } } return new THREE.CanvasTexture(canvas);
        }
        function createCircuitTexture(size) { // v1.0 version
            const canvas = document.createElement("canvas"); canvas.width = size; canvas.height = size; const ctx = canvas.getContext("2d"); ctx.fillStyle = "#0d1b2a"; ctx.fillRect(0, 0, size, size); const lineCount = 25; for (let i = 0; i < lineCount; i++) { ctx.strokeStyle = "rgba(0, 204, 255, 0.3)"; ctx.lineWidth = Math.random() * 2 + 1; ctx.beginPath(); let x1 = Math.random() * size, y1 = Math.random() * size; let x2 = x1 + (Math.random() - 0.5) * 150, y2 = y1 + (Math.random() - 0.5) * 150; ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); } const arcCount = 15; for (let i = 0; i < arcCount; i++) { ctx.strokeStyle = "rgba(0, 204, 255, 0.3)"; ctx.lineWidth = Math.random() * 2 + 1; ctx.beginPath(); let cx = Math.random() * size, cy = Math.random() * size; let r = Math.random() * 40 + 10; ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.stroke(); } const textCount = 10; ctx.fillStyle = "rgba(0, 204, 255, 0.25)"; ctx.font = "14px monospace"; for (let i = 0; i < textCount; i++) { let tx = Math.random() * size, ty = Math.random() * size; let hexString = Math.floor(Math.random() * 0xffffff).toString(16).toUpperCase(); ctx.fillText(hexString, tx, ty); } return new THREE.CanvasTexture(canvas);
        }
        function onWindowResize() { // v1.0 version
            if(camera && renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        }
        function onDocumentMouseMove(e) { // v1.0 version (updates targetRotation)
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            const maxRotation = 0.08; // v1.0 rotation amount
            targetRotationY = mouse.x * maxRotation; targetRotationX = mouse.y * maxRotation;
        }
        function updateGlyphs() { // v1.0 version (includes repulsion and scaling)
            glyphs.forEach(sprite => { if (!sprite?.userData) return;
                sprite.userData.lifetime += 0.016; const fade = 1 - (sprite.userData.lifetime / sprite.userData.maxLifetime);
                const currentOpacity = Math.max(fade, 0) * globalGlyphFade; sprite.material.opacity = currentOpacity;
                 if (currentOpacity < 0.01 || fade <= 0.05) {
                    sprite.userData.lifetime = 0; sprite.userData.maxLifetime = 12 + Math.random() * 12;
                    if (Math.random() < 0.5) spawnGlyphOnWall(sprite); else sprite.position.set((Math.random() - 0.5) * CORRIDOR_SIZE, Math.random() * 1950 - 700, -Math.random() * CORRIDOR_SIZE);
                     sprite.userData.basePosition.copy(sprite.position); sprite.userData.velocity.set(0, 0, 0); sprite.material.opacity = 1.0 * globalGlyphFade;
                }
                const t = Date.now() * 0.001 * sprite.userData.oscillationSpeed; sprite.position.x = sprite.userData.basePosition.x + Math.sin(t) * 15; sprite.position.y = sprite.userData.basePosition.y + Math.cos(t) * 15;
                 if(camera){
                     const pos = sprite.position.clone(); pos.project(camera);
                     const glyphScreenX = (pos.x * 0.5 + 0.5) * window.innerWidth; const glyphScreenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                     // Use raw mouse here as per v1.0 logic for repulsion target
                     const mouseScreenX = (mouse.x + 1) * 0.5 * window.innerWidth; const mouseScreenY = (-mouse.y + 1) * 0.5 * window.innerHeight;
                     const dist = Math.hypot(glyphScreenX - mouseScreenX, glyphScreenY - mouseScreenY);
                     if (dist < repulsionDistance) { const dx = glyphScreenX - mouseScreenX; const dy = glyphScreenY - mouseScreenY; const angle = Math.atan2(dy, dx); const pushX = Math.cos(angle) * repulsionForce; const pushY = Math.sin(angle) * repulsionForce; sprite.userData.velocity.x += pushX; sprite.userData.velocity.y += pushY; }
                     sprite.userData.velocity.multiplyScalar(friction); sprite.position.x += sprite.userData.velocity.x; sprite.position.y += sprite.userData.velocity.y;
                     // v1.0 scaling
                     const d = camera.position.distanceTo(sprite.position); const minDist = 500, maxDist = 2000; const scaleClose = 400, scaleFar = 200; const clampDist = THREE.MathUtils.clamp(d, minDist, maxDist); const alpha = (clampDist - minDist) / (maxDist - minDist); const finalScale = scaleClose * (1 - alpha) + scaleFar * alpha; sprite.scale.set(finalScale, finalScale, 1);
                }
            });
        }
        function spawnGlyphOnWall(sprite) { // v1.0 version
            const wallTypes = [0, 1, 3]; const wallType = wallTypes[Math.floor(Math.random() * wallTypes.length)]; const offset = 50; let x, y; if (wallType === 0) { x = -CORRIDOR_SIZE / 2 + offset; y = Math.random() * 1950 - 700; } else if (wallType === 1) { x = CORRIDOR_SIZE / 2 - offset; y = Math.random() * 1950 - 700; } else { y = CORRIDOR_SIZE / 2 - offset; x = (Math.random() - 0.5) * CORRIDOR_SIZE; } const z = -Math.random() * CORRIDOR_SIZE; sprite.position.set(x, y, z);
        }
        function createGlyphSprite(letter) { // v1.0 version (simpler)
            const canvas = document.createElement("canvas"); canvas.width = 128; canvas.height = 128; const ctx = canvas.getContext("2d"); ctx.clearRect(0, 0, 128, 128); ctx.font = "100px Arial"; ctx.fillStyle = "rgba(0,204,255,1.0)"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(letter, 64, 64); const texture = new THREE.CanvasTexture(canvas); const material = new THREE.SpriteMaterial({ map: texture, transparent: true, alphaTest: 0.1, sizeAttenuation: true }); const sprite = new THREE.Sprite(material); sprite.renderOrder = 2; sprite.scale.set(120, 120, 1); return sprite;
        }

        // ----- Initial Setup Calls -----
         updateInventorySlots(); // Initialize inventory display (using v2.3 logic)

    </script>
</body>
</html>
