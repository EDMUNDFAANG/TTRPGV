<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Animus Corridor Simulation</title>
  <!-- Include Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Optional: If you need additional controls, you can include OrbitControls here -->
  <style>
    /* Fullscreen canvas with light blue holographic background */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #b3e5fc; /* Holographic light blue */
    }
    canvas {
      display: block;
    }
    /* Navigation overlay styling */
    nav {
      position: fixed;
      top: 0;
      width: 100%;
      background: rgba(0,0,0,0.3);
      padding: 10px;
      display: flex;
      justify-content: center;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0,150,255,0.5);
    }
    nav button {
      background: transparent;
      border: 2px solid rgba(0,150,255,0.7);
      color: rgba(0,150,255,0.7);
      margin: 0 10px;
      padding: 10px 20px;
      cursor: pointer;
      text-transform: uppercase;
      transition: background 0.3s, color 0.3s;
      font-family: Arial, sans-serif;
    }
    nav button:hover, nav button.active {
      background: rgba(0,150,255,0.7);
      color: #fff;
    }
    /* Content sections (for Inventory, Map, etc.) overlaying the scene */
    .content-section {
      position: fixed;
      top: 60px;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 20px;
      color: #000;
      background: rgba(255,255,255,0.8);
      z-index: 10;
      overflow: auto;
      display: none;
    }
    .content-section.active {
      display: block;
    }
  </style>
</head>
<body>
  <!-- Navigation Overlay -->
  <nav>
    <button data-section="inventory" class="active">Inventory</button>
    <button data-section="map">Map</button>
    <button data-section="email">Email</button>
    <button data-section="codex">Codex</button>
    <button data-section="scanner">Scanner</button>
  </nav>
  <!-- Content Sections -->
  <div id="inventory" class="content-section active">
    <h1>Inventory</h1>
    <p>Inventory details go here.</p>
  </div>
  <div id="map" class="content-section">
    <h1>Map</h1>
    <p>Map details go here.</p>
  </div>
  <div id="email" class="content-section">
    <h1>Email</h1>
    <p>Email details go here.</p>
  </div>
  <div id="codex" class="content-section">
    <h1>Codex</h1>
    <p>Codex details go here.</p>
  </div>
  <div id="scanner" class="content-section">
    <h1>Scanner</h1>
    <p>Scanner details go here.</p>
  </div>

  <!-- Three.js will inject the canvas -->
  <script>
    // ===== Navigation Switching =====
    const navButtons = document.querySelectorAll('nav button');
    const contentSections = document.querySelectorAll('.content-section');
    navButtons.forEach(button => {
      button.addEventListener('click', () => {
        const sectionId = button.getAttribute('data-section');
        contentSections.forEach(section => {
          section.classList.toggle('active', section.id === sectionId);
        });
        navButtons.forEach(btn => {
          btn.classList.toggle('active', btn === button);
        });
      });
    });

    // ===== Three.js Setup =====
    let scene, camera, renderer, corridor, glyphs = [];
    let mouse = new THREE.Vector2(0, 0);
    let targetRotationX = 0, targetRotationY = 0;

    init();
    animate();

    function init() {
      // Create scene with a holographic light blue background and fog
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xb3e5fc);
      scene.fog = new THREE.FogExp2(0xb3e5fc, 0.0008);

      // Create perspective camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 10000);
      camera.position.set(0, 0, 500);

      // Renderer with antialiasing
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create the corridor as an open box (missing the front face) using five large planes
      corridor = new THREE.Group();
      const gridTexture = createGridTexture();
      const planeMaterial = new THREE.MeshBasicMaterial({ map: gridTexture, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
      const size = 4000; // overall room size
      const half = size / 2;

      // Floor
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(size, size), planeMaterial);
      floor.rotation.x = -Math.PI/2;
      floor.position.y = -half;
      corridor.add(floor);

      // Ceiling
      const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(size, size), planeMaterial);
      ceiling.rotation.x = Math.PI/2;
      ceiling.position.y = half;
      corridor.add(ceiling);

      // Left Wall
      const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(size, size), planeMaterial);
      leftWall.rotation.y = Math.PI/2;
      leftWall.position.x = -half;
      corridor.add(leftWall);

      // Right Wall
      const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(size, size), planeMaterial);
      rightWall.rotation.y = -Math.PI/2;
      rightWall.position.x = half;
      corridor.add(rightWall);

      // Back Wall
      const backWall = new THREE.Mesh(new THREE.PlaneGeometry(size, size), planeMaterial);
      backWall.position.z = -half;
      backWall.rotation.y = Math.PI;
      corridor.add(backWall);

      scene.add(corridor);

      // Create floating glyphs that drift and react to the cursor
      const glyphLetters = ["Λ", "Δ", "Ω", "ψ", "Σ", "Φ", "Ξ", "Π"];
      for (let i = 0; i < 10; i++) {
        let letter = glyphLetters[Math.floor(Math.random() * glyphLetters.length)];
        let sprite = createGlyphSprite(letter);
        // Position glyph randomly within the corridor
        sprite.position.set(
          (Math.random() - 0.5) * size * 0.6,
          (Math.random() - 0.5) * size * 0.6,
          -Math.random() * size * 0.5  // closer to the viewer than the back wall
        );
        // Save initial position for drifting
        sprite.userData = { basePosition: sprite.position.clone(), speed: Math.random() * 0.5 + 0.5 };
        scene.add(sprite);
        glyphs.push(sprite);
      }

      // Listen for mouse movement for interactive scene rotation and glyph reaction
      document.addEventListener('mousemove', onDocumentMouseMove, false);
      window.addEventListener('resize', onWindowResize, false);
    }

    // Create a canvas texture with a grid of thin, fading white lines on a light blue background
    function createGridTexture() {
      const size = 512;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const context = canvas.getContext('2d');
      // Fill with holographic light blue
      context.fillStyle = "#b3e5fc";
      context.fillRect(0, 0, size, size);
      // Draw thin white grid lines
      context.strokeStyle = "rgba(255,255,255,0.5)";
      context.lineWidth = 1;
      const spacing = 50;
      for (let i = 0; i <= size; i += spacing) {
        context.beginPath();
        context.moveTo(i, 0);
        context.lineTo(i, size);
        context.stroke();
      }
      for (let j = 0; j <= size; j += spacing) {
        context.beginPath();
        context.moveTo(0, j);
        context.lineTo(size, j);
        context.stroke();
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(20, 20);
      return texture;
    }

    // Create a sprite for a glyph (a floating symbol) using a canvas texture
    function createGlyphSprite(letter) {
      const canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      const context = canvas.getContext('2d');
      context.font = "100px Orbitron, sans-serif";
      context.fillStyle = "rgba(255,255,255,0.8)";
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.fillText(letter, 64, 64);
      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(150, 150, 1);
      return sprite;
    }

    // Update mouse coordinates and determine target rotations based on cursor position
    function onDocumentMouseMove(event) {
      // Normalize mouse coordinates to [-1, 1]
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      // Set target rotations (small angles) based on mouse position
      const maxRotation = 0.1; // in radians
      targetRotationY = mouse.x * maxRotation;
      targetRotationX = mouse.y * maxRotation;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Animation loop: update scene rotation and animate glyphs
    function animate() {
      requestAnimationFrame(animate);
      // Smoothly rotate the corridor group to simulate a shifting, infinite space
      corridor.rotation.y += (targetRotationY - corridor.rotation.y) * 0.05;
      corridor.rotation.x += (targetRotationX - corridor.rotation.x) * 0.05;

      // Update each glyph: apply a gentle oscillation and react if the cursor is near
      glyphs.forEach(sprite => {
        let t = Date.now() * 0.001 * sprite.userData.speed;
        // Basic oscillation around the original (base) position
        sprite.position.x = sprite.userData.basePosition.x + Math.sin(t) * 10;
        sprite.position.y = sprite.userData.basePosition.y + Math.cos(t) * 10;
        // Project sprite position to screen space to check proximity to mouse
        let pos = sprite.position.clone();
        pos.project(camera);
        let dx = pos.x - mouse.x;
        let dy = pos.y - mouse.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        // If the mouse is near, push the glyph away slightly
        if(distance < 0.3) {
          let push = (0.3 - distance) * 50;
          sprite.position.x += dx * 0.02 * push;
          sprite.position.y += dy * 0.02 * push;
        }
      });

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
