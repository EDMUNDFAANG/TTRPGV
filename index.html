<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Animus Corridor Simulation</title>
  <!-- Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    /* ===== Reset & Body ===== */
    html, body {
      margin: 0; 
      padding: 0;
      overflow: hidden;
      font-family: "Arial", sans-serif;
      background: #0d1b2a; /* fallback in case WebGL doesn't load */
    }

    /* ===== Canvas ===== */
    canvas {
      display: block;
    }

    /* ===== Navigation Bar ===== */
    nav {
      position: fixed;
      top: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0.4);
      padding: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0,204,255,0.5);
    }
    nav button {
      background: transparent;
      border: 2px solid rgba(0,204,255,0.7);
      color: #00ccff;
      margin: 0 10px;
      padding: 8px 16px;
      cursor: pointer;
      text-transform: uppercase;
      transition: background 0.3s, color 0.3s, transform 0.3s;
      outline: none;
    }
    nav button:hover,
    nav button.active {
      background: #00ccff;
      color: #000;
      transform: scale(1.05);
    }

    /* ===== Centered Content Card ===== */
    .content-card {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60%;
      max-width: 800px;
      padding: 30px;
      color: #fff;
      text-align: center;

      /* Subtle neon border */
      border: 2px solid rgba(0, 204, 255, 0.3);
      border-radius: 20px;
      box-shadow: 0 0 20px rgba(0, 204, 255, 0.2);

      /* Frosted glass effect (where supported) */
      background: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(8px);
      
      z-index: 10;
    }
    .content-card h1 {
      font-size: 2em;
      margin-bottom: 0.5em;
      color: #00ccff;
    }
    .content-card p {
      font-size: 1.1em;
      line-height: 1.6em;
    }
    /* Hide all except "Inventory" by default, or you can adapt to your needs */
    #map, #email, #codex, #scanner {
      display: none;
    }

  </style>
</head>
<body>
  <!-- ===== Navigation ===== -->
  <nav>
    <button data-section="inventory" class="active">Inventory</button>
    <button data-section="map">Map</button>
    <button data-section="email">Email</button>
    <button data-section="codex">Codex</button>
    <button data-section="scanner">Scanner</button>
  </nav>

  <!-- ===== Content Cards ===== -->
  <div id="inventory" class="content-card">
    <h1>Inventory</h1>
    <p>Inventory details go here.</p>
  </div>
  <div id="map" class="content-card">
    <h1>Map</h1>
    <p>Map details go here.</p>
  </div>
  <div id="email" class="content-card">
    <h1>Email</h1>
    <p>Email details go here.</p>
  </div>
  <div id="codex" class="content-card">
    <h1>Codex</h1>
    <p>Codex details go here.</p>
  </div>
  <div id="scanner" class="content-card">
    <h1>Scanner</h1>
    <p>Scanner details go here.</p>
  </div>

  <!-- ===== Three.js Scene ===== -->
  <script>
    let scene, camera, renderer;
    let corridor;
    let glyphs = [];
    let mouse = new THREE.Vector2(0, 0);
    let targetRotationX = 0, targetRotationY = 0;

    // For glyph interaction
    const raycaster = new THREE.Raycaster();

    init();
    animate();

    function init() {
      // Scene & Fog
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0d1b2a);
      // Increase density for heavier fog
      scene.fog = new THREE.FogExp2(0x0d1b2a, 0.0012);

      // Camera
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        1,
        5000
      );
      camera.position.set(0, 0, 800);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
      directionalLight.position.set(1, 1, 1).normalize();
      scene.add(directionalLight);

      // Corridor (open-ended)
      corridor = new THREE.Group();
      const size = 4000;
      const half = size / 2;

      // Corridor material: neon grid
      const gridTexture = createGridTexture();
      const corridorMat = new THREE.MeshPhongMaterial({
        map: gridTexture,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.5
      });

      // Floor
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(size, size),
        corridorMat
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -half;
      corridor.add(floor);

      // Ceiling
      const ceiling = new THREE.Mesh(
        new THREE.PlaneGeometry(size, size),
        corridorMat
      );
      ceiling.rotation.x = Math.PI / 2;
      ceiling.position.y = half;
      corridor.add(ceiling);

      // Left Wall
      const leftWall = new THREE.Mesh(
        new THREE.PlaneGeometry(size, size),
        corridorMat
      );
      leftWall.rotation.y = Math.PI / 2;
      leftWall.position.x = -half;
      corridor.add(leftWall);

      // Right Wall
      const rightWall = new THREE.Mesh(
        new THREE.PlaneGeometry(size, size),
        corridorMat
      );
      rightWall.rotation.y = -Math.PI / 2;
      rightWall.position.x = half;
      corridor.add(rightWall);

      // (No Back Wall) => extends into fog
      scene.add(corridor);

      // Floating glyphs
      const glyphLetters = ["Λ", "Δ", "Ω", "ψ", "Σ", "Φ", "Ξ", "Π"];
      for (let i = 0; i < 25; i++) {
        const letter = glyphLetters[Math.floor(Math.random() * glyphLetters.length)];
        const sprite = createGlyphSprite(letter);
        // random position in the corridor
        sprite.position.set(
          (Math.random() - 0.5) * size * 0.6,
          (Math.random() - 0.5) * size * 0.6,
          -Math.random() * size * 0.5
        );
        sprite.userData = {
          basePosition: sprite.position.clone(),
          speed: Math.random() * 0.5 + 0.5,
          baseScale: sprite.scale.clone()
        };
        scene.add(sprite);
        glyphs.push(sprite);
      }

      // Listeners
      window.addEventListener("resize", onWindowResize, false);
      document.addEventListener("mousemove", onDocumentMouseMove, false);

      // Nav button toggles
      const navButtons = document.querySelectorAll("nav button");
      const sections = ["inventory","map","email","codex","scanner"];
      navButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          const sectionId = btn.getAttribute("data-section");
          // Toggle content
          sections.forEach(s => {
            const el = document.getElementById(s);
            if(s === sectionId) {
              el.style.display = "block";
            } else {
              el.style.display = "none";
            }
          });
          // Toggle active button
          navButtons.forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
        });
      });
    }

    /* Create the neon grid texture for the corridor walls/floor/ceiling */
    function createGridTexture() {
      const size = 512;
      const canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");

      // Fill background
      ctx.fillStyle = "#0d1b2a";
      ctx.fillRect(0, 0, size, size);

      // Neon lines
      ctx.strokeStyle = "rgba(0,204,255,0.4)";
      ctx.lineWidth = 1;
      const spacing = 50;
      for (let x = 0; x <= size; x += spacing) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, size);
        ctx.stroke();
      }
      for (let y = 0; y <= size; y += spacing) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(size, y);
        ctx.stroke();
      }
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      // Repeating to make the grid denser
      texture.repeat.set(10, 10);
      return texture;
    }

    /* Create a floating glyph (sprite) */
    function createGlyphSprite(letter) {
      const canvas = document.createElement("canvas");
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext("2d");

      // Clear & set text style
      ctx.clearRect(0, 0, 128, 128);
      ctx.font = "100px Arial";
      ctx.fillStyle = "rgba(0,204,255,0.8)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(letter, 64, 64);

      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        depthTest: false
      });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(120, 120, 1);
      return sprite;
    }

    /* Handle window resizing */
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    /* Track mouse movement for corridor rotation + glyph hover effect */
    function onDocumentMouseMove(event) {
      // Normalize mouse coordinates to [-1,1]
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Corridor rotation
      const maxRotation = 0.1; // in radians
      targetRotationY = mouse.x * maxRotation;
      targetRotationX = mouse.y * maxRotation;
    }

    /* Animate the scene */
    function animate() {
      requestAnimationFrame(animate);

      // Smooth corridor rotation
      corridor.rotation.y += (targetRotationY - corridor.rotation.y) * 0.05;
      corridor.rotation.x += (targetRotationX - corridor.rotation.x) * 0.05;

      // Update glyph positions & mild "hover" effect
      glyphs.forEach(sprite => {
        // Floating (oscillation)
        const t = Date.now() * 0.001 * sprite.userData.speed;
        sprite.position.x = sprite.userData.basePosition.x + Math.sin(t) * 10;
        sprite.position.y = sprite.userData.basePosition.y + Math.cos(t) * 10;

        // Project glyph position to screen space
        const pos = sprite.position.clone();
        pos.project(camera);
        // Convert to pixel coordinates
        const glyphX = (pos.x * 0.5 + 0.5) * window.innerWidth;
        const glyphY = (pos.y * -0.5 + 0.5) * window.innerHeight;

        // Distance from mouse
        const dist = Math.hypot(glyphX - ( (mouse.x+1)*0.5*window.innerWidth ), glyphY - ( (-mouse.y+1)*0.5*window.innerHeight ));
        // If cursor is within ~100px, scale up a bit
        if (dist < 100) {
          sprite.scale.lerp(new THREE.Vector3(150,150,1), 0.2);
        } else {
          sprite.scale.lerp(sprite.userData.baseScale, 0.2);
        }
      });

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
