<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Animus Corridor Simulation</title>
  <!-- Load Orbitron font -->
  <link href="https://fonts.googleapis.com/css?family=Orbitron" rel="stylesheet">
  <!-- Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    :root {
      --bg-color: #0d1b2a; /* Slightly darker for more contrast? Keep as is? */
      --accent-color: #00ccff;
      --panel-bg: rgba(0, 0, 0, 0.4);
      --text-color: rgba(0, 204, 255, 0.9);
      --border-color: rgba(0,204,255,0.3);
      --hover-border-color: rgba(0,204,255,0.6);
      --active-bg: rgba(0,204,255,0.2);
    }
    /* ===== Reset & Base Styles ===== */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: var(--bg-color); /* Base background */
      font-family: 'Orbitron', sans-serif;
      color: var(--text-color);
    }
    canvas {
      display: block;
      position: fixed; /* Ensure canvas stays fixed */
      top: 0;
      left: 0;
      z-index: -1; /* Place canvas behind all other content */
    }

    /* ===== Holographic Text Style ===== */
    .holo-text {
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-shadow: 0 0 3px rgba(0,204,255,0.8), 0 0 6px rgba(0,204,255,0.5);
      color: var(--text-color);
      opacity: 0.95;
    }

    /* ===== Login Panel Styling & Transition ===== */
    #loginPanel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(1);
      width: 300px;
      padding: 30px;
      border: 2px solid var(--border-color);
      border-radius: 20px;
      background: var(--panel-bg);
      backdrop-filter: blur(8px); /* Slightly increased blur */
      text-align: center;
      z-index: 400; /* Above canvas */
      opacity: 1;
      transition: opacity 0.6s ease-out, transform 0.6s ease-out;
      pointer-events: auto;
    }
    #loginPanel.hidden {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
        pointer-events: none;
    }

    #loginPanel input {
      width: 90%;
      margin: 10px 0;
      padding: 8px;
      border: 1px solid var(--accent-color);
      border-radius: 4px;
      background: transparent;
      color: var(--accent-color);
      font-family: 'Orbitron', sans-serif;
      font-size: 1em;
      text-align: center;
    }
    #loginPanel button {
      margin-top: 10px;
      padding: 8px 16px;
      border: 2px solid var(--accent-color);
      background: transparent;
      color: var(--accent-color);
      cursor: pointer;
      transition: background 0.3s;
      font-family: 'Orbitron', sans-serif;
    }
    #loginPanel button:hover {
      background: var(--active-bg);
    }

    /* ===== Main Content (hidden until login) ===== */
    #mainContent {
      display: block;
      opacity: 0;
      transition: opacity 1.5s ease-in;
      transition-delay: 0.5s; /* Delay fade-in until login panel fades out */
      pointer-events: none;
    }
    #mainContent.visible {
        opacity: 1;
        pointer-events: auto;
    }

    /* ===== Intro Message Overlay ===== */
    #introMessage {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2.5em;
      z-index: 300; /* Below login, above nav initially */
      opacity: 0;
      animation: introAnim 3s forwards;
      animation-delay: 0.8s; /* Delay slightly more to follow login fade */
    }
    @keyframes introAnim {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      40% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
    }

    /* ===== Navigation Bar ===== */
    nav {
      position: fixed;
      top: 20px;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 200; /* Above canvas/plexus, below panels */
      background: rgba(0,0,0,0.5);
      padding: 10px;
      box-shadow: 0 0 10px rgba(0,204,255,0.5);
      backdrop-filter: blur(5px);
      opacity: 0;
      animation: navFadeIn 1s forwards;
      animation-delay: 2.5s; /* Delay more to sync with mainContent fade */
    }
    @keyframes navFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    nav button {
      background: transparent;
      border: 2px solid var(--accent-color);
      margin: 0 10px;
      padding: 8px 16px;
      cursor: pointer;
      text-transform: uppercase;
      transition: background 0.3s, color 0.3s, transform 0.3s;
      outline: none;
      opacity: 0;
      transform: translateY(-20px);
      animation: buttonFadeIn 0.8s forwards;
      color: var(--text-color);
    }
    /* Adjust delays to follow nav fade-in */
    nav button[data-section="inventory"] { animation-delay: 2.7s; }
    nav button[data-section="map"] { animation-delay: 2.9s; }
    nav button[data-section="email"] { animation-delay: 3.1s; }
    nav button[data-section="codex"] { animation-delay: 3.3s; }
    nav button[data-section="scanner"] { animation-delay: 3.5s; }
    nav button[data-section="vitals"] { animation-delay: 3.7s; }

    @keyframes buttonFadeIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    nav button:hover,
    nav button.active {
      background: var(--active-bg);
      color: #FFF;
      transform: scale(1.05) translateY(0);
    }

    /* ===== Content Panels Wrapper ===== */
    #contentWrapper {
      /* No specific styles needed now panels handle their own fade/transform */
    }

    /* ===== Floating UI Panels ===== */
    .content-card {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      width: 70%;
      max-width: 900px;
      height: 60vh;
      max-height: 600px;
      padding: 25px;
      border: 2px solid var(--border-color);
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0,204,255,0.2);
      background: var(--panel-bg);
      backdrop-filter: blur(10px);
      z-index: 100; /* Below nav, above canvas/plexus */
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease, transform 0.5s ease;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .content-card.active {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
      animation: panelActivate 0.5s ease-out forwards;
    }
    @keyframes panelActivate {
        from { transform: translate(-50%, -50%) scale(0.98); }
        to { transform: translate(-50%, -50%) scale(1); }
    }
    .content-card h1 {
      margin: 0 0 15px 0;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-color);
      text-align: center;
      flex-shrink: 0;
    }
    .content-card .panel-content {
       flex-grow: 1;
       overflow-y: auto;
       padding-right: 10px;
    }
     /* Custom Scrollbar */
    .panel-content::-webkit-scrollbar { width: 8px; }
    .panel-content::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 4px; }
    .panel-content::-webkit-scrollbar-thumb { background-color: var(--accent-color); border-radius: 4px; border: 2px solid var(--panel-bg); }

    /* ===== Inventory Container Styling ===== */
   #inventoryContainer {
      display: none; /* Hidden by default */
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      z-index: 150; /* Above other cards */
      width: 800px;
      height: 550px;
      padding: 20px;
      background: var(--panel-bg);
      backdrop-filter: blur(10px);
      border: 2px solid var(--border-color);
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0,204,255,0.2);
      flex-direction: row;
      gap: 20px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease, transform 0.5s ease;
   }
   #inventoryContainer.active {
      display: flex;
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
      animation: panelActivate 0.5s ease-out forwards;
    }

    .inventory-grid {
      flex: 2;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
      grid-auto-rows: 90px;
      gap: 10px;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow-y: auto;
      align-content: start;
    }
     /* Custom Scrollbar */
    .inventory-grid::-webkit-scrollbar { width: 6px; }
    .inventory-grid::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 3px;}
    .inventory-grid::-webkit-scrollbar-thumb { background-color: var(--accent-color); border-radius: 3px; border: 1px solid var(--panel-bg); }

    .inventory-slot {
      width: 100%;
      height: 100%;
      border: 2px solid var(--border-color);
      border-radius: 8px;
      background: rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: border-color 0.3s, background-color 0.3s;
      cursor: pointer;
      position: relative;
    }
    .inventory-slot:hover {
      border-color: var(--hover-border-color);
      background-color: rgba(0, 204, 255, 0.1);
    }
     .inventory-slot.selected {
        border-color: var(--accent-color);
        background-color: rgba(0, 204, 255, 0.15);
        box-shadow: 0 0 8px var(--accent-color);
    }
    .inventory-slot img {
      max-width: 85%;
      max-height: 85%;
      object-fit: contain;
    }

    /* Item Info Panel Styling */
    .item-info {
      flex: 1;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: rgba(0,0,0,0.1);
      padding: 15px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    .item-details {
        flex-grow: 1;
        overflow-y: auto;
        margin-bottom: 15px;
    }
    /* Custom Scrollbar */
    .item-details::-webkit-scrollbar { width: 6px; }
    .item-details::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 3px;}
    .item-details::-webkit-scrollbar-thumb { background-color: var(--accent-color); border-radius: 3px; border: 1px solid var(--panel-bg); }

    .item-info h2 {
      margin: 0 0 10px 0;
      font-size: 1.3em;
      color: var(--accent-color);
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 5px;
    }
    .item-info p {
      font-size: 0.95em;
      line-height: 1.5;
      color: var(--text-color);
    }
    .item-actions {
        flex-shrink: 0;
        text-align: right;
    }
    .item-actions button {
      background: transparent;
      border: 2px solid var(--accent-color);
      color: var(--accent-color);
      margin-left: 10px;
      padding: 8px 16px;
      cursor: pointer;
      text-transform: uppercase;
      transition: background 0.3s, color 0.3s;
      font-family: 'Orbitron', sans-serif;
    }
    .item-actions button:hover {
      background: var(--active-bg);
      color: #FFF;
    }
     .item-actions button:disabled {
        border-color: rgba(0, 204, 255, 0.2);
        color: rgba(0, 204, 255, 0.3);
        cursor: not-allowed;
        background: transparent;
    }

    /* ===== Email Section Styling ===== */
    #email .panel-content {
        display: flex;
        gap: 15px;
        padding: 15px 0 0 0;
    }
    #emailList {
        flex: 1;
        list-style: none;
        padding: 0;
        margin: 0;
        border-right: 1px solid var(--border-color);
        overflow-y: auto;
        padding-right: 15px;
        max-height: calc(60vh - 100px);
    }
     /* Custom Scrollbar */
    #emailList::-webkit-scrollbar { width: 6px; }
    #emailList::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 3px;}
    #emailList::-webkit-scrollbar-thumb { background-color: var(--accent-color); border-radius: 3px; border: 1px solid var(--panel-bg); }

    #emailList li {
        padding: 10px 12px;
        border: 1px solid transparent;
        border-bottom: 1px solid rgba(0, 204, 255, 0.15);
        margin-bottom: 5px;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s, border-color 0.3s;
    }
    #emailList li:hover {
        background-color: rgba(0, 204, 255, 0.08);
        border-color: rgba(0, 204, 255, 0.2);
    }
    #emailList li.active {
        background-color: var(--active-bg);
        border-color: var(--accent-color);
        box-shadow: 0 0 5px rgba(0, 204, 255, 0.3);
    }
    #emailList li .sender {
        font-weight: bold;
        display: block;
        margin-bottom: 3px;
        color: var(--accent-color);
    }
    #emailList li .subject {
        font-size: 0.9em;
        color: var(--text-color);
    }
    #emailList li.read .subject { opacity: 0.7; }
     #emailList li.unread::before {
        content: '●';
        color: var(--accent-color);
        font-size: 0.8em;
        margin-right: 8px;
        display: inline-block;
    }

    #emailContent {
        flex: 2;
        padding: 0 10px;
        overflow-y: auto;
        max-height: calc(60vh - 100px);
    }
     /* Custom Scrollbar */
    #emailContent::-webkit-scrollbar { width: 6px; }
    #emailContent::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 3px;}
    #emailContent::-webkit-scrollbar-thumb { background-color: var(--accent-color); border-radius: 3px; border: 1px solid var(--panel-bg); }

    #emailContent h2 {
        font-size: 1.4em;
        color: var(--accent-color);
        margin: 0 0 15px 0;
        padding-bottom: 5px;
        border-bottom: 1px solid var(--border-color);
    }
    #emailContent .email-meta {
        font-size: 0.85em;
        color: rgba(0, 204, 255, 0.7);
        margin-bottom: 20px;
    }
     #emailContent .email-meta span { display: block; }
    #emailContent .email-body {
        font-size: 0.95em;
        line-height: 1.6;
        white-space: pre-wrap;
    }
    #emailPlaceholder {
      text-align: center;
      margin-top: 50px;
      font-size: 1.1em;
      color: rgba(0, 204, 255, 0.6);
    }

    /* ===== Refined Ripple Effect ===== */
    .ripple {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(0,204,255,0.15) 5%, rgba(0,204,255,0.08) 25%, rgba(0,204,255,0) 55%);
      transform: scale(0);
      pointer-events: none;
      animation: ripple-effect 0.7s ease-out;
      z-index: 50; /* Below panels/nav, above canvas */
    }
    @keyframes ripple-effect {
      0% { transform: scale(0); opacity: 0.6; }
      70% { transform: scale(1.5); opacity: 0.3; }
      100% { transform: scale(2.0); opacity: 0; }
    }

    /* ===== Other Section Placeholders ===== */
    #map .panel-content p,
    #codex .panel-content p,
    #scanner .panel-content p,
    #vitals .panel-content p {
        padding-top: 20px;
        font-size: 1.1em;
        text-align: center;
    }

  </style>
</head>
<body>
  <!-- Three.js canvas will be inserted here by JS -->

  <!-- ===== Login Panel ===== -->
  <div id="loginPanel">
    <h1 class="holo-text">Access Required</h1>
    <input type="text" id="username" placeholder="Username" value="Vesta"/>
    <input type="password" id="passcode" placeholder="Passcode" value="password" />
    <button id="loginButton" class="holo-text">Initiate Link</button>
  </div>

  <!-- ===== Main Content (hidden until login) ===== -->
  <div id="mainContent">
    <!-- ===== Intro Message ===== -->
    <div id="introMessage" class="holo-text">Welcome, Vesta Vyntarion.</div>

    <!-- ===== Navigation ===== -->
    <nav>
      <button data-section="inventory" class="holo-text">Inventory</button>
      <button data-section="map" class="holo-text">Map</button>
      <button data-section="email" class="holo-text">Email</button>
      <button data-section="codex" class="holo-text">Codex</button>
      <button data-section="scanner" class="holo-text">Scanner</button>
      <button data-section="vitals" class="holo-text">Vitals</button>
    </nav>

    <!-- ===== Content Panels Wrapper ===== -->
    <div id="contentWrapper">
      <div id="map" class="content-card">
        <h1 class="holo-text">Navigation Grid</h1>
        <div class="panel-content">
           <p class="holo-text">Stellar Cartography Data Unavailable.</p>
        </div>
      </div>
      <div id="email" class="content-card">
        <h1 class="holo-text">Comms Terminal</h1>
         <div class="panel-content">
            <ul id="emailList"></ul>
            <div id="emailContent">
                 <div id="emailPlaceholder" class="holo-text">Select a message from the terminal list.</div>
                 <h2 id="emailSubject" style="display: none;"></h2>
                 <div id="emailMeta" style="display: none;">
                     <span id="emailSender"></span>
                     <span id="emailDate"></span>
                 </div>
                 <div id="emailBody" style="display: none;"></div>
            </div>
         </div>
      </div>
      <div id="codex" class="content-card">
        <h1 class="holo-text">Data Codex</h1>
        <div class="panel-content">
           <p class="holo-text">No entries found. Connect to Archive Node.</p>
        </div>
      </div>
      <div id="scanner" class="content-card">
        <h1 class="holo-text">Environmental Scanner</h1>
         <div class="panel-content">
            <p class="holo-text">Scanner inactive. Awaiting target lock.</p>
        </div>
      </div>
      <div id="vitals" class="content-card">
        <h1 class="holo-text">Biometrics</h1>
         <div class="panel-content">
            <p class="holo-text">Telemetry offline. Check neural link.</p>
        </div>
      </div>
    </div>

  <!-- ===== New Inventory Container (initially hidden) ===== -->
  <div id="inventoryContainer">
    <div class="inventory-grid">
      <div class="inventory-slot" data-itemid="health_potion_1"><img src="placeholder.png" alt="Item"></div>
      <div class="inventory-slot" data-itemid="keycard_alpha"><img src="placeholder.png" alt="Item"></div>
      <div class="inventory-slot"></div><div class="inventory-slot"></div><div class="inventory-slot"></div><div class="inventory-slot"></div>
      <div class="inventory-slot"></div><div class="inventory-slot"></div><div class="inventory-slot"></div><div class="inventory-slot"></div>
      <div class="inventory-slot"></div><div class="inventory-slot"></div><div class="inventory-slot"></div><div class="inventory-slot"></div>
      <div class="inventory-slot"></div><div class="inventory-slot"></div>
    </div>
    <div class="item-info">
      <div class="item-details">
        <h2 class="holo-text" id="itemInfoTitle">Item(s)</h2>
        <p class="holo-text" id="itemInfoDesc">Select an item from the grid.</p>
      </div>
      <div class="item-actions">
        <button id="itemUseButton" class="holo-text" disabled>Use</button>
        <button id="itemDropButton" class="holo-text" disabled>Drop</button>
      </div>
    </div>
  </div>

  <script>
    // ----- Global DOM Elements -----
    const loginPanel = document.getElementById("loginPanel");
    const loginButton = document.getElementById("loginButton");
    const mainContent = document.getElementById("mainContent");
    const navButtons = document.querySelectorAll("nav button[data-section]");
    const contentCards = document.querySelectorAll("#contentWrapper .content-card");
    const inventoryContainer = document.getElementById("inventoryContainer");
    const inventorySlots = document.querySelectorAll(".inventory-slot");
    const itemInfoTitle = document.getElementById("itemInfoTitle");
    const itemInfoDesc = document.getElementById("itemInfoDesc");
    const itemUseButton = document.getElementById("itemUseButton");
    const itemDropButton = document.getElementById("itemDropButton");
    const emailList = document.getElementById("emailList");
    const emailContent = document.getElementById("emailContent");
    const emailPlaceholder = document.getElementById("emailPlaceholder");
    const emailSubjectEl = document.getElementById("emailSubject");
    const emailMetaEl = document.getElementById("emailMeta");
    const emailSenderEl = document.getElementById("emailSender");
    const emailDateEl = document.getElementById("emailDate");
    const emailBodyEl = document.getElementById("emailBody");

    let loggedIn = false; // Flag to track login state
    let loginCompleteTime = Infinity; // Time when login finishes

    // ----- Dummy Data -----
    const inventoryItems = {
        "health_potion_1": { name: "Medi-Gel (Basic)", description: "Standard issue regen-gel. Seals minor wounds and provides temporary pain relief. Single use.", usable: true },
        "keycard_alpha": { name: "Access Key (Gestalt-Class-Ship): Sector Gamma", description: "Standard personnel keycard. Grants access to Gamma Sector maintenance hatches and common areas. (The depths floor.)", usable: false },
    };
    const emails = [
        { id: 1, sender: "System Operations", subject: "Holo-Pad Calibration", date: "G34.1", body: "Personnel VST-VYN,\n\nYour connection to the Holo-Pad is confirmed. All core systems nominal.\n\nRemember to consult the Data Codex for operational procedures and review safety protocols.\n\nReport any anomalies immediately via the designated channel.\n\n- GestOps Command", read: false },
        { id: 2, sender: "Quartermaster Unit 7", subject: "Inventory Manifest Update", date: "G34.0", body: "Attn: V. Vyntarion,\n\nYour starting equipment has been dispatched:\n- Standard Issue Sidearm (Check Scanner Slot)\n- Medi-Gel (Basic) x2\n- Access Key: Sector Alpha\n\nConfirm receipt.\n\n- QM-7", read: false },
        { id: 3, sender: "WARNING - Automated Alert", subject: "Energy Fluctuation Detected - Sector Gamma", date: "G33.9", body: "ALERT: Unidentified energy signature detected originating from Sector Gamma.\n\n Gestalt-Drive Null Magnitude exceeds standard operational parameters.\n\nProceed with caution. Avoid area until cleared by Hazard Containment.\n\nRECORD ID: AE-8873-G", read: true },
        { id: 4, sender: "Dr. Aris T.", subject: "Re: Research Query", date: "G33.8", body: "Vesta,\n\nRegarding your query for your prosthetic container, I have a few key pieces of newfound information. My studies suggest an external influence, but I lack sufficient data.\n\nKeep your scanner active. Any unusual energy readings, especially temporal signatures, forward them to me directly.\n\nStay safe,\nAris", read: false },
    ];

    // ----- Login Handling -----
    loginButton.addEventListener("click", function() {
      const username = document.getElementById("username").value.trim();
      const passcode = document.getElementById("passcode").value.trim();
      if (username && passcode && !loggedIn) {
        loggedIn = true; // Set flag
        loginCompleteTime = Date.now() * 0.001 + 0.6; // Mark time when fade finishes

        loginPanel.classList.add("hidden");

        loginPanel.addEventListener('transitionend', () => {
            loginPanel.style.display = "none";
            mainContent.classList.add("visible");
            // Three.js is already running, main content fade controlled by CSS
        }, { once: true });

      } else if (!loggedIn) {
        alert("Access denied. Credentials required.");
      }
    });

    // ----- Navigation & Panel Switching Logic -----
    navButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        // Only allow interaction after login is fully complete
        if (!loggedIn || (Date.now() * 0.001 < loginCompleteTime + 1.0)) return; // Add slight delay

        const section = btn.getAttribute("data-section");
        navButtons.forEach(b => b.classList.remove("active"));
        contentCards.forEach(card => card.classList.remove("active"));
        inventoryContainer.classList.remove("active");

        btn.classList.add("active");

        if (section === "inventory") {
          inventoryContainer.classList.add("active");
        } else {
          const targetCard = document.getElementById(section);
          if (targetCard) {
            targetCard.classList.add("active");
            if (section === "email") {
                populateEmailList();
                resetEmailContent();
            }
          }
        }
      });
    });

    // ----- Inventory Interaction Logic -----
    let selectedSlot = null;
    inventorySlots.forEach(slot => {
        slot.addEventListener("click", () => {
            // Only allow interaction after login is fully complete
            if (!loggedIn || (Date.now() * 0.001 < loginCompleteTime + 1.0)) return;

            const itemId = slot.getAttribute("data-itemid");
            if (selectedSlot) { selectedSlot.classList.remove("selected"); }

            if (itemId && inventoryItems[itemId]) {
                const item = inventoryItems[itemId];
                itemInfoTitle.textContent = item.name;
                itemInfoDesc.textContent = item.description;
                itemUseButton.disabled = !item.usable;
                itemDropButton.disabled = false;
                slot.classList.add("selected");
                selectedSlot = slot;
            } else {
                itemInfoTitle.textContent = "Empty Slot";
                itemInfoDesc.textContent = "This inventory slot is empty.";
                itemUseButton.disabled = true;
                itemDropButton.disabled = true;
                slot.classList.add("selected");
                selectedSlot = slot;
            }
        });
        // Placeholder SVG generation
        const img = slot.querySelector('img');
        if (img && img.src.includes('placeholder.png')) {
            const placeholderSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 100 100"><rect width="100" height="100" fill="rgba(0,204,255,0.05)"/><line x1="20" y1="20" x2="80" y2="80" stroke="rgba(0,204,255,0.2)" stroke-width="5"/><line x1="80" y1="20" x2="20" y2="80" stroke="rgba(0,204,255,0.2)" stroke-width="5"/><circle cx="50" cy="50" r="30" fill="none" stroke="rgba(0,204,255,0.3)" stroke-width="5"/></svg>`;
            img.src = `data:image/svg+xml;base64,${btoa(placeholderSvg)}`;
            img.style.opacity = "0.5";
        }
    });
    itemUseButton.addEventListener("click", () => { /* ... unchanged ... */
         if (selectedSlot && !itemUseButton.disabled) {
            const itemId = selectedSlot.getAttribute("data-itemid");
            alert(`Used ${inventoryItems[itemId].name}!`);
        }
    });
    itemDropButton.addEventListener("click", () => { /* ... unchanged ... */
        if (selectedSlot && !itemDropButton.disabled) {
            const itemId = selectedSlot.getAttribute("data-itemid");
            const itemName = itemId ? inventoryItems[itemId].name : "Empty Slot";
             if (confirm(`Are you sure you want to drop ${itemName}?`)) {
                alert(`Dropped ${itemName}.`);
                 if (itemId) {
                     selectedSlot.removeAttribute("data-itemid");
                      const img = selectedSlot.querySelector('img');
                      if(img) {
                        const placeholderSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 100 100"><rect width="100" height="100" fill="rgba(0,204,255,0.05)"/><line x1="20" y1="20" x2="80" y2="80" stroke="rgba(0,204,255,0.2)" stroke-width="5"/><line x1="80" y1="20" x2="20" y2="80" stroke="rgba(0,204,255,0.2)" stroke-width="5"/><circle cx="50" cy="50" r="30" fill="none" stroke="rgba(0,204,255,0.3)" stroke-width="5"/></svg>`;
                        img.src = `data:image/svg+xml;base64,${btoa(placeholderSvg)}`;
                        img.style.opacity = "0.5";
                      }
                     itemInfoTitle.textContent = "Empty Slot";
                     itemInfoDesc.textContent = "This inventory slot is empty.";
                     itemUseButton.disabled = true;
                     itemDropButton.disabled = true;
                     selectedSlot.classList.remove("selected");
                     selectedSlot = null;
                 }
            }
        }
    });

    // ----- Email Section Logic -----
    function populateEmailList() { /* ... unchanged ... */
        emailList.innerHTML = '';
        emails.sort((a, b) => b.id - a.id);
        emails.forEach(email => {
            const li = document.createElement('li');
            li.setAttribute('data-email-id', email.id);
            li.classList.toggle('read', email.read);
            li.classList.toggle('unread', !email.read);
            const senderSpan = document.createElement('span');
            senderSpan.className = 'sender holo-text'; senderSpan.textContent = email.sender;
            const subjectSpan = document.createElement('span');
            subjectSpan.className = 'subject holo-text'; subjectSpan.textContent = email.subject;
            li.appendChild(senderSpan); li.appendChild(subjectSpan);
            li.addEventListener('click', () => {
                displayEmailContent(email.id);
                document.querySelectorAll('#emailList li').forEach(item => item.classList.remove('active'));
                li.classList.add('active');
            });
            emailList.appendChild(li);
        });
    }
    function displayEmailContent(emailId) { /* ... unchanged ... */
        const email = emails.find(e => e.id === emailId);
        if (email) {
            emailPlaceholder.style.display = 'none';
            emailSubjectEl.style.display = 'block'; emailMetaEl.style.display = 'block'; emailBodyEl.style.display = 'block';
            emailSubjectEl.textContent = email.subject;
            emailSenderEl.textContent = `From: ${email.sender}`; emailDateEl.textContent = `Received: ${email.date}`;
            emailBodyEl.textContent = email.body;
            if (!email.read) {
                email.read = true;
                const listItem = emailList.querySelector(`li[data-email-id="${emailId}"]`);
                if (listItem) { listItem.classList.remove('unread'); listItem.classList.add('read'); }
            }
            emailContent.scrollTop = 0;
        }
    }
     function resetEmailContent() { /* ... unchanged ... */
        emailPlaceholder.style.display = 'block';
        emailSubjectEl.style.display = 'none'; emailMetaEl.style.display = 'none'; emailBodyEl.style.display = 'none';
        document.querySelectorAll('#emailList li').forEach(item => item.classList.remove('active'));
    }

    // ----- Ripple Effect on Click -----
    document.addEventListener("click", function(e) { /* ... unchanged ... */
        if (e.target.closest('button, .inventory-slot, #emailList li, #loginPanel')) { return; } // Avoid on login panel too
        const ripple = document.createElement("div"); ripple.classList.add("ripple");
        const size = Math.min(window.innerWidth, window.innerHeight) * 0.6;
        ripple.style.width = ripple.style.height = size + "px";
        ripple.style.left = e.clientX - size / 2 + "px"; ripple.style.top = e.clientY - size / 2 + "px";
        document.body.appendChild(ripple);
        ripple.addEventListener("animationend", () => { ripple.remove(); });
    });


    // ----- Three.js Scene & Animation Code -----
    let scene, camera, renderer;
    let corridor;
    let ceilingMesh, leftWallMesh, rightWallMesh;
    let glyphs = [];
    let globalGlyphFade = 0;
    const CORRIDOR_SIZE = 2500;
    let mouse = new THREE.Vector2(0, 0);
    let targetRotationX = 0, targetRotationY = 0;
    let floorTexture, ceilingTexture;
    let leftWallTextureData, rightWallTextureData; // Store texture data { texture, canvas, ctx, size }
    const SCROLL_SPEED_FLOOR = 0.0007;
    const SCROLL_SPEED_CODE = 0.0005;
    let plexusGroup;
    const repulsionDistance = 120;
    const repulsionForce = 1.5;
    const friction = 0.93;
    let textureUpdateCounter = 0; // For throttling texture updates
    const TEXTURE_UPDATE_INTERVAL = 4; // Update textures every X frames
    const codeChars = ["0","1","∑","∆","≈","≠","Ω","π","Σ","Δ","¤","¥","µ","∂","ƒ","Ξ","Ψ","Φ","Λ","Ω","▓","▒","░","█"]; // Added block chars

    function initThreeJS() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0d1b2a);
      scene.fog = new THREE.FogExp2(0x0d1b2a, 0.0007); // Keep existing fog
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
      camera.position.set(0, 0, 1800);
      camera.lookAt(0, 0, 0);
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Use alpha for potential future layering?
      renderer.setSize(window.innerWidth, window.innerHeight);
      // Style is set in CSS now to ensure z-index=-1
      document.body.insertBefore(renderer.domElement, document.body.firstChild); // Insert canvas at the beginning

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
      directionalLight.position.set(1, 1, 1).normalize();
      scene.add(directionalLight);

      corridor = new THREE.Group();
      scene.add(corridor);

      // Create textures using helper, store data object
      leftWallTextureData = createCodeTexture(512);
      leftWallTextureData.texture.wrapS = leftWallTextureData.texture.wrapT = THREE.RepeatWrapping;
      leftWallTextureData.texture.repeat.set(4, 5);

      rightWallTextureData = createCodeTexture(512);
      rightWallTextureData.texture.wrapS = rightWallTextureData.texture.wrapT = THREE.RepeatWrapping;
      rightWallTextureData.texture.repeat.set(4, 5);

      // Floor texture can remain static for now unless requested otherwise
      floorTexture = createCodeTexture(512).texture; // Just get the texture
      floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
      floorTexture.repeat.set(4, 10);

      ceilingTexture = createCircuitTexture(512);
      ceilingTexture.wrapS = ceilingTexture.wrapT = THREE.RepeatWrapping;
      ceilingTexture.repeat.set(2, 2);

      // Use the .texture property from the data objects
      const leftWallMat = new THREE.MeshPhongMaterial({ map: leftWallTextureData.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
      const rightWallMat = new THREE.MeshPhongMaterial({ map: rightWallTextureData.texture, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
      const floorMat = new THREE.MeshPhongMaterial({ map: floorTexture, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
      const ceilingMat = new THREE.MeshPhongMaterial({ map: ceilingTexture, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });

      const planeGeo = new THREE.PlaneGeometry(CORRIDOR_SIZE, CORRIDOR_SIZE);
      ceilingMesh = new THREE.Mesh(planeGeo, ceilingMat);
      ceilingMesh.rotation.x = Math.PI / 2;
      ceilingMesh.position.y = CORRIDOR_SIZE / 2;
      corridor.add(ceilingMesh);

      leftWallMesh = new THREE.Mesh(planeGeo, leftWallMat);
      leftWallMesh.rotation.y = Math.PI / 2;
      leftWallMesh.position.x = -CORRIDOR_SIZE / 2 - 500; // Start off-screen
      corridor.add(leftWallMesh);

      rightWallMesh = new THREE.Mesh(planeGeo, rightWallMat);
      rightWallMesh.rotation.y = -Math.PI / 2;
      rightWallMesh.position.x = CORRIDOR_SIZE / 2 + 500; // Start off-screen
      corridor.add(rightWallMesh);

      // Create plexus, start slightly scaled down and transparent for pre-login view
      plexusGroup = createScrollingPlexus();
      plexusGroup.rotation.x = -0.2;
      plexusGroup.renderOrder = 1;
      plexusGroup.scale.set(0.5, 0.5, 0.5); // Start smaller
      if (plexusGroup.children.length > 0 && plexusGroup.children[0].material.uniforms.plexusColor) {
         plexusGroup.children[0].material.uniforms.plexusColor.value.setScalar(0.6); // Start fainter
         plexusGroup.children[0].material.uniforms.fogFar.value = -500; // Start fog closer initially
      }
      scene.add(plexusGroup);

      // Glyphs creation (unchanged logic, but they won't fade in until later)
      const glyphLetters = ["ᚠ","ᚢ","ᚦ","ᚨ","ᚱ","ᚲ","ᛉ","ᛏ","ᛒ","ᛖ","ᛞ","ᛟ","𐎠","𐎣","𐎫"];
      for (let i = 0; i < 30; i++) { /* ... unchanged glyph setup ... */
        const letter = glyphLetters[Math.floor(Math.random() * glyphLetters.length)];
        const sprite = createGlyphSprite(letter);
        if (Math.random() < 0.5) spawnGlyphOnWall(sprite);
        else sprite.position.set((Math.random() - 0.5) * CORRIDOR_SIZE, Math.random() * 1950 - 700, -Math.random() * CORRIDOR_SIZE);
        sprite.userData = { basePosition: sprite.position.clone(), oscillationSpeed: Math.random() * 0.5 + 0.5, velocity: new THREE.Vector3(0, 0, 0), lifetime: 0, maxLifetime: 12 + Math.random() * 12 };
        sprite.material.opacity = 0; // Start invisible
        glyphs.push(sprite);
        scene.add(sprite);
      }


      window.addEventListener("resize", onWindowResize, false);
      document.addEventListener("mousemove", onDocumentMouseMove, false);
    }

    function animateThreeJS() {
      requestAnimationFrame(animateThreeJS);
      const time = Date.now() * 0.001;
      const timeSinceLoginComplete = loggedIn ? time - loginCompleteTime : -Infinity;

      corridor.rotation.y += (targetRotationY - corridor.rotation.y) * 0.05;
      corridor.rotation.x += (targetRotationX - corridor.rotation.x) * 0.05;

      // --- Animations based on Login State ---

      // 1. Wall Animation (Only if logged in)
      const wallAnimDuration = 2.0;
      const wallStartDelay = 0.1; // Start sliding slightly after login starts fading
      if (loggedIn && time >= loginCompleteTime - 0.6 + wallStartDelay) { // Start based on login click time
          const wallElapsedTime = time - (loginCompleteTime - 0.6 + wallStartDelay);
          if (wallElapsedTime < wallAnimDuration) {
            const progress = wallElapsedTime / wallAnimDuration;
            const easeProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI); // Ease-in-out
            leftWallMesh.position.x = (-CORRIDOR_SIZE/2 - 500) + easeProgress * 500;
            rightWallMesh.position.x = (CORRIDOR_SIZE/2 + 500) - easeProgress * 500;
          } else {
            // Ensure final position and enable texture updates
             if (leftWallMesh.position.x !== -CORRIDOR_SIZE / 2) { // Check avoids repeated updates
                leftWallMesh.position.x = -CORRIDOR_SIZE / 2;
                rightWallMesh.position.x = CORRIDOR_SIZE / 2;
             }
             // Update dynamic textures only after walls are in place
             textureUpdateCounter++;
             if(textureUpdateCounter >= TEXTURE_UPDATE_INTERVAL) {
                updateCodeTexture(leftWallTextureData);
                updateCodeTexture(rightWallTextureData);
                textureUpdateCounter = 0;
             }
          }
      }

      // 2. Plexus Animation (Fade/Scale up after login)
      const plexusStartDelay = 0.5; // Delay relative to login fade start
      const plexusAnimDuration = 1.5;
       if (loggedIn && time >= loginCompleteTime - 0.6 + plexusStartDelay) {
           const plexusElapsedTime = time - (loginCompleteTime - 0.6 + plexusStartDelay);
           if (plexusElapsedTime < plexusAnimDuration) {
                const s = plexusElapsedTime / plexusAnimDuration;
                const easeS = 0.5 - 0.5 * Math.cos(s * Math.PI); // Ease-in-out scale
                const finalScale = 1.0;
                const startScale = 0.5;
                const currentScale = startScale + (finalScale - startScale) * easeS;
                plexusGroup.scale.set(currentScale, currentScale, currentScale);

                // Fade in color and adjust fog distance
                if (plexusGroup.children.length > 0 && plexusGroup.children[0].material.uniforms.plexusColor) {
                    const startAlpha = 0.6;
                    const finalAlpha = 1.0; // Or slightly less if preferred, e.g., 0.9
                    plexusGroup.children[0].material.uniforms.plexusColor.value.setScalar(startAlpha + (finalAlpha - startAlpha) * easeS);

                    const startFog = -500;
                    const finalFog = -1500; // Push fog further back
                    plexusGroup.children[0].material.uniforms.fogFar.value = startFog + (finalFog - startFog) * easeS;
                }
           } else if (plexusGroup.scale.x !== 1.0) { // Set final state once
                plexusGroup.scale.set(1, 1, 1);
                if (plexusGroup.children.length > 0 && plexusGroup.children[0].material.uniforms.plexusColor) {
                    plexusGroup.children[0].material.uniforms.plexusColor.value.setScalar(1.0); // Final alpha
                     plexusGroup.children[0].material.uniforms.fogFar.value = -1500; // Final fog distance
                }
           }
       }

      // 3. Glyph Fade In (After main content starts appearing)
      const glyphStartDelay = 1.0; // Relative to login fade finishing
      if (timeSinceLoginComplete >= glyphStartDelay) {
         globalGlyphFade = Math.min((timeSinceLoginComplete - glyphStartDelay) / 1.5, 1); // Slower fade in
      } else {
         globalGlyphFade = 0;
      }
      updateGlyphs(); // Update glyphs regardless, opacity handles visibility

      // --- Constant Animations ---
      floorTexture.offset.y += SCROLL_SPEED_FLOOR;
      leftWallTextureData.texture.offset.y += SCROLL_SPEED_CODE;
      rightWallTextureData.texture.offset.y += SCROLL_SPEED_CODE;
      ceilingTexture.offset.y -= SCROLL_SPEED_FLOOR * 0.5;

      if (plexusGroup && plexusGroup.children.length > 0) {
        updateScrollingPlexus(plexusGroup.children[0], time);
      }

      renderer.render(scene, camera);
    }

    // --- Helper functions for Three.js ---

    // Returns an object: { texture, canvas, ctx, size }
    function createCodeTexture(size) {
        const canvas = document.createElement("canvas");
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "#0d1b2a"; // Match background
        ctx.fillRect(0, 0, size, size);
        ctx.fillStyle = "rgba(0, 204, 255, 0.4)"; // Base color
        ctx.font = "10px monospace";

        const columns = Math.floor(size / 10); // Adjust density if needed
        const rows = Math.floor(size / 10);
        const colWidth = size / columns;
        const rowHeight = size / rows;

        // Initial draw (same as before)
        for (let c = 0; c < columns; c++) {
            for (let r = 0; r < rows; r++) {
                const char = codeChars[Math.floor(Math.random() * codeChars.length)];
                ctx.fillText(char, c * colWidth, r * rowHeight + rowHeight * 0.8);
            }
        }
        const texture = new THREE.CanvasTexture(canvas);
        // Return all needed parts for later updates
        return { texture, canvas, ctx, size };
    }

    // Function to update the code texture dynamically
    function updateCodeTexture(textureData) {
        const { texture, canvas, ctx, size } = textureData;
        const columns = Math.floor(size / 10);
        const rows = Math.floor(size / 10);
        const colWidth = size / columns;
        const rowHeight = size / rows;

        const updates = Math.floor(columns * rows * 0.05); // Update % of chars each time

        ctx.fillStyle = "rgba(0, 204, 255, 0.4)"; // Set draw style
        ctx.font = "10px monospace";

        for (let i = 0; i < updates; i++) {
            const r = Math.floor(Math.random() * rows);
            const c = Math.floor(Math.random() * columns);
            const x = c * colWidth;
            const yBase = r * rowHeight;
            const yText = yBase + rowHeight * 0.8;

            // Slightly clear the old char
            ctx.fillStyle = "#0d1b2a"; // Background color
            ctx.fillRect(x, yBase, colWidth * 1.1, rowHeight * 1.1); // Clear slightly larger area

            // Draw a new char
            const char = codeChars[Math.floor(Math.random() * codeChars.length)];
            ctx.fillStyle = "rgba(0, 204, 255, " + (0.3 + Math.random() * 0.3) + ")"; // Vary opacity slightly
            ctx.fillText(char, x, yText);
        }

        texture.needsUpdate = true; // Tell Three.js to re-upload the texture
    }


    function createScrollingPlexus(){
        const group = new THREE.Group();
        const nodeCount = 160, threshold = 435, scrollSpeed = 1.0;
        const regionMinX = -1100, regionMaxX = 1100, regionMinY = -1100, regionMaxY = -700;
        const regionMinZ = -3000, regionMaxZ = 1200;
        const regionWidth = regionMaxX - regionMinX, regionDepth = regionMaxZ - regionMinZ;
        const nodes = [];
        for (let i = 0; i < nodeCount; i++) { /* ... node setup unchanged ... */
            const x = THREE.MathUtils.randFloat(regionMinX, regionMaxX);
            const y = THREE.MathUtils.randFloat(regionMinY, regionMaxY);
            const z = THREE.MathUtils.randFloat(regionMinZ, regionMaxZ);
            const v = new THREE.Vector3(x, y, z);
            v.userData = { phase: Math.random() * Math.PI * 2, amplitude: 20 + Math.random() * 10, scrollSpeed };
            nodes.push(v);
        }
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
        // geometry.setAttribute('uv', new THREE.Float32BufferAttribute([], 2)); // UVs not needed for depth fog

        // REFINED PLEXUS SHADER
        const material = new THREE.ShaderMaterial({
            uniforms: {
                // Use 'value: new THREE.Color(...).multiplyScalar(alpha)' for initial faintness
                plexusColor: { value: new THREE.Color(0x00ccff) },
                // Fog parameters (adjust these values)
                fogNear: { value: -200.0 }, // Z distance where fog starts
                fogFar: { value: -1500.0 }   // Z distance where fog is max (lines are faint)
            },
            vertexShader: `
                varying float vDepth; // Pass depth to fragment shader
                void main() {
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vDepth = mvPosition.z; // Store depth (negative value gets larger further away)
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform vec3 plexusColor;
                uniform float fogNear;
                uniform float fogFar;
                varying float vDepth;
                void main() {
                    // Calculate fog factor (0 = max fog, 1 = no fog)
                    // smoothstep clamps and interpolates smoothly between edges
                    float fogFactor = smoothstep(fogFar, fogNear, vDepth); // Reverse near/far because depth is negative

                    gl_FragColor = vec4(plexusColor, fogFactor * 0.7); // Apply fogFactor to alpha (adjust base alpha 0.7 if needed)
                }
            `,
            transparent: true,
            depthTest: true, // Keep depth testing
            depthWrite: false // Don't write to depth buffer (good for transparency)
        });

        const plexusLines = new THREE.LineSegments(geometry, material);
        plexusLines.frustumCulled = false; plexusLines.renderOrder = 1; // Render after solid objects if any
        plexusLines.userData = { nodes, regionMinX, regionMaxX, regionMinZ, regionMaxZ, regionWidth, regionDepth, threshold };
        group.add(plexusLines);
        return group;
    }

    function updateScrollingPlexus(plexusLines, time) {
        const geometry = plexusLines.geometry;
        const { nodes, regionMinX, regionMaxX, regionMinZ, regionMaxZ, regionWidth, regionDepth, threshold } = plexusLines.userData;
        const positions = [];
        // const uvs = []; // Not needed for this shader

        for (let i = 0; i < nodes.length; i++) {
            const n = nodes[i];
            n.y += Math.sin(time * 0.5 + n.userData.phase) * 0.2;
            n.z += n.userData.scrollSpeed;
            if (n.z > regionMaxZ + 200) n.z = regionMinZ - 50;
        }
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const dist = nodes[i].distanceTo(nodes[j]);
                if (dist < threshold) {
                    positions.push(nodes[i].x, nodes[i].y, nodes[i].z);
                    positions.push(nodes[j].x, nodes[j].y, nodes[j].z);
                    // UV calculation removed
                }
            }
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        // geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2)); // UV attribute removed
        geometry.attributes.position.needsUpdate = true;
        // geometry.attributes.uv.needsUpdate = true; // UV update removed
        geometry.computeBoundingSphere(); // Still useful for culling if enabled
    }

    function createCircuitTexture(size) { /* ... unchanged ... */
        const canvas = document.createElement("canvas"); canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext("2d"); ctx.fillStyle = "#0d1b2a"; ctx.fillRect(0, 0, size, size);
        const lineCount = 25;
        for (let i = 0; i < lineCount; i++) { ctx.strokeStyle = "rgba(0, 204, 255, 0.3)"; ctx.lineWidth = Math.random() * 2 + 1; ctx.beginPath();
            let x1 = Math.random() * size, y1 = Math.random() * size; let x2 = x1 + (Math.random() - 0.5) * 150, y2 = y1 + (Math.random() - 0.5) * 150;
            ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); }
        const arcCount = 15;
        for (let i = 0; i < arcCount; i++) { ctx.strokeStyle = "rgba(0, 204, 255, 0.3)"; ctx.lineWidth = Math.random() * 2 + 1; ctx.beginPath();
            let cx = Math.random() * size, cy = Math.random() * size; let r = Math.random() * 40 + 10;
            ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.stroke(); }
        const textCount = 10; ctx.fillStyle = "rgba(0, 204, 255, 0.25)"; ctx.font = "14px monospace";
        for (let i = 0; i < textCount; i++) { let tx = Math.random() * size, ty = Math.random() * size;
            let hexString = Math.floor(Math.random() * 0xffffff).toString(16).toUpperCase(); ctx.fillText(hexString, tx, ty); }
        return new THREE.CanvasTexture(canvas);
    }
    function onWindowResize() { /* ... unchanged ... */
        camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function onDocumentMouseMove(e) { /* ... unchanged ... */
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        const maxRotation = 0.08; targetRotationY = mouse.x * maxRotation; targetRotationX = mouse.y * maxRotation;
    }
    function updateGlyphs() { /* ... unchanged (uses globalGlyphFade now) ... */
        glyphs.forEach(sprite => {
            sprite.userData.lifetime += 0.016; const fade = 1 - (sprite.userData.lifetime / sprite.userData.maxLifetime);
            sprite.material.opacity = Math.max(fade, 0) * globalGlyphFade; // Use global fade factor
            if (sprite.material.opacity < 0.01 && globalGlyphFade > 0.9) { // Only reset if fully visible & faded out
                sprite.userData.lifetime = 0; sprite.userData.maxLifetime = 12 + Math.random() * 12;
                if (Math.random() < 0.5) spawnGlyphOnWall(sprite);
                else sprite.position.set((Math.random() - 0.5) * CORRIDOR_SIZE, Math.random() * 1950 - 700, -Math.random() * CORRIDOR_SIZE);
                sprite.userData.basePosition.copy(sprite.position); sprite.userData.velocity.set(0, 0, 0);
                // Opacity is set at the start of the function based on global fade
            }
            // Oscillation
            const t = Date.now() * 0.001 * sprite.userData.oscillationSpeed;
            sprite.position.x = sprite.userData.basePosition.x + Math.sin(t) * 15;
            sprite.position.y = sprite.userData.basePosition.y + Math.cos(t) * 15;
            // Mouse repulsion
            const pos = sprite.position.clone(); pos.project(camera);
            const glyphScreenX = (pos.x * 0.5 + 0.5) * window.innerWidth; const glyphScreenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
            const mouseScreenX = (mouse.x + 1) * 0.5 * window.innerWidth; const mouseScreenY = (-mouse.y + 1) * 0.5 * window.innerHeight;
            const dist = Math.hypot(glyphScreenX - mouseScreenX, glyphScreenY - mouseScreenY);
            if (dist < repulsionDistance) {
                const dx = glyphScreenX - mouseScreenX; const dy = glyphScreenY - mouseScreenY; const angle = Math.atan2(dy, dx);
                const forceFactor = (repulsionDistance - dist) / repulsionDistance; // Stronger push when closer
                const pushX = Math.cos(angle) * repulsionForce * forceFactor; const pushY = Math.sin(angle) * repulsionForce * forceFactor;
                sprite.userData.velocity.x += pushX; sprite.userData.velocity.y += pushY;
            }
            // Apply friction and move
            sprite.userData.velocity.multiplyScalar(friction);
            sprite.position.x += sprite.userData.velocity.x; sprite.position.y += sprite.userData.velocity.y;
            // Scale based on distance
            const d = camera.position.distanceTo(sprite.position);
            const minDist = 500, maxDist = 2000; const scaleClose = 400, scaleFar = 200;
            const clampDist = THREE.MathUtils.clamp(d, minDist, maxDist); const alpha = (clampDist - minDist) / (maxDist - minDist);
            const finalScale = scaleClose * (1 - alpha) + scaleFar * alpha;
            sprite.scale.set(finalScale, finalScale, 1);
        });
    }
    function spawnGlyphOnWall(sprite) { /* ... unchanged ... */
        // Removed redundant wallTypes array
        const wallType = Math.random(); // 0 to <1
        const offset = 50; let x, y, z = -Math.random() * CORRIDOR_SIZE;

        if (wallType < 0.33) { // Left wall
             x = -CORRIDOR_SIZE / 2 + offset; y = Math.random() * 1950 - 700;
        } else if (wallType < 0.66) { // Right wall
             x = CORRIDOR_SIZE / 2 - offset; y = Math.random() * 1950 - 700;
        } else { // Ceiling (approximated) - might need adjustment based on CORRIDOR_SIZE
             y = CORRIDOR_SIZE / 2 - offset; x = (Math.random() - 0.5) * CORRIDOR_SIZE;
        }
        sprite.position.set(x, y, z);
    }
    function createGlyphSprite(letter) { /* ... unchanged ... */
        const canvas = document.createElement("canvas"); canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext("2d"); ctx.clearRect(0, 0, 128, 128);
        ctx.font = "100px Arial"; ctx.fillStyle = "rgba(0,204,255,1.0)"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(letter, 64, 64); const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true, alphaTest: 0.1, sizeAttenuation: true });
        const sprite = new THREE.Sprite(material); sprite.renderOrder = 2; sprite.scale.set(120, 120, 1);
        return sprite;
    }

    // --- Start Execution ---
    initThreeJS();
    animateThreeJS();

  </script>
</body>
</html>

--- END OF REFINED FILE index (3).html ---
