<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Animus Corridor Simulation</title>
  <!-- Load Orbitron font for a futuristic, robotic look -->
  <link href="https://fonts.googleapis.com/css?family=Orbitron" rel="stylesheet">
  <!-- Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    :root {
      --bg-color: #0d1b2a;
      --accent-color: #00ccff;
      --panel-bg: rgba(0, 0, 0, 0.3);
    }
    /* ===== Reset & Base Styles ===== */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: var(--bg-color);
      font-family: 'Orbitron', sans-serif;
    }
    canvas {
      display: block;
    }

    /* ===== Holographic Text Style (Refined for crispness) ===== */
    .holo-text {
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-shadow: 0 0 2px rgba(0,204,255,0.8), 0 0 5px rgba(0,204,255,0.5);
      /* Use a repeating SVG pattern for subtle detail */
      background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200'%3E%3Cdefs%3E%3Cpattern id='p' patternUnits='userSpaceOnUse' width='200' height='200'%3E%3Ccircle cx='100' cy='100' r='50' stroke='rgba(0,204,255,0.3)' stroke-width='2' fill='none' /%3E%3Cline x1='0' y1='0' x2='200' y2='200' stroke='rgba(0,204,255,0.3)' stroke-width='2' /%3E%3C/pattern%3E%3C/defs%3E%3Crect width='200' height='200' fill='url(%23p)' /%3E%3C/svg%3E") repeat;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      opacity: 0.95;
    }
    
    /* ===== Login Panel (covers the screen initially) ===== */
    #loginPanel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 300px;
      padding: 30px;
      border: 2px solid rgba(0,204,255,0.3);
      border-radius: 20px;
      background: var(--panel-bg);
      backdrop-filter: blur(8px);
      text-align: center;
      z-index: 400;
    }
    #loginPanel input {
      width: 90%;
      margin: 10px 0;
      padding: 8px;
      border: 1px solid var(--accent-color);
      border-radius: 4px;
      background: transparent;
      color: var(--accent-color);
      font-family: 'Orbitron', sans-serif;
      font-size: 1em;
      text-align: center;
    }
    #loginPanel button {
      margin-top: 10px;
      padding: 8px 16px;
      border: 2px solid var(--accent-color);
      background: transparent;
      color: var(--accent-color);
      cursor: pointer;
      transition: background 0.3s;
      font-family: 'Orbitron', sans-serif;
    }
    #loginPanel button:hover {
      background: rgba(0,204,255,0.3);
    }

    /* ===== Main Content (hidden until login) ===== */
    #mainContent {
      display: none;
    }
    
    /* ===== Intro Message Overlay ===== */
    #introMessage {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2.5em;
      z-index: 300;
      opacity: 0;
      animation: introAnim 3s forwards;
    }
    @keyframes introAnim {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
      }
      40% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* ===== Navigation Bar ===== */
    nav {
      position: fixed;
      top: 20px;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 200;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      box-shadow: 0 0 10px rgba(0,204,255,0.5);
      backdrop-filter: blur(5px);
      opacity: 0;
      animation: navFadeIn 1s forwards;
      animation-delay: 3s;
    }
    @keyframes navFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    /* Initially hide buttons with a slight upward offset */
    nav button {
      background: transparent;
      border: 2px solid var(--accent-color);
      margin: 0 10px;
      padding: 8px 16px;
      cursor: pointer;
      text-transform: uppercase;
      transition: background 0.3s, color 0.3s, transform 0.3s;
      outline: none;
      opacity: 0;
      transform: translateY(-20px);
      animation: buttonFadeIn 0.8s forwards;
    }
    /* Staggered delays ‚Äì center "email" appears first */
    nav button[data-section="email"] { animation-delay: 3.2s; }
    nav button[data-section="inventory"] { animation-delay: 3.4s; }
    nav button[data-section="map"] { animation-delay: 3.6s; }
    nav button[data-section="codex"] { animation-delay: 3.8s; }
    nav button[data-section="scanner"] { animation-delay: 4.0s; }
    @keyframes buttonFadeIn {
      from { opacity: 0; transform: translateY(-20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    nav button:hover,
    nav button.active {
      background: rgba(0,204,255,0.4);
      color: #000;
      transform: scale(1.05);
    }
    
    /* ===== Content Wrapper for Floating UI Panels ===== */
    #contentWrapper {
      opacity: 0;
      animation: contentFadeIn 1s forwards;
      animation-delay: 3.2s;
    }
    @keyframes contentFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    /* ===== Floating UI Panels ===== */
    .content-card {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      width: 60%;
      max-width: 800px;
      padding: 30px;
      border: 2px solid rgba(0,204,255,0.3);
      border-radius: 20px;
      box-shadow: 0 0 20px rgba(0,204,255,0.2);
      background: var(--panel-bg);
      backdrop-filter: blur(8px);
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease, transform 0.5s ease;
    }
    .content-card.active {
      opacity: 1;
      pointer-events: auto;
      transform: translate(-50%, -50%) scale(1);
    }
    .content-card h1, .content-card p {
      margin: 0;
    }
    
    /* ===== Refined Ripple Effect ===== */
    .ripple {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(0,204,255,0.45) 15%, rgba(0,204,255,0.2) 50%, rgba(0,204,255,0) 70%);
      transform: scale(0);
      pointer-events: none;
      animation: ripple-effect 1.2s ease-out;
      z-index: 50;
    }
    .ripple::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border: 1px dashed rgba(0,204,255,0.35);
      border-radius: 50%;
      animation: ripple-lines 1.2s ease-out;
    }
    @keyframes ripple-effect {
      0% { transform: scale(0); opacity: 0.95; }
      50% { transform: scale(1.8); opacity: 0.7; }
      100% { transform: scale(3.5); opacity: 0; }
    }
    @keyframes ripple-lines {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(3.5); opacity: 0; }
    }
  </style>
</head>
<body>
  <!-- ===== Login Panel ===== -->
  <div id="loginPanel" class="content-card">
    <h1 class="holo-text">Access Required</h1>
    <input type="text" id="username" placeholder="Username" />
    <input type="password" id="passcode" placeholder="Passcode" />
    <button id="loginButton">Enter</button>
  </div>

  <!-- ===== Main Content (hidden until login) ===== -->
  <div id="mainContent">
    <!-- ===== Intro Message ===== -->
    <div id="introMessage" class="holo-text">Welcome, Vesta Vyntarion.</div>
    
    <!-- ===== Navigation ===== -->
    <nav>
      <button data-section="inventory" class="active holo-text">Inventory</button>
      <button data-section="map" class="holo-text">Map</button>
      <button data-section="email" class="holo-text">Email</button>
      <button data-section="codex" class="holo-text">Codex</button>
      <button data-section="scanner" class="holo-text">Scanner</button>
    </nav>
    
    <!-- ===== Content Panels Wrapper ===== -->
    <div id="contentWrapper">
      <div id="inventory" class="content-card active">
        <h1 class="holo-text">Inventory</h1>
        <p class="holo-text">Inventory details go here.</p>
      </div>
      <div id="map" class="content-card">
        <h1 class="holo-text">Map</h1>
        <p class="holo-text">Map details go here.</p>
      </div>
      <div id="email" class="content-card">
        <h1 class="holo-text">Email</h1>
        <p class="holo-text">Email details go here.</p>
      </div>
      <div id="codex" class="content-card">
        <h1 class="holo-text">Codex</h1>
        <p class="holo-text">Codex details go here.</p>
      </div>
      <div id="scanner" class="content-card">
        <h1 class="holo-text">Scanner</h1>
        <p class="holo-text">Scanner details go here.</p>
      </div>
    </div>
  </div>

  <!-- ===== Three.js Scene & Animus Corridor Simulation ===== -->
  <script>
    let scene, camera, renderer;
    let corridor;
    let ceilingMesh, leftWallMesh, rightWallMesh;
    let glyphs = [];
    let globalGlyphFade = 0; // Global factor for glyph opacity

    const CORRIDOR_SIZE = 2500;

    // Mouse & rotation targets
    let mouse = new THREE.Vector2(0, 0);
    let targetRotationX = 0, targetRotationY = 0;

    // Textures for faces
    let floorTexture, ceilingTexture, leftWallTexture, rightWallTexture;

    // Scrolling speeds
    const SCROLL_SPEED_FLOOR = 0.0007;
    const SCROLL_SPEED_CODE = 0.0005;

    // Plexus group
    let plexusGroup;

    // Repulsion for glyphs
    const repulsionDistance = 120;
    const repulsionForce = 1.5;
    const friction = 0.93;

    // Variables for loading sequence
    let loadingStartTime = 0; // Will be set after login

    // ----- Login Handling -----
    document.getElementById("loginButton").addEventListener("click", function() {
      const username = document.getElementById("username").value.trim();
      const passcode = document.getElementById("passcode").value.trim();
      if (username && passcode) {
        // Hide login panel and show main content
        document.getElementById("loginPanel").style.display = "none";
        document.getElementById("mainContent").style.display = "block";
        // Start the animation sequence
        loadingStartTime = Date.now() * 0.001;
        init();
        animate();
      } else {
        alert("Please enter both username and passcode.");
      }
    });

    function init() {
      // Scene & Fog
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0d1b2a);
      scene.fog = new THREE.FogExp2(0x0d1b2a, 0.0007);

      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
      camera.position.set(0, 0, 1800);
      camera.lookAt(0, 0, 0);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
      directionalLight.position.set(1, 1, 1).normalize();
      scene.add(directionalLight);

      // Corridor Group
      corridor = new THREE.Group();
      scene.add(corridor);

      // ====== Code Textures for Walls & "Floor" ======
      leftWallTexture = createCodeTexture(512);
      leftWallTexture.wrapS = leftWallTexture.wrapT = THREE.RepeatWrapping;
      leftWallTexture.repeat.set(4, 5);

      rightWallTexture = createCodeTexture(512);
      rightWallTexture.wrapS = rightWallTexture.wrapT = THREE.RepeatWrapping;
      rightWallTexture.repeat.set(4, 5);

      // Floor texture (unused)
      floorTexture = createCodeTexture(512);
      floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
      floorTexture.repeat.set(4, 10);

      // Ceiling uses a circuit texture
      ceilingTexture = createCircuitTexture(512);
      ceilingTexture.wrapS = ceilingTexture.wrapT = THREE.RepeatWrapping;
      ceilingTexture.repeat.set(2, 2);

      // Materials
      const leftWallMat = new THREE.MeshPhongMaterial({
        map: leftWallTexture,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.7
      });
      const rightWallMat = new THREE.MeshPhongMaterial({
        map: rightWallTexture,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.7
      });
      const floorMat = new THREE.MeshPhongMaterial({
        map: floorTexture,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.7
      });
      const ceilingMat = new THREE.MeshPhongMaterial({
        map: ceilingTexture,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.7
      });

      // Create geometry for the corridor
      const planeGeo = new THREE.PlaneGeometry(CORRIDOR_SIZE, CORRIDOR_SIZE);

      // === Ceiling ===
      ceilingMesh = new THREE.Mesh(planeGeo, ceilingMat);
      ceilingMesh.rotation.x = Math.PI / 2;
      ceilingMesh.position.y = CORRIDOR_SIZE / 2;
      corridor.add(ceilingMesh);

      // === Left Wall ===
      leftWallMesh = new THREE.Mesh(planeGeo, leftWallMat);
      leftWallMesh.rotation.y = Math.PI / 2;
      leftWallMesh.position.x = -CORRIDOR_SIZE / 2 - 500;
      corridor.add(leftWallMesh);

      // === Right Wall ===
      rightWallMesh = new THREE.Mesh(planeGeo, rightWallMat);
      rightWallMesh.rotation.y = -Math.PI / 2;
      rightWallMesh.position.x = CORRIDOR_SIZE / 2 + 500;
      corridor.add(rightWallMesh);

      // ========== SCROLLING PLEXUS ==========
      plexusGroup = createScrollingPlexus();
      plexusGroup.rotation.x = -0.2;
      plexusGroup.renderOrder = 1;
      plexusGroup.scale.set(0, 0, 0);
      scene.add(plexusGroup);

      // ====== GLYPH SPRITES (30 total) ======
      const glyphLetters = [
        "·ö†","·ö¢","·ö¶","·ö®","·ö±","·ö≤","·õâ","·õè","·õí","·õñ","·õû","·õü",
        "êé†","êé£","êé´"
      ];
      for (let i = 0; i < 30; i++) {
        const letter = glyphLetters[Math.floor(Math.random() * glyphLetters.length)];
        const sprite = createGlyphSprite(letter);
        if (Math.random() < 0.5) {
          spawnGlyphOnWall(sprite);
        } else {
          sprite.position.set(
            (Math.random() - 0.5) * CORRIDOR_SIZE,
            Math.random() * 1950 - 700,
            -Math.random() * CORRIDOR_SIZE
          );
        }
        sprite.userData = {
          basePosition: sprite.position.clone(),
          oscillationSpeed: Math.random() * 0.5 + 0.5,
          velocity: new THREE.Vector3(0, 0, 0),
          lifetime: 0,
          maxLifetime: 12 + Math.random() * 12
        };
        glyphs.push(sprite);
        scene.add(sprite);
      }

      // ====== Event Listeners ======
      window.addEventListener("resize", onWindowResize, false);
      document.addEventListener("mousemove", onDocumentMouseMove, false);

      // UI Panel Navigation
      const navButtons = document.querySelectorAll("nav button");
      const sections = ["inventory", "map", "email", "codex", "scanner"];
      navButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          navButtons.forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          sections.forEach(s => {
            const el = document.getElementById(s);
            if (btn.getAttribute("data-section") === s) {
              el.classList.add("active");
            } else {
              el.classList.remove("active");
            }
          });
        });
      });
    }

    function createScrollingPlexus() {
      const group = new THREE.Group();
      const nodeCount = 160;
      const threshold = 435;
      const scrollSpeed = 1.0;
      const regionMinX = -1100, regionMaxX = 1100;
      const regionMinY = -1100, regionMaxY = -700;
      const regionMinZ = -3000, regionMaxZ = 1200;
      const regionWidth = regionMaxX - regionMinX;
      const regionDepth = regionMaxZ - regionMinZ;
      const nodes = [];
      for (let i = 0; i < nodeCount; i++) {
        const x = THREE.MathUtils.randFloat(regionMinX, regionMaxX);
        const y = THREE.MathUtils.randFloat(regionMinY, regionMaxY);
        const z = THREE.MathUtils.randFloat(regionMinZ, regionMaxZ);
        const v = new THREE.Vector3(x, y, z);
        v.userData = {
          phase: Math.random() * Math.PI * 2,
          amplitude: 20 + Math.random() * 10,
          scrollSpeed
        };
        nodes.push(v);
      }
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
      geometry.setAttribute('uv', new THREE.Float32BufferAttribute([], 2));
      const material = new THREE.ShaderMaterial({
        uniforms: {
          lineColor: { value: new THREE.Color(0x00ccff) },
          center: { value: new THREE.Vector2(0.5, 0.5) },
          maxDist: { value: 1.0 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 lineColor;
          uniform vec2 center;
          uniform float maxDist;
          varying vec2 vUv;
          void main() {
            float d = distance(vUv, center);
            float alpha = 1.0 - smoothstep(0.0, maxDist, d);
            gl_FragColor = vec4(lineColor, alpha);
          }
        `,
        transparent: true,
        depthTest: true,
        depthWrite: false
      });
      const plexusLines = new THREE.LineSegments(geometry, material);
      plexusLines.frustumCulled = false;
      plexusLines.renderOrder = 1;
      plexusLines.userData = {
        nodes,
        regionMinX, regionMaxX,
        regionMinZ, regionMaxZ,
        regionWidth, regionDepth,
        threshold
      };
      group.add(plexusLines);
      return group;
    }

    function createCodeTexture(size) {
      const canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#0d1b2a";
      ctx.fillRect(0, 0, size, size);
      ctx.fillStyle = "rgba(0, 204, 255, 0.4)";
      ctx.font = "10px monospace";
      const codeChars = [
        "0", "1", "‚àë", "‚àÜ", "‚âà", "‚â†", "‚Ñ¶", "œÄ", "Œ£", "Œî",
        "¬§", "¬•", "¬µ", "‚àÇ", "∆í", "Œû", "Œ®", "Œ¶", "Œõ", "Œ©"
      ];
      const columns = 40, rows = 50;
      const colWidth = size / columns, rowHeight = size / rows;
      for (let c = 0; c < columns; c++) {
        for (let r = 0; r < rows; r++) {
          const char = codeChars[Math.floor(Math.random() * codeChars.length)];
          let x = c * colWidth + colWidth * 0.1;
          let y = r * rowHeight + rowHeight * 0.8;
          ctx.fillText(char, x, y);
        }
      }
      return new THREE.CanvasTexture(canvas);
    }

    function createCircuitTexture(size) {
      const canvas = document.createElement("canvas");
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#0d1b2a";
      ctx.fillRect(0, 0, size, size);
      const lineCount = 25;
      for (let i = 0; i < lineCount; i++) {
        ctx.strokeStyle = "rgba(0, 204, 255, 0.3)";
        ctx.lineWidth = Math.random() * 2 + 1;
        ctx.beginPath();
        let x1 = Math.random() * size, y1 = Math.random() * size;
        let x2 = x1 + (Math.random() - 0.5) * 150, y2 = y1 + (Math.random() - 0.5) * 150;
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      const arcCount = 15;
      for (let i = 0; i < arcCount; i++) {
        ctx.strokeStyle = "rgba(0, 204, 255, 0.3)";
        ctx.lineWidth = Math.random() * 2 + 1;
        ctx.beginPath();
        let cx = Math.random() * size, cy = Math.random() * size;
        let r = Math.random() * 40 + 10;
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();
      }
      const textCount = 10;
      ctx.fillStyle = "rgba(0, 204, 255, 0.25)";
      ctx.font = "14px monospace";
      for (let i = 0; i < textCount; i++) {
        let tx = Math.random() * size, ty = Math.random() * size;
        let hexString = Math.floor(Math.random() * 0xffffff).toString(16).toUpperCase();
        ctx.fillText(hexString, tx, ty);
      }
      return new THREE.CanvasTexture(canvas);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onDocumentMouseMove(e) {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      const maxRotation = 0.08;
      targetRotationY = mouse.x * maxRotation;
      targetRotationX = mouse.y * maxRotation;
    }

    function animate() {
      requestAnimationFrame(animate);
      const time = Date.now() * 0.001;
      const elapsedTime = time - loadingStartTime;
      
      // Global glyph fade (starts after 3.2s)
      globalGlyphFade = (elapsedTime < 3.2) ? 0 : Math.min((elapsedTime - 3.2) / 1, 1);
      
      // Smooth corridor rotation
      corridor.rotation.y += (targetRotationY - corridor.rotation.y) * 0.05;
      corridor.rotation.x += (targetRotationX - corridor.rotation.x) * 0.05;

      // Animate walls sliding in (first 2 seconds)
      if (elapsedTime < 2) {
        const progress = elapsedTime / 2;
        leftWallMesh.position.x = (-CORRIDOR_SIZE/2 - 500) + progress * 500;
        rightWallMesh.position.x = (CORRIDOR_SIZE/2 + 500) - progress * 500;
      } else {
        leftWallMesh.position.x = -CORRIDOR_SIZE/2;
        rightWallMesh.position.x = CORRIDOR_SIZE/2;
      }

      // Scroll the code textures on walls
      floorTexture.offset.y += SCROLL_SPEED_FLOOR;
      leftWallTexture.offset.y += SCROLL_SPEED_CODE;
      rightWallTexture.offset.y += SCROLL_SPEED_CODE;
      ceilingTexture.offset.y -= SCROLL_SPEED_FLOOR * 0.5;

      // Animate plexus appearance (scale between 3 and 4 seconds)
      if (elapsedTime < 3) {
        plexusGroup.scale.set(0, 0, 0);
      } else if (elapsedTime < 4) {
        const s = (elapsedTime - 3);
        plexusGroup.scale.set(s, s, s);
      } else {
        plexusGroup.scale.set(1, 1, 1);
      }

      if (plexusGroup && plexusGroup.children.length > 0) {
        updateScrollingPlexus(plexusGroup.children[0], time);
      }

      updateGlyphs();
      renderer.render(scene, camera);
    }

    function updateScrollingPlexus(plexusLines, time) {
      const geometry = plexusLines.geometry;
      const { nodes, regionMinX, regionMaxX, regionMinZ, regionMaxZ, regionWidth, regionDepth, threshold } = plexusLines.userData;
      const positions = [];
      const uvs = [];
      for (let i = 0; i < nodes.length; i++) {
        const n = nodes[i];
        n.y += Math.sin(time + n.userData.phase) * 0.2;
        n.z += n.userData.scrollSpeed;
        if (n.z > regionMaxZ + 200) {
          n.z = regionMinZ - 50;
        }
      }
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const dist = nodes[i].distanceTo(nodes[j]);
          if (dist < threshold) {
            positions.push(nodes[i].x, nodes[i].y, nodes[i].z);
            positions.push(nodes[j].x, nodes[j].y, nodes[j].z);
            const u1 = (nodes[i].x - regionMinX) / (regionMaxX - regionMinX);
            const v1 = (nodes[i].z - regionMinZ) / regionDepth;
            const u2 = (nodes[j].x - regionMinX) / (regionMaxX - regionMinX);
            const v2 = (nodes[j].z - regionMinZ) / regionDepth;
            uvs.push(u1, v1);
            uvs.push(u2, v2);
          }
        }
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      geometry.attributes.position.needsUpdate = true;
      geometry.attributes.uv.needsUpdate = true;
      geometry.computeBoundingSphere();
    }

    function updateGlyphs() {
      glyphs.forEach(sprite => {
        sprite.userData.lifetime += 0.016;
        const fade = 1 - (sprite.userData.lifetime / sprite.userData.maxLifetime);
        sprite.material.opacity = Math.max(fade, 0) * globalGlyphFade;
        if (fade <= 0.05) {
          sprite.userData.lifetime = 0;
          sprite.userData.maxLifetime = 12 + Math.random() * 12;
          if (Math.random() < 0.5) {
            spawnGlyphOnWall(sprite);
          } else {
            sprite.position.set(
              (Math.random() - 0.5) * CORRIDOR_SIZE,
              Math.random() * 1950 - 700,
              -Math.random() * CORRIDOR_SIZE
            );
          }
          sprite.userData.basePosition.copy(sprite.position);
          sprite.userData.velocity.set(0, 0, 0);
          sprite.material.opacity = 1.0 * globalGlyphFade;
        }
        const t = Date.now() * 0.001 * sprite.userData.oscillationSpeed;
        sprite.position.x = sprite.userData.basePosition.x + Math.sin(t) * 15;
        sprite.position.y = sprite.userData.basePosition.y + Math.cos(t) * 15;
        const pos = sprite.position.clone();
        pos.project(camera);
        const glyphScreenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
        const glyphScreenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
        const mouseScreenX = (mouse.x + 1) * 0.5 * window.innerWidth;
        const mouseScreenY = (-mouse.y + 1) * 0.5 * window.innerHeight;
        const dist = Math.hypot(glyphScreenX - mouseScreenX, glyphScreenY - mouseScreenY);
        if (dist < repulsionDistance) {
          const dx = glyphScreenX - mouseScreenX;
          const dy = glyphScreenY - mouseScreenY;
          const angle = Math.atan2(dy, dx);
          const pushX = Math.cos(angle) * repulsionForce;
          const pushY = Math.sin(angle) * repulsionForce;
          sprite.userData.velocity.x += pushX;
          sprite.userData.velocity.y += pushY;
        }
        sprite.userData.velocity.multiplyScalar(friction);
        sprite.position.x += sprite.userData.velocity.x;
        sprite.position.y += sprite.userData.velocity.y;
        const d = camera.position.distanceTo(sprite.position);
        const minDist = 500, maxDist = 2000;
        const scaleClose = 400, scaleFar = 200;
        const clampDist = THREE.MathUtils.clamp(d, minDist, maxDist);
        const alpha = (clampDist - minDist) / (maxDist - minDist);
        const finalScale = scaleClose * (1 - alpha) + scaleFar * alpha;
        sprite.scale.set(finalScale, finalScale, 1);
      });
    }

    function spawnGlyphOnWall(sprite) {
      const wallTypes = [0, 1, 3];
      const wallType = wallTypes[Math.floor(Math.random() * wallTypes.length)];
      const offset = 50;
      let x, y;
      if (wallType === 0) {
        x = -CORRIDOR_SIZE / 2 + offset;
        y = Math.random() * 1950 - 700;
      } else if (wallType === 1) {
        x = CORRIDOR_SIZE / 2 - offset;
        y = Math.random() * 1950 - 700;
      } else {
        y = CORRIDOR_SIZE / 2 - offset;
        x = (Math.random() - 0.5) * CORRIDOR_SIZE;
      }
      const z = -Math.random() * CORRIDOR_SIZE;
      sprite.position.set(x, y, z);
    }

    function createGlyphSprite(letter) {
      const canvas = document.createElement("canvas");
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, 128, 128);
      ctx.font = "100px Arial";
      ctx.fillStyle = "rgba(0,204,255,1.0)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(letter, 64, 64);
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({
        map: texture,
        transparent: true,
        alphaTest: 0.1,
      });
      material.sizeAttenuation = true;
      const sprite = new THREE.Sprite(material);
      sprite.renderOrder = 2;
      sprite.scale.set(120, 120, 1);
      return sprite;
    }

    document.addEventListener("click", function(e) {
      const ripple = document.createElement("div");
      ripple.classList.add("ripple");
      const diameter = Math.max(window.innerWidth, window.innerHeight);
      ripple.style.width = ripple.style.height = diameter + "px";
      ripple.style.left = e.clientX - diameter / 2 + "px";
      ripple.style.top = e.clientY - diameter / 2 + "px";
      document.body.appendChild(ripple);
      ripple.addEventListener("animationend", () => {
        ripple.remove();
      });
    });
  </script>
</body>
</html>
