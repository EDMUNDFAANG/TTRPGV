<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Animus Corridor Simulation [Refined v2]</title>
    <!-- Load Orbitron font -->
    <link href="https://fonts.googleapis.com/css?family=Orbitron" rel="stylesheet">
    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg-color: #0d1b2a;
            --accent-color: #00ccff;
            --text-color: rgba(0, 204, 255, 0.9);
            --panel-bg: rgba(0, 10, 20, 0.5); /* Slightly darker, bluer panel bg */
            --border-color: rgba(0, 204, 255, 0.3);
            --hover-border-color: rgba(0, 204, 255, 0.6);
            --active-bg: rgba(0, 204, 255, 0.2);
            --pulse-color: rgba(0, 204, 255, 0.7); /* For activation pulses */
            --scrollbar-thumb: var(--accent-color);
            --scrollbar-track: rgba(0, 0, 0, 0.2);
        }

        /* ===== Reset & Base Styles ===== */
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: var(--bg-color);
            font-family: 'Orbitron', sans-serif;
            color: var(--text-color);
        }

        canvas {
            display: block;
             /* Keep canvas visible, behind other elements */
             position: fixed;
             top: 0;
             left: 0;
             z-index: -1; /* Place behind all UI */
        }

        /* ===== Holographic Text Style ===== */
        .holo-text {
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-shadow: 0 0 4px rgba(0, 204, 255, 0.8), 0 0 8px rgba(0, 204, 255, 0.5);
            color: var(--text-color);
            animation: textPulse 4s infinite ease-in-out alternate; /* Subtle pulse */
        }
        @keyframes textPulse {
             from { text-shadow: 0 0 4px rgba(0, 204, 255, 0.7), 0 0 8px rgba(0, 204, 255, 0.4); }
             to { text-shadow: 0 0 6px rgba(0, 204, 255, 0.9), 0 0 12px rgba(0, 204, 255, 0.6); }
        }
        /* Less intense pulse for general text */
        p.holo-text, span.holo-text, li .holo-text {
            animation: none; /* Remove default pulse from paragraphs/spans */
            text-shadow: 0 0 3px rgba(0, 204, 255, 0.8), 0 0 6px rgba(0, 204, 255, 0.5);
        }


        /* ===== Login Panel Styling & Boot-Up Animation ===== */
        #loginPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95); /* Start slightly smaller */
            width: 320px; /* Slightly wider */
            padding: 35px;
            border: 2px solid var(--border-color);
            border-radius: 18px;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            text-align: center;
            z-index: 400;
            opacity: 0; /* Start hidden */
            transition: opacity 1.2s ease-out, transform 1.2s ease-out;
            pointer-events: none; /* Not interactive until visible */
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.1);
            overflow: hidden; /* Contain pseudo-elements */
            /* Add pseudo-element for scan line effect */
        }
        #loginPanel::before {
             content: '';
             position: absolute;
             top: 0;
             left: 10%; /* Start off-center */
             width: 2px; /* Thin line */
             height: 100%;
             background: linear-gradient(
                 to bottom,
                 transparent 0%,
                 rgba(0, 204, 255, 0.3) 50%,
                 transparent 100%
             );
             opacity: 0;
             animation: loginScan 5s linear infinite alternate;
             animation-delay: 0.5s; /* Start after fade-in begins */
        }

        @keyframes loginScan {
            0% { left: 10%; opacity: 0.3; }
            100% { left: 90%; opacity: 0.6; } /* Move across and slightly brighten */
        }

        #loginPanel.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1); /* Scale to full size */
            pointer-events: auto;
        }
        #loginPanel.hidden {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
            pointer-events: none;
            transition: opacity 0.6s ease-in, transform 0.6s ease-in; /* Faster fade out */
        }
        #loginPanel h1.holo-text { /* Make title stand out more */
             font-size: 1.6em;
             margin-bottom: 25px;
         }
        #loginPanel input {
            width: 90%;
            margin: 12px 0;
            padding: 10px;
            border: 1px solid var(--accent-color);
            border-radius: 5px;
            background: rgba(0,0,0, 0.2); /* Slightly visible background */
            color: var(--accent-color);
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            text-align: center;
            transition: box-shadow 0.3s;
        }
         #loginPanel input:focus {
             outline: none;
             box-shadow: 0 0 8px var(--accent-color);
         }

        #loginPanel button {
            margin-top: 20px;
            padding: 10px 20px;
            border: 2px solid var(--accent-color);
            background: transparent;
            color: var(--accent-color);
            cursor: pointer;
            transition: background 0.3s, transform 0.2s, box-shadow 0.3s;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1em;
            border-radius: 5px;
        }

        #loginPanel button:hover {
            background: var(--active-bg);
             box-shadow: 0 0 10px var(--accent-color);
             transform: translateY(-2px);
        }
         #loginPanel button:active {
              transform: translateY(0px); /* Click down effect */
         }

        /* ===== Main Content ===== */
        #mainContent {
            display: block; /* Keep it block, control visibility with opacity/transform */
            opacity: 0;
            transform: translateY(20px); /* Start slightly down */
            transition: opacity 1.5s ease-out, transform 1.5s ease-out;
            transition-delay: 0.3s; /* Start fade slightly after login panel starts hiding */
            pointer-events: none;
        }

        #mainContent.visible {
            opacity: 1;
             transform: translateY(0px); /* Slide up to position */
            pointer-events: auto;
        }

        /* ===== Intro Message Overlay ===== */
        #introMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.8em; /* Slightly larger */
            z-index: 300;
            opacity: 0;
            /* Starts animating after mainContent becomes visible */
            animation: introAnim 3.5s forwards ease-out; /* Slightly longer */
            /* Delay syncs with mainContent transition + delay (0.3 + 1.5 = 1.8s approx start) */
            /* Let's make it start a bit sooner than nav */
            animation-delay: 1.0s;
        }

        @keyframes introAnim { /* Refined easing and scale */
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.7);
            }
             20% { /* Faster rise */
                  opacity: 1;
                  transform: translate(-50%, -50%) scale(1.05);
             }
            80% { /* Hold longer */
                 opacity: 1;
                 transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
                 pointer-events: none; /* Make sure it's not clickable after fading */
            }
        }


        /* ===== Navigation Bar ===== */
        nav {
            position: fixed;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.5); /* Enhanced shadow */
            backdrop-filter: blur(8px); /* More blur */
            opacity: 0;
            transform: translateY(-30px); /* Start further up */
            /* Animation starts after intro message begins fading out */
            animation: navFadeSlideIn 1.2s forwards ease-out;
            /* Delay should account for intro message hold time */
            animation-delay: 3.0s; /* Delay from page load (adjust if intro anim timing changes) */
        }

        @keyframes navFadeSlideIn {
            from {
                opacity: 0;
                 transform: translateY(-30px);
            }
            to {
                opacity: 1;
                 transform: translateY(0);
            }
        }


        nav button {
            background: transparent;
            border: 2px solid var(--accent-color);
            margin: 0 10px;
            padding: 8px 16px;
            cursor: pointer;
            text-transform: uppercase;
            transition: background 0.3s ease, color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            outline: none;
            opacity: 0; /* Start hidden */
            transform: translateY(-20px); /* Start up */
            color: var(--text-color); /* Inherit text color */
             border-radius: 4px;
             box-shadow: 0 0 5px transparent; /* Placeholder for transition */
            /* Animation Keyframes applied directly */
            animation: buttonFadeSlideIn 0.8s forwards ease-out;
        }

        /* Staggered Delays for Nav Buttons (Relative to Nav Fade-In Start) */
        nav button[data-section="inventory"] { animation-delay: 3.2s; } /* nav delay + 0.2s */
        nav button[data-section="map"]       { animation-delay: 3.35s; }/* nav delay + 0.35s */
        nav button[data-section="email"]     { animation-delay: 3.5s; } /* nav delay + 0.5s */
        nav button[data-section="codex"]     { animation-delay: 3.65s; }/* nav delay + 0.65s */
        nav button[data-section="scanner"]   { animation-delay: 3.8s; } /* nav delay + 0.8s */
        nav button[data-section="vitals"]    { animation-delay: 3.95s; }/* nav delay + 0.95s */

        @keyframes buttonFadeSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        nav button:hover,
        nav button.active {
            background: var(--active-bg);
            color: #FFF; /* Brighter text */
             box-shadow: 0 0 12px var(--accent-color); /* Glow effect */
            /* Combine transforms smoothly */
            transform: translateY(-2px) scale(1.03);
        }
         nav button:active {
              transform: translateY(0) scale(1); /* Click down effect */
         }


        /* ===== Floating UI Panels ===== */
        .content-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.98); /* Start slightly small */
            width: 75%; /* Wider */
            max-width: 950px;
            height: 65vh; /* Slightly taller */
            max-height: 650px;
            padding: 25px;
            border: 2px solid var(--border-color);
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 204, 255, 0.25); /* Softer, larger shadow */
            background: var(--panel-bg);
            backdrop-filter: blur(12px); /* Increased blur */
            z-index: 100;
            opacity: 0;
            pointer-events: none;
             /* Animate opacity, transform, and add border/shadow pulse */
             transition: opacity 0.5s ease-out, transform 0.5s ease-out;
             /* Prepare for activation animation */
            border-color: var(--border-color);
            box-shadow: 0 0 25px rgba(0, 204, 255, 0.25);
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Changed from visible to hidden */
        }

        .content-card.active {
            opacity: 1;
            pointer-events: auto;
            /* Run scale animation and pulse animation */
             animation: panelActivate 0.5s ease-out forwards, panelPulse 0.6s ease-out forwards;
        }

        @keyframes panelActivate { /* Scale up slightly more dynamically */
            from { transform: translate(-50%, -50%) scale(0.98); }
             70% { transform: translate(-50%, -50%) scale(1.01); } /* Overshoot slightly */
            to   { transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes panelPulse { /* Brief bright border/shadow */
            0% { border-color: var(--border-color); box-shadow: 0 0 25px rgba(0, 204, 255, 0.25); }
            50% { border-color: var(--pulse-color); box-shadow: 0 0 35px var(--pulse-color); }
             100% { border-color: var(--border-color); box-shadow: 0 0 25px rgba(0, 204, 255, 0.25); }
         }

        /* Staggered content appearance inside active panel */
        .content-card.active h1,
        .content-card.active .panel-content {
            opacity: 0;
             transform: translateY(10px);
            animation: panelContentFadeIn 0.5s ease-out forwards;
            animation-delay: 0.2s; /* Delay after panel activation animation starts */
         }
         @keyframes panelContentFadeIn {
             to { opacity: 1; transform: translateY(0); }
         }


        .content-card h1 {
            margin: 0 0 20px 0; /* More space below title */
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            flex-shrink: 0;
            font-size: 1.8em; /* Larger title */
        }

        .content-card .panel-content {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 15px; /* Space for scrollbar */
        }

        /* ===== Custom Scrollbar ===== */
        .panel-content::-webkit-scrollbar,
        .inventory-grid::-webkit-scrollbar,
        .item-details::-webkit-scrollbar,
        #emailList::-webkit-scrollbar,
        #emailContent::-webkit-scrollbar {
            width: 8px;
        }
        .panel-content::-webkit-scrollbar-track,
        .inventory-grid::-webkit-scrollbar-track,
        .item-details::-webkit-scrollbar-track,
        #emailList::-webkit-scrollbar-track,
        #emailContent::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
            border-radius: 4px;
        }
        .panel-content::-webkit-scrollbar-thumb,
        .inventory-grid::-webkit-scrollbar-thumb,
        .item-details::-webkit-scrollbar-thumb,
        #emailList::-webkit-scrollbar-thumb,
        #emailContent::-webkit-scrollbar-thumb {
            background-color: var(--scrollbar-thumb);
            border-radius: 4px;
            border: 2px solid var(--panel-bg); /* Match panel bg */
        }
         .panel-content::-webkit-scrollbar-thumb:hover,
         .inventory-grid::-webkit-scrollbar-thumb:hover,
         .item-details::-webkit-scrollbar-thumb:hover,
         #emailList::-webkit-scrollbar-thumb:hover,
         #emailContent::-webkit-scrollbar-thumb:hover {
              background-color: var(--pulse-color); /* Highlight on hover */
          }


        /* ===== Inventory Container Styling ===== */
        #inventoryContainer {
             /* Inherits base panel styles via JS adding .content-card class conceptually */
             /* Specific overrides: */
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.98);
            z-index: 150; /* Ensure inventory is above standard content cards if overlapping */
             width: 850px; /* Slightly wider */
             height: 600px; /* Match other panels height better */
             max-height: 70vh; /* Add max height */
             padding: 20px;
             background: var(--panel-bg);
             backdrop-filter: blur(12px);
             border: 2px solid var(--border-color);
             border-radius: 15px;
             box-shadow: 0 0 25px rgba(0, 204, 255, 0.25);
             display: none; /* Start hidden with display: none */
             flex-direction: row;
             gap: 25px; /* More gap */
             opacity: 0;
             pointer-events: none;
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            /* Will also use panelActivate and panelPulse via active class */
            overflow: hidden; /* Added overflow hidden */
        }

        #inventoryContainer.active {
            display: flex; /* Change display to flex when active */
            opacity: 1;
            pointer-events: auto;
            animation: panelActivate 0.5s ease-out forwards, panelPulse 0.6s ease-out forwards;
         }
         /* Staggered content appearance inside active inventory */
        #inventoryContainer.active .inventory-grid,
        #inventoryContainer.active .item-info {
            opacity: 0;
             transform: translateY(10px);
             animation: panelContentFadeIn 0.5s ease-out forwards;
            animation-delay: 0.2s;
        }


        .inventory-grid {
            flex: 2; /* Grid takes more space */
            display: grid;
             grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); /* Slightly larger minimum */
             grid-auto-rows: 100px; /* Square slots */
            gap: 12px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow-y: auto;
            align-content: start;
             background: rgba(0,0,0, 0.1); /* Subtle grid background */
        }


        .inventory-slot {
            width: 100%;
            height: 100%;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.4); /* Darker slots */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: border-color 0.3s, background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            cursor: pointer;
            position: relative;
             box-shadow: 0 0 4px transparent; /* for transition */
             transform: scale(1);
        }

        .inventory-slot:hover {
            border-color: var(--hover-border-color);
            background-color: rgba(0, 204, 255, 0.1);
             transform: scale(1.03); /* Subtle pop */
             box-shadow: 0 0 8px var(--hover-border-color);
        }

        .inventory-slot.selected {
            border-color: var(--accent-color);
            background-color: rgba(0, 204, 255, 0.18);
            box-shadow: 0 0 12px var(--accent-color);
             transform: scale(1.02); /* Slightly scaled when selected */
        }

        .inventory-slot img {
             max-width: 80%; /* Adjust size */
             max-height: 80%;
            object-fit: contain;
             filter: drop-shadow(0 0 3px var(--accent-color)); /* Add slight glow to item image */
            opacity: 0.9; /* Placeholder slightly faded */
        }

        /* Item Info Panel Styling */
        .item-info {
            flex: 1;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.15);
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .item-details {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 20px;
             padding-right: 10px; /* scrollbar space */
        }

        .item-info h2 {
             /* Inherits .holo-text pulse */
            margin: 0 0 15px 0;
             font-size: 1.4em;
             color: var(--accent-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        .item-info p {
             font-size: 1em;
             line-height: 1.6;
             color: var(--text-color);
         }
         .item-info p.holo-text { animation: none; } /* No pulse on description */

        .item-actions {
            flex-shrink: 0;
            text-align: right;
             border-top: 1px solid var(--border-color); /* Separator line */
             padding-top: 15px;
        }

        .item-actions button {
             /* Inherits base nav button styles conceptually, override/add specific */
            background: transparent;
            border: 2px solid var(--accent-color);
             color: var(--accent-color);
            margin-left: 10px;
            padding: 8px 18px; /* Wider */
            cursor: pointer;
            text-transform: uppercase;
             transition: background 0.3s, color 0.3s, transform 0.2s, box-shadow 0.3s;
            font-family: 'Orbitron', sans-serif;
             border-radius: 4px;
             box-shadow: 0 0 5px transparent;
         }

        .item-actions button:hover:not(:disabled) {
            background: var(--active-bg);
             color: #FFF;
             box-shadow: 0 0 10px var(--accent-color);
             transform: translateY(-2px);
        }
         .item-actions button:active:not(:disabled) {
              transform: translateY(0px);
         }

        .item-actions button:disabled {
            border-color: rgba(0, 204, 255, 0.2);
             color: rgba(0, 204, 255, 0.3);
             cursor: not-allowed;
             background: transparent;
             box-shadow: none;
             transform: none;
        }

         /* ===== Email Section Styling ===== */
        #email .panel-content {
             display: flex;
             gap: 20px; /* Increased gap */
             padding: 15px 0 0 0;
             /* Ensure it animates in */
              opacity: 1; transform: translateY(0);
        }

        #emailList {
            flex: 1;
            list-style: none;
            padding: 0 20px 0 0; /* Increased right padding */
            margin: 0;
             border-right: 1px solid var(--border-color);
             overflow-y: auto;
            max-height: calc(65vh - 120px); /* Adjust based on panel height/padding */
        }

        #emailList li {
             padding: 12px 15px;
             border: 1px solid transparent;
            border-bottom: 1px solid rgba(0, 204, 255, 0.1); /* Lighter separator */
             margin-bottom: 6px;
             border-radius: 5px;
             cursor: pointer;
             transition: background-color 0.3s, border-color 0.3s, transform 0.2s ease-out;
             position: relative; /* For pseudo-elements */
             overflow: hidden; /* Contain potential hover effects */
        }

        #emailList li::before { /* Subtle left border indicator on hover/active */
             content: '';
             position: absolute;
             left: 0;
             top: 0;
             bottom: 0;
             width: 3px;
             background-color: var(--accent-color);
             transform: scaleY(0);
             transition: transform 0.3s ease;
             transform-origin: bottom;
         }

        #emailList li:hover {
            background-color: rgba(0, 204, 255, 0.08);
             border-color: transparent; /* Use pseudo-element for highlight */
             transform: translateX(5px);
         }
         #emailList li:hover::before {
              transform: scaleY(1);
              transform-origin: top;
          }

        #emailList li.active {
            background-color: var(--active-bg);
            border-color: transparent; /* Active uses pseudo-element */
             transform: translateX(0px); /* Don't shift active item */
         }
         #emailList li.active::before {
              transform: scaleY(1); /* Keep highlight visible */
              transform-origin: center;
          }


        #emailList li .sender {
            font-weight: bold;
            display: block;
            margin-bottom: 4px;
            color: var(--accent-color);
             font-size: 1.05em;
        }

        #emailList li .subject {
            font-size: 0.9em;
            color: var(--text-color);
         }
         #emailList li .sender.holo-text,
         #emailList li .subject.holo-text {
              animation: none; /* Remove pulse from list items */
          }

        #emailList li.read .subject { opacity: 0.6; } /* Dim read subject more */
        #emailList li.read .sender { opacity: 0.8; } /* Slightly dim read sender */

        #emailList li.unread::after { /* More distinct unread indicator */
             content: '';
             position: absolute;
             right: 15px;
             top: 50%;
             transform: translateY(-50%);
             width: 8px;
             height: 8px;
             background-color: var(--accent-color);
             border-radius: 50%;
             box-shadow: 0 0 6px var(--accent-color);
        }

        #emailContent {
            flex: 2;
            padding: 0 15px 0 10px;
             overflow-y: auto;
            max-height: calc(65vh - 120px);
         }

        #emailContent h2 { /* Subject in content view */
             /* Inherits .holo-text pulse */
            font-size: 1.5em;
             color: var(--accent-color);
             margin: 0 0 10px 0;
             padding-bottom: 8px;
             border-bottom: 1px solid var(--border-color);
        }

        #emailContent .email-meta {
             font-size: 0.9em;
             color: rgba(0, 204, 255, 0.7);
             margin-bottom: 25px;
             border-bottom: 1px dashed var(--border-color); /* Dashed separator */
             padding-bottom: 15px;
        }
         #emailContent .email-meta span { display: block; margin-bottom: 5px; }

        #emailContent .email-body {
            font-size: 1em; /* Larger body text */
            line-height: 1.7; /* More spacing */
             white-space: pre-wrap; /* Preserve line breaks from data */
            color: var(--text-color); /* Ensure uses standard text color */
            padding-bottom: 20px;
         }

        #emailPlaceholder {
             text-align: center;
             padding: 60px 20px;
             font-size: 1.2em;
             color: rgba(0, 204, 255, 0.6);
             border: 1px dashed var(--border-color);
             border-radius: 8px;
             margin-top: 20px;
         }


        /* ===== Refined Ripple Effect ===== */
        .ripple {
            position: absolute;
            border-radius: 50%;
             /* Sharper center, faster fade */
            background: radial-gradient(circle, rgba(0, 204, 255, 0.25) 2%, rgba(0, 204, 255, 0.1) 20%, rgba(0, 204, 255, 0) 50%);
            transform: scale(0);
            pointer-events: none;
             /* Faster, smaller ripple */
             animation: ripple-effect 0.6s ease-out;
             z-index: 50;
        }

        @keyframes ripple-effect {
            from { transform: scale(0); opacity: 0.7; }
            to   { transform: scale(1.8); opacity: 0; } /* Scale slightly less */
        }

        /* ===== Other Section Placeholders ===== */
        #map .panel-content p,
        #codex .panel-content p,
        #scanner .panel-content p,
        #vitals .panel-content p {
            padding: 40px 20px;
            font-size: 1.2em;
            text-align: center;
             color: rgba(0, 204, 255, 0.7);
            line-height: 1.6;
        }

    </style>
</head>

<body>
    <!-- ===== Login Panel (Starts hidden, made visible by JS) ===== -->
    <div id="loginPanel">
        <h1 class="holo-text">Access Required</h1>
        <input type="text" id="username" placeholder="Designation" value="Vesta" /> <!-- Changed placeholder -->
        <input type="password" id="passcode" placeholder="Auth Key" value="password" /> <!-- Changed placeholder -->
        <button id="loginButton" class="holo-text">Initiate Link</button>
    </div>

    <!-- ===== Main Content (hidden until login) ===== -->
    <div id="mainContent">
        <!-- ===== Intro Message ===== -->
        <div id="introMessage" class="holo-text">Syncing Neural Interface... Welcome, Vesta.</div> <!-- Updated text -->

        <!-- ===== Navigation ===== -->
        <nav>
            <button data-section="inventory" class="holo-text">Inventory</button>
            <button data-section="map" class="holo-text">Nav-Grid</button> <!-- Renamed -->
            <button data-section="email" class="holo-text">Comms</button> <!-- Renamed -->
            <button data-section="codex" class="holo-text">Codex</button>
            <button data-section="scanner" class="holo-text">Scanner</button>
            <button data-section="vitals" class="holo-text">Biometrics</button> <!-- Renamed -->
        </nav>

        <!-- ===== Content Panels Wrapper ===== -->
        <div id="contentWrapper">
            <!-- MAP -->
            <div id="map" class="content-card">
                <h1 class="holo-text">Navigation Grid</h1>
                <div class="panel-content">
                    <p class="holo-text">Stellar Cartography Data Unavailable.<br>Awaiting Triangulation Lock.</p>
                </div>
            </div>
            <!-- EMAIL -->
            <div id="email" class="content-card">
                <h1 class="holo-text">Comms Terminal</h1>
                <div class="panel-content">
                    <ul id="emailList"></ul>
                    <div id="emailContent">
                        <div id="emailPlaceholder" class="holo-text">Select encrypted transmission...</div>
                        <h2 id="emailSubject" class="holo-text" style="display: none;"></h2>
                        <div id="emailMeta" style="display: none;">
                            <span id="emailSender" class="holo-text"></span>
                            <span id="emailDate" class="holo-text"></span>
                        </div>
                        <div id="emailBody" style="display: none;"></div>
                    </div>
                </div>
            </div>
             <!-- CODEX -->
            <div id="codex" class="content-card">
                <h1 class="holo-text">Data Codex</h1>
                <div class="panel-content">
                    <p class="holo-text">Codex database empty.<br>Connect to external Archive Node or utilize Scanner for entries.</p>
                </div>
            </div>
            <!-- SCANNER -->
            <div id="scanner" class="content-card">
                <h1 class="holo-text">Environmental Scanner</h1>
                <div class="panel-content">
                    <p class="holo-text">Scanner systems initializing...<br>Awaiting target lock or environmental input.</p>
                </div>
            </div>
             <!-- VITALS -->
            <div id="vitals" class="content-card">
                <h1 class="holo-text">Biometrics Interface</h1>
                <div class="panel-content">
                    <p class="holo-text">Neural link telemetry unstable.<br>Recalibrating biometric feed... Stand by.</p>
                </div>
            </div>
        </div>

        <!-- ===== New Inventory Container (starts display:none) ===== -->
        <div id="inventoryContainer">
            <div class="inventory-grid">
                 <!-- Slots will be populated / updated by JS -->
                 <!-- Example structure (content set by JS) -->
                 <div class="inventory-slot" data-itemid="health_potion_1"><img src="" alt=""></div>
                 <div class="inventory-slot" data-itemid="keycard_alpha"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
                 <div class="inventory-slot"><img src="" alt=""></div>
             </div>
            <div class="item-info">
                <div class="item-details">
                    <h2 class="holo-text" id="itemInfoTitle">Analysis Grid</h2>
                     <p class="holo-text" id="itemInfoDesc">Designate inventory object for detailed scan.</p>
                </div>
                <div class="item-actions">
                     <button id="itemUseButton" class="holo-text" disabled>Interface</button> <!-- Renamed -->
                     <button id="itemDropButton" class="holo-text" disabled>Jettison</button> <!-- Renamed -->
                 </div>
            </div>
        </div>
    </div>

    <script>
        // ----- Global DOM Elements -----
        const loginPanel = document.getElementById("loginPanel");
        const loginButton = document.getElementById("loginButton");
        const mainContent = document.getElementById("mainContent");
        const navButtons = document.querySelectorAll("nav button[data-section]");
        const contentCards = document.querySelectorAll("#contentWrapper .content-card");
        const inventoryContainer = document.getElementById("inventoryContainer");
        const inventoryGrid = document.querySelector(".inventory-grid"); // Get grid parent
        // Select slots dynamically later or ensure they exist initially
        let inventorySlots; // Will be populated after generating placeholders
        const itemInfoTitle = document.getElementById("itemInfoTitle");
        const itemInfoDesc = document.getElementById("itemInfoDesc");
        const itemUseButton = document.getElementById("itemUseButton");
        const itemDropButton = document.getElementById("itemDropButton");
        const emailList = document.getElementById("emailList");
        const emailContent = document.getElementById("emailContent");
        const emailPlaceholder = document.getElementById("emailPlaceholder");
        const emailSubjectEl = document.getElementById("emailSubject");
        const emailMetaEl = document.getElementById("emailMeta");
        const emailSenderEl = document.getElementById("emailSender");
        const emailDateEl = document.getElementById("emailDate");
        const emailBodyEl = document.getElementById("emailBody");
        let loadingStartTime;
        let selectedSlot = null; // Track selected inventory slot

        // ----- Dummy Data -----
        // Added placeholder URLs/names for SVG for demonstration
        // In a real scenario, these paths would point to actual files
        const inventoryItems = {
            "health_potion_1": { name: "Medi-Gel Injector", description: "Automated injector containing concentrated regenerative nano-solution. Effective on moderate tissue trauma. Auto-disposes after use.", usable: true, img: "medi_gel.svg" }, // Example path
            "keycard_alpha": { name: "Access Credential: Sector Alpha", description: "Standard issue clearance chip embedded in polymer substrate. Grants level 1 access within designated Alpha Sector zones.", usable: false, img: "keycard.svg" }, // Example path
            // Add more items
        };
        const emails = [{ id: 1, sender: "SysCore AI", subject: ":: Corridor Sync Established ::", date: "Cycle 34.1 REV 8", body: "Unit Designate: VST-VYN [Vesta]\n\nConfirmed connection to the Animus Corridor Simulation construct.\nBio-Neural Interface: STABLE\nCore Systems: NOMINAL [Confidence: 99.8%]\n\nData Codex access granted. Safety protocols engaged.\nReport detected spatio-temporal anomalies via secure comms channel immediately.\n\n++ SysCore Operational Branch ++", read: false }, { id: 2, sender: "Supply Chain AI [QM-7 Designation]", subject: "Equipment Dispatch Confirmation", date: "Cycle 34.0 REV 5", body: "Recipient: V. Vyntarion (VST-VYN)\n\nStandard Issue Loadout dispatched to designated access point:\n- Integrated Sidearm Unit [Check Scanner Interface]\n- Medi-Gel Injector x2\n- Access Credential: Sector Alpha x1\n\nInventory verification requested upon retrieval.\n\n-- QM-7 Logistical Matrix --", read: false }, { id: 3, sender: "Automated Hazard Monitor", subject: "ALERT: Unstable Energy Signature - Sector Gamma", date: "Cycle 33.9 REV 12", body: "PRIORITY ALERT ::\n\nUnidentified high-energy resonance pattern detected.\nOrigin Point: Sector Gamma / Grid Reference 7G-Delta-9.\nMagnitude exceeds standard variance thresholds by 4 sigmas.\nPhenomenon signature inconsistent with known subspace events.\n\nACTION: Avoid designated zone. Hazard Containment Team en route.\n\nRECORD ID: AE-8873-G-HIGH", read: true }, { id: 4, sender: "Dr. Aris Thorne [Secured Channel]", subject: "Query Follow-up // Urgent Data Request", date: "Cycle 33.8 REV 2", body: "Vesta,\n\nThe chroniton field flux patterns you logged... they defy current models. My quantum simulations are producing paradoxical outcomes, pointing towards an external 'observer' effect or a causal loop. Cannot confirm without hard data.\n\nYour scanner array is key. Focus on *any* anomalous energy readings, particularly those exhibiting temporal shear or non-linear decay signatures. Log everything and transmit directly via this secured channel ONLY. Designate Priority Alpha.\n\nMaintain vigilance. This research is critical.\n\n// Aris //", read: false }, ];

         // ----- Initial Setup -----
         document.addEventListener('DOMContentLoaded', () => {
             // Trigger login panel fade-in after a short delay
             setTimeout(() => {
                 if (loginPanel) { // Check if element exists
                     loginPanel.classList.add('visible');
                 } else {
                    console.error("Login panel not found!");
                 }
             }, 300); // Small delay for boot effect

            setupInventoryPlaceholders();
            addInventoryEventListeners(); // Add listeners after placeholders are set up
         });


         // ----- Login Handling -----
        loginButton.addEventListener("click", function() {
            const usernameInput = document.getElementById("username");
            const passcodeInut = document.getElementById("passcode");
            // Basic check if inputs exist before getting value
            const username = usernameInput ? usernameInput.value.trim() : "";
            const passcode = passcodeInut ? passcodeInut.value.trim() : "";

            if (username && passcode) {
                if (loginPanel) {
                    loginPanel.classList.add("hidden");
                }
                 // <<< FIX: Start showing mainContent immediately >>>
                if (mainContent) {
                     mainContent.classList.add("visible"); // Make main content start its transition
                 } else {
                    console.error("Main content container not found!");
                    return; // Stop if main content is missing
                 }

                if (loginPanel) {
                    // Still hide the login panel completely after its transition for performance
                     loginPanel.addEventListener('transitionend', () => {
                         loginPanel.style.display = "none";
                     }, { once: true });
                }

                // Start background animation timing
                loadingStartTime = Date.now() * 0.001;
                if (typeof THREE !== 'undefined') { // Check if Three.js loaded
                    console.log("Three.js loaded, initializing scene...");
                    initThreeJS();
                    animateThreeJS();
                } else {
                    console.error("Three.js failed to load.");
                    alert("Error: Background visualization library failed to load.")
                }
            } else {
                alert("Access denied. Valid credentials required.");
            }
        });


        // ----- Navigation & Panel Switching Logic -----
        navButtons.forEach(btn => {
            btn.addEventListener("click", () => {
                const section = btn.getAttribute("data-section");
                let currentlyActive = document.querySelector('.content-card.active, #inventoryContainer.active');
                let buttonActive = document.querySelector('nav button.active');

                // If clicking the already active button, close the panel
                if (buttonActive === btn && currentlyActive) {
                    currentlyActive.classList.remove('active');
                    btn.classList.remove('active');
                    resetItemInfo(); // Reset inventory info if closing
                    resetEmailContent(); // Reset email if closing
                    if (selectedSlot) { // Check if selectedSlot is not null
                        selectedSlot.classList.remove('selected'); // Deselect inventory item
                    }
                    selectedSlot = null;
                    return; // Stop further processing
                }

                // Deactivate all buttons and panels first
                navButtons.forEach(b => b.classList.remove("active"));
                contentCards.forEach(card => card.classList.remove("active"));
                if (inventoryContainer) { // Check if exists
                    inventoryContainer.classList.remove("active");
                }

                // Activate the clicked button
                btn.classList.add("active");

                // Reset states before showing new panel
                resetItemInfo(); // Reset inventory info
                resetEmailContent(); // Reset email info
                if (selectedSlot) { // Deselect previous item visually
                    selectedSlot.classList.remove('selected');
                    selectedSlot = null;
                }

                // Show the correct panel
                if (section === "inventory") {
                    if (inventoryContainer) { // Check if exists
                        inventoryContainer.classList.add("active");
                    } else {
                        console.error("Inventory container not found!");
                    }
                } else {
                    const targetCard = document.getElementById(section);
                    if (targetCard) {
                        targetCard.classList.add("active");
                        if (section === "email") {
                            populateEmailList();
                            resetEmailContent(); // Ensure placeholder shows first
                        }
                    } else {
                        console.error(`Content card with ID "${section}" not found!`);
                    }
                }
            });
        });

         // ----- Inventory Interaction Logic -----
         function setupInventoryPlaceholders() {
             if (!inventoryGrid) return; // Ensure grid exists

             const slots = inventoryGrid.querySelectorAll(".inventory-slot");
             slots.forEach(slot => {
                 const img = slot.querySelector('img');
                 if (!img) return; // Skip if slot has no img element

                 const itemId = slot.getAttribute('data-itemid');
                 let itemImageSrc = ''; // Default to empty

                 if (itemId && inventoryItems[itemId] && inventoryItems[itemId].img) {
                     // Use defined image if available
                     // *** IMPORTANT: Replace with actual path logic if needed ***
                     // For this demo, we assume the 'img' value is just the filename
                     // and we won't actually load it, just set alt text.
                     itemImageSrc = inventoryItems[itemId].img; // Keep track of intended image
                     img.alt = inventoryItems[itemId].name;
                     img.src = itemImageSrc; // Try setting the src (will likely fail without real paths)
                     img.style.opacity = "1"; // Assume real image is opaque
                 } else {
                     // Generate placeholder SVG for empty slots or items without defined images
                     const placeholderSvg = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 100 100">
                             <rect width="100" height="100" fill="rgba(0,204,255,0.02)"/>
                            <circle cx="50" cy="50" r="35" fill="none" stroke="rgba(0,204,255,0.2)" stroke-width="3" stroke-dasharray="10 5"/>
                             <line x1="30" y1="50" x2="70" y2="50" stroke="rgba(0,204,255,0.15)" stroke-width="3"/>
                             <line x1="50" y1="30" x2="50" y2="70" stroke="rgba(0,204,255,0.15)" stroke-width="3"/>
                         </svg>`;
                     img.src = `data:image/svg+xml;base64,${btoa(placeholderSvg)}`;
                     img.style.opacity = "0.4"; // Make placeholder less prominent
                     img.alt = "Empty Slot";
                 }
             });
             // Re-select slots after potential changes
             inventorySlots = inventoryGrid.querySelectorAll(".inventory-slot");
         }

        function addInventoryEventListeners() {
            if (!inventorySlots) {
                console.warn("Inventory slots not ready for event listeners.");
                setupInventoryPlaceholders(); // Try setting up again just in case
                inventorySlots = inventoryGrid ? inventoryGrid.querySelectorAll(".inventory-slot") : []; // Re-select
                if (!inventorySlots || inventorySlots.length === 0) {
                    console.error("Failed to find inventory slots after setup attempt.");
                    return;
                }
             }

             inventorySlots.forEach(slot => {
                 slot.addEventListener("click", () => {
                     handleInventorySlotClick(slot);
                 });
             });

             // Item action buttons (check if they exist)
             if (itemUseButton) {
                 itemUseButton.addEventListener("click", handleItemUse);
             }
             if (itemDropButton) {
                itemDropButton.addEventListener("click", handleItemDrop);
             }
         }

         function handleInventorySlotClick(slot) {
            if (!slot) return; // Safety check
            const itemId = slot.getAttribute("data-itemid");

             // Deselect previous slot
            if (selectedSlot && selectedSlot !== slot) { // Check it's not the same slot
                selectedSlot.classList.remove("selected");
             }

             // Reset info panel first
            resetItemInfo(false); // Don't set placeholder text yet

             if (itemId && inventoryItems[itemId]) {
                const item = inventoryItems[itemId];
                if (itemInfoTitle) itemInfoTitle.textContent = item.name;
                if (itemInfoDesc) itemInfoDesc.textContent = item.description;
                if (itemUseButton) itemUseButton.disabled = !item.usable;
                if (itemDropButton) itemDropButton.disabled = false;
                slot.classList.add("selected");
                selectedSlot = slot;
             } else {
                 // Empty slot selected
                 if (itemInfoTitle) itemInfoTitle.textContent = "Empty Slot Designation";
                 if (itemInfoDesc) itemInfoDesc.textContent = "No object detected in this grid coordinate.";
                 if (itemUseButton) itemUseButton.disabled = true;
                 if (itemDropButton) itemDropButton.disabled = true;
                 slot.classList.add("selected"); // Still visually select the empty slot
                 selectedSlot = slot;
             }
         }


         function handleItemUse() {
             if (selectedSlot && itemUseButton && !itemUseButton.disabled) {
                 const itemId = selectedSlot.getAttribute("data-itemid");
                 if (itemId && inventoryItems[itemId]) {
                    console.log(`Attempting to use: ${inventoryItems[itemId].name}`); // Log action
                    alert(`Interfaced with ${inventoryItems[itemId].name}.`);
                    // Future: Add real use logic (e.g., consume, apply effect, remove item)
                    // If consumable: removeItemFromSlot(selectedSlot);
                }
            }
         }

         function handleItemDrop() {
             if (selectedSlot && itemDropButton && !itemDropButton.disabled) {
                const itemId = selectedSlot.getAttribute("data-itemid");
                 const itemName = (itemId && inventoryItems[itemId]) ? inventoryItems[itemId].name : "the empty slot data";
                 if (confirm(`Confirm jettison command for: ${itemName}? This action is irreversible.`)) {
                     console.log(`Attempting to drop: ${itemName}`); // Log action
                     alert(`Jettisoned ${itemName}.`);
                     // Future: Add real drop logic
                    if (itemId) {
                         removeItemFromSlot(selectedSlot);
                     } else {
                          // Clear selection even if it was an empty slot clicked before dropping nothing
                         selectedSlot.classList.remove('selected');
                         resetItemInfo(); // Show default placeholder
                         selectedSlot = null;
                     }
                }
            }
         }

        function removeItemFromSlot(slot) {
            if (!slot) return; // Safety check
            slot.removeAttribute("data-itemid");
            const img = slot.querySelector('img');
            if (img) { // Replace image with placeholder SVG
                const placeholderSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 100 100"><rect width="100" height="100" fill="rgba(0,204,255,0.02)"/><circle cx="50" cy="50" r="35" fill="none" stroke="rgba(0,204,255,0.2)" stroke-width="3" stroke-dasharray="10 5"/><line x1="30" y1="50" x2="70" y2="50" stroke="rgba(0,204,255,0.15)" stroke-width="3"/><line x1="50" y1="30" x2="50" y2="70" stroke="rgba(0,204,255,0.15)" stroke-width="3"/></svg>`;
                img.src = `data:image/svg+xml;base64,${btoa(placeholderSvg)}`;
                img.style.opacity = "0.4";
                 img.alt = "Empty Slot";
            }
            // Reset info panel and selection state
            slot.classList.remove('selected');
            resetItemInfo(); // Reset to placeholder text
            selectedSlot = null;
         }


        function resetItemInfo(showPlaceholderText = true) {
            if(showPlaceholderText) {
                 if (itemInfoTitle) itemInfoTitle.textContent = "Analysis Grid";
                 if (itemInfoDesc) itemInfoDesc.textContent = "Designate inventory object for detailed scan.";
            }
             if (itemUseButton) itemUseButton.disabled = true;
             if (itemDropButton) itemDropButton.disabled = true;
             // Do not deselect the visual slot here, only reset the text/buttons
             // The calling function should handle deselecting the slot if needed.
         }


        // ----- Email Section Logic -----
        function populateEmailList() {
            if (!emailList) return; // Safety check
            emailList.innerHTML = ''; // Clear previous list
            emails.sort((a, b) => b.id - a.id); // Sort newest first
             emails.forEach(email => {
                const li = document.createElement('li');
                li.setAttribute('data-email-id', email.id);
                li.classList.toggle('read', email.read);
                li.classList.toggle('unread', !email.read);

                const senderSpan = document.createElement('span');
                 senderSpan.className = 'sender holo-text'; // Apply class
                senderSpan.textContent = email.sender;

                 const subjectSpan = document.createElement('span');
                 subjectSpan.className = 'subject holo-text'; // Apply class
                subjectSpan.textContent = email.subject;

                 li.appendChild(senderSpan);
                 li.appendChild(subjectSpan);

                 li.addEventListener('click', () => {
                     // Deselect other emails visually first
                    const activeItems = emailList.querySelectorAll('li.active');
                     activeItems.forEach(item => item.classList.remove('active'));
                     // Select clicked email
                    li.classList.add('active');
                    displayEmailContent(email.id);
                 });
                 emailList.appendChild(li);
             });
         }

         function displayEmailContent(emailId) {
             const email = emails.find(e => e.id === emailId);
             if (email) {
                 // Ensure elements exist before manipulating
                 if (emailPlaceholder) emailPlaceholder.style.display = 'none';
                 if (emailSubjectEl) { emailSubjectEl.style.display = 'block'; emailSubjectEl.textContent = email.subject; }
                 if (emailMetaEl) emailMetaEl.style.display = 'block';
                 if (emailSenderEl) emailSenderEl.textContent = `Origin Signal: ${email.sender}`;
                 if (emailDateEl) emailDateEl.textContent = `Timestamp: ${email.date}`;
                 if (emailBodyEl) { emailBodyEl.style.display = 'block'; emailBodyEl.textContent = email.body; }

                if (!email.read) {
                     email.read = true;
                     const listItem = emailList ? emailList.querySelector(`li[data-email-id="${emailId}"]`) : null;
                     if (listItem) {
                         listItem.classList.remove('unread');
                         listItem.classList.add('read');
                     }
                 }
                 if (emailContent) {
                    emailContent.scrollTop = 0; // Scroll to top of message
                 }
            } else {
                console.warn(`Email with ID ${emailId} not found.`);
                resetEmailContent(); // Show placeholder if email not found
            }
         }

         function resetEmailContent() {
             if (emailPlaceholder) emailPlaceholder.style.display = 'block';
             if (emailSubjectEl) emailSubjectEl.style.display = 'none';
             if (emailMetaEl) emailMetaEl.style.display = 'none';
             if (emailBodyEl) emailBodyEl.style.display = 'none';
            // Remove active class from list items if any
            if (emailList) {
                const activeItems = emailList.querySelectorAll('li.active');
                activeItems.forEach(item => item.classList.remove('active'));
            }
         }

        // ----- Ripple Effect on Click -----
        document.addEventListener("click", function (e) {
            // Prevent ripple on interactive elements OR inside already active panels/inventory
            if (e.target.closest('button, .inventory-slot, #emailList li, input, .content-card.active, #inventoryContainer.active')) {
                return;
            }

            const ripple = document.createElement("div");
            ripple.classList.add("ripple");
            const size = Math.min(window.innerWidth, window.innerHeight) * 0.5; // Slightly smaller ripple base
            ripple.style.width = ripple.style.height = size + "px";
            // Center ripple on click coords
            ripple.style.left = e.clientX - size / 2 + "px";
            ripple.style.top = e.clientY - size / 2 + "px";
            document.body.appendChild(ripple);

            // Use animationend event for removal
            ripple.addEventListener("animationend", () => {
                if (ripple.parentNode) { // Check if it's still attached
                    ripple.remove();
                }
            }, { once: true }); // Ensure listener is removed after firing once
         });

         // ----- Three.js Scene & Animation Code -----
        let scene, camera, renderer;
        let corridor;
        let ceilingMesh, leftWallMesh, rightWallMesh;
        let glyphs = [];
        let globalGlyphFade = 0;
        const CORRIDOR_SIZE = 2500;
        let mouse = new THREE.Vector2(0, 0);
        let targetRotationX = 0, targetRotationY = 0;
        let floorTexture, ceilingTexture, leftWallTexture, rightWallTexture;
        const SCROLL_SPEED_FLOOR = 0.0007;
        const SCROLL_SPEED_CODE = 0.0005;
        let plexusGroup;
        const repulsionDistance = 130; // Slightly increased interaction distance
        const repulsionForce = 1.8;   // Slightly stronger push
        const friction = 0.92;        // Slightly less friction (moves longer)

        // Renamed init/animate functions
         function initThreeJS() {
             try { // Add a try...catch block for robust initialization
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0d1b2a);
                scene.fog = new THREE.FogExp2(0x0d1b2a, 0.0007); // Keep fog

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
                camera.position.set(0, 0, 1800); // Initial camera position
                camera.lookAt(0, 0, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio); // Added for sharper rendering
                renderer.setSize(window.innerWidth, window.innerHeight);
                 // Ensure canvas is styled correctly by CSS (position: fixed, z-index: -1)
                 document.body.insertBefore(renderer.domElement, document.body.firstChild); // Add canvas to body start

                // --- Lights ---
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.45); // Slightly brighter ambient
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xADD8E6, 0.35); // Lighter blue directional
                directionalLight.position.set(1, 1.5, 1).normalize();
                scene.add(directionalLight);

                // --- Corridor ---
                corridor = new THREE.Group();
                scene.add(corridor);

                // --- Textures ---
                leftWallTexture = createCodeTexture(512);
                 if(leftWallTexture) { // Check texture creation success
                    leftWallTexture.wrapS = leftWallTexture.wrapT = THREE.RepeatWrapping;
                    leftWallTexture.repeat.set(4, 5);
                 }
                rightWallTexture = createCodeTexture(512);
                 if(rightWallTexture) {
                    rightWallTexture.wrapS = rightWallTexture.wrapT = THREE.RepeatWrapping;
                    rightWallTexture.repeat.set(4, 5);
                 }
                floorTexture = createCodeTexture(512);
                 if(floorTexture) {
                    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
                    floorTexture.repeat.set(4, 10);
                 }
                ceilingTexture = createCircuitTexture(512);
                 if(ceilingTexture) {
                    ceilingTexture.wrapS = ceilingTexture.wrapT = THREE.RepeatWrapping;
                    ceilingTexture.repeat.set(3, 3); // Slightly denser ceiling circuits
                 }

                // --- Materials ---
                 // Ensure textures exist before creating materials that use them
                const wallMat = new THREE.MeshPhongMaterial({
                    map: leftWallTexture, // Will be null if texture failed
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.65,
                    specular: 0x111111,
                    shininess: 10
                });
                 const floorMat = new THREE.MeshPhongMaterial({ map: floorTexture, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
                 const ceilingMat = new THREE.MeshPhongMaterial({ map: ceilingTexture, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });

                // --- Geometry ---
                const planeGeo = new THREE.PlaneGeometry(CORRIDOR_SIZE, CORRIDOR_SIZE);

                // --- Meshes ---
                ceilingMesh = new THREE.Mesh(planeGeo, ceilingMat);
                ceilingMesh.rotation.x = Math.PI / 2;
                ceilingMesh.position.y = CORRIDOR_SIZE / 2;
                corridor.add(ceilingMesh);

                leftWallMesh = new THREE.Mesh(planeGeo.clone(), wallMat.clone()); // Clone geometry too for safety
                if(leftWallMesh.material) leftWallMesh.material.map = leftWallTexture; // Assign map if material exists
                leftWallMesh.rotation.y = Math.PI / 2;
                leftWallMesh.position.x = -CORRIDOR_SIZE / 2 - 500; // Start off-screen
                corridor.add(leftWallMesh);

                rightWallMesh = new THREE.Mesh(planeGeo.clone(), wallMat.clone());
                if(rightWallMesh.material) rightWallMesh.material.map = rightWallTexture;
                rightWallMesh.rotation.y = -Math.PI / 2;
                rightWallMesh.position.x = CORRIDOR_SIZE / 2 + 500; // Start off-screen
                corridor.add(rightWallMesh);

                // --- Plexus ---
                 plexusGroup = createScrollingPlexus();
                 if (!plexusGroup) {
                     console.error("Plexus creation failed. Skipping add.");
                 } else {
                    plexusGroup.rotation.x = -0.2;
                     plexusGroup.scale.set(0, 0, 0); // Start scaled down
                     plexusGroup.renderOrder = 1;
                    scene.add(plexusGroup);
                }

                 // --- Glyphs ---
                const glyphLetters = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
                 glyphs = []; // Clear glyphs array before creating new ones
                for (let i = 0; i < 40; i++) {
                     const letter = glyphLetters[Math.floor(Math.random() * glyphLetters.length)];
                     const sprite = createGlyphSprite(letter);
                     if (!sprite) continue; // Skip if sprite creation failed

                     const radius = 800 + Math.random() * 1000;
                     const angle = Math.random() * Math.PI * 2;
                     const height = Math.random() * 1950 - 700;
                     const depth = -Math.random() * (CORRIDOR_SIZE * 0.8);
                     sprite.position.set(Math.cos(angle) * radius, height, depth);

                    sprite.userData = {
                         basePosition: sprite.position.clone(),
                         oscillationSpeed: Math.random() * 0.4 + 0.3,
                         velocity: new THREE.Vector3(0, 0, 0),
                         lifetime: Math.random() * 15,
                         maxLifetime: 15 + Math.random() * 10
                     };
                     glyphs.push(sprite);
                     scene.add(sprite);
                 }

                 // --- Event Listeners ---
                 window.addEventListener("resize", onWindowResize, false);
                 document.addEventListener("mousemove", onDocumentMouseMove, false);

                 console.log("Three.js scene initialized successfully.");

             } catch (error) {
                 console.error("Error during Three.js initialization:", error);
                 alert("Failed to initialize 3D background. Please check console for errors.");
                 renderer = null; // Flag that initialization failed
             }
         }


         function animateThreeJS() {
            // Stop animation if renderer failed to initialize or scene/camera missing
             if (!renderer || !scene || !camera) return;

             requestAnimationFrame(animateThreeJS);
            const time = Date.now() * 0.001;
             // Ensure loadingStartTime is set before calculating elapsedTime
             if (typeof loadingStartTime === 'undefined') return;
             const elapsedTime = time - loadingStartTime;
            if (isNaN(elapsedTime) || elapsedTime < 0) return; // Additional safety check


            // --- Animations Based on Elapsed Time Since Login ---

            // Global glyph fade-in
             const glyphStartDelay = 0.5;
            const glyphFadeDuration = 2.0;
             // Update glyph fade calculation (check if glyphs array exists)
             if(glyphs && glyphs.length > 0) {
                 globalGlyphFade = (elapsedTime < glyphStartDelay) ? 0 : Math.min((elapsedTime - glyphStartDelay) / glyphFadeDuration, 0.7);
             } else {
                globalGlyphFade = 0;
             }

             // Corridor rotation based on mouse
            if (corridor) {
                 corridor.rotation.y += (targetRotationY - corridor.rotation.y) * 0.04;
                 corridor.rotation.x += (targetRotationX - corridor.rotation.x) * 0.04;
            }

             // Animate walls sliding in
            if (leftWallMesh && rightWallMesh) {
                 const wallAnimDuration = 2.5;
                 const wallStartDelay = 0.4;
                 if (elapsedTime >= wallStartDelay && elapsedTime < wallStartDelay + wallAnimDuration) {
                    const progress = (elapsedTime - wallStartDelay) / wallAnimDuration;
                    const easeProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);
                     // Check position exists before setting
                    if (leftWallMesh.position) {
                        leftWallMesh.position.x = THREE.MathUtils.lerp(-CORRIDOR_SIZE / 2 - 500, -CORRIDOR_SIZE / 2, easeProgress);
                    }
                    if (rightWallMesh.position) {
                        rightWallMesh.position.x = THREE.MathUtils.lerp(CORRIDOR_SIZE / 2 + 500, CORRIDOR_SIZE / 2, easeProgress);
                    }
                 } else if (elapsedTime >= wallStartDelay + wallAnimDuration) {
                     // Ensure final position is exact after animation
                    if (leftWallMesh.position) leftWallMesh.position.x = -CORRIDOR_SIZE / 2;
                    if (rightWallMesh.position) rightWallMesh.position.x = CORRIDOR_SIZE / 2;
                 }
            }

            // Texture scrolling
            // Check texture and offset exist before modifying
             if(floorTexture?.offset) floorTexture.offset.y += SCROLL_SPEED_FLOOR;
             if(leftWallTexture?.offset) leftWallTexture.offset.y += SCROLL_SPEED_CODE;
             if(rightWallTexture?.offset) rightWallTexture.offset.y += SCROLL_SPEED_CODE;
             if(ceilingTexture?.offset) ceilingTexture.offset.y -= SCROLL_SPEED_FLOOR * 0.5;


             // Animate plexus appearance
            if(plexusGroup?.scale) { // Check if plexusGroup and scale exist
                 const plexusStartDelay = 3.0;
                 const plexusAnimDuration = 1.8;
                 if (elapsedTime < plexusStartDelay) {
                    plexusGroup.scale.set(0, 0, 0);
                 } else if (elapsedTime < plexusStartDelay + plexusAnimDuration) {
                     const s = (elapsedTime - plexusStartDelay) / plexusAnimDuration;
                     const easeS = 1 - Math.pow(1 - s, 3);
                     plexusGroup.scale.set(easeS, easeS, easeS);
                 } else {
                     plexusGroup.scale.set(1, 1, 1); // Ensure final scale is 1
                 }
            }


            // Update dynamic elements
            // Check if plexus exists and is scaled up before updating
             if (plexusGroup?.children?.length > 0 && plexusGroup?.scale?.x > 0.01) {
                 updateScrollingPlexus(plexusGroup.children[0], time);
             }
             // Check if glyphs array exists and has items before updating
             if (glyphs && glyphs.length > 0) {
                 updateGlyphs(time);
             }

            // Render scene
            renderer.render(scene, camera);
         }

         // --- Helper functions for Three.js ---

         function createScrollingPlexus() {
             try { // Add try-catch for robustness
                const group = new THREE.Group();
                const nodeCount = 180, threshold = 450, scrollSpeed = 0.8;
                const regionMinX = -1200, regionMaxX = 1200, regionMinY = -1150, regionMaxY = -650;
                const regionMinZ = -3200, regionMaxZ = 1300;
                const regionWidth = regionMaxX - regionMinX, regionDepth = regionMaxZ - regionMinZ;

                const nodes = [];
                for (let i = 0; i < nodeCount; i++) {
                    nodes.push(
                        new THREE.Vector3(
                            THREE.MathUtils.randFloat(regionMinX, regionMaxX),
                            THREE.MathUtils.randFloat(regionMinY, regionMaxY),
                            THREE.MathUtils.randFloat(regionMinZ, regionMaxZ)
                        )
                    );
                }

                const geometry = new THREE.BufferGeometry();
                const material = new THREE.LineBasicMaterial({
                    color: 0x00aaff,
                    transparent: true,
                    opacity: 0.45,
                    depthWrite: false
                });

                const plexusLines = new THREE.LineSegments(geometry, material);
                plexusLines.frustumCulled = false;
                plexusLines.renderOrder = 1;
                plexusLines.userData = { nodes, regionMinZ, regionMaxZ, regionDepth, threshold, scrollSpeed };
                group.add(plexusLines);
                return group;
            } catch (error) {
                console.error("Error creating plexus:", error);
                return null; // Return null on failure
            }
         }


         function updateScrollingPlexus(plexusLines, time) {
            // Basic checks for existence
            if (!plexusLines?.geometry || !plexusLines?.userData?.nodes) return;

            const geometry = plexusLines.geometry;
            const { nodes, regionMinZ, regionMaxZ, regionDepth, threshold, scrollSpeed } = plexusLines.userData;
            const positions = [];

            // Update node positions
            for (const n of nodes) {
                if (!n?.z || !n?.y) continue; // Check if n and properties exist

                n.z += scrollSpeed;
                n.y += (Math.random() - 0.5) * 0.5;
                if (n.z > regionMaxZ + 100) n.z = regionMinZ - THREE.MathUtils.randFloat(0, 100);
                n.y = THREE.MathUtils.clamp(n.y, -1150, -650);
            }

            // Calculate line segments
            if(nodes.length > 1) {
                for (let i = 0; i < nodes.length; i++) {
                   if(!nodes[i]) continue;
                    for (let j = i + 1; j < nodes.length; j++) {
                        if(!nodes[j]) continue;
                        try {
                            const distSq = nodes[i].distanceToSquared(nodes[j]);
                           if (distSq < threshold * threshold) {
                               positions.push(nodes[i].x, nodes[i].y, nodes[i].z);
                                positions.push(nodes[j].x, nodes[j].y, nodes[j].z);
                           }
                        } catch(e) {
                           console.warn("Error calculating distance in plexus:", e, nodes[i], nodes[j]);
                        }
                   }
                }
            }

            // Update geometry attributes
            // Ensure setAttribute method exists
            if (geometry.setAttribute) {
                if (positions.length > 0) {
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                } else if (geometry.getAttribute('position') && geometry.getAttribute('position').count > 0) {
                    // Clear buffer if no lines
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
                }
                // Only update if attribute exists
                if (geometry.attributes.position) {
                    geometry.attributes.position.needsUpdate = true;
                }
            }
         }


        function createCodeTexture(size) {
            const canvas = document.createElement("canvas");
             canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext("2d");
             if (!ctx) { console.error("Failed to get 2D context for code texture"); return null; }
            ctx.fillStyle = "#08141E";
            ctx.fillRect(0, 0, size, size);
             ctx.fillStyle = "rgba(0, 180, 220, 0.5)";
            ctx.font = "11px monospace";
            const codeChars = ["0","1","","","","<",">","/","{","}","[","]","","","","","","","","","","","","","","","","", ":", ";"];
            const columns = 35, rows = 45;
            const colWidth = size / columns, rowHeight = size / rows;
            for (let c = 0; c < columns; c++) {
                for (let r = 0; r < rows; r++) {
                     if (Math.random() > 0.2) {
                        const char = codeChars[Math.floor(Math.random() * codeChars.length)];
                         ctx.fillText(char, c * colWidth + Math.random()*5, r * rowHeight + rowHeight * 0.8 + Math.random()*5);
                     }
                 }
             }
             return new THREE.CanvasTexture(canvas);
         }

         function createCircuitTexture(size) {
             const canvas = document.createElement("canvas");
             canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext("2d");
            if (!ctx) { console.error("Failed to get 2D context for circuit texture"); return null; }
            ctx.fillStyle = "#0A1825";
             ctx.fillRect(0, 0, size, size);
            const circuitColor = "rgba(0, 204, 255, 0.25)";
            ctx.lineWidth = 1.5;
             for (let i = 0; i < 35; i++) {
                ctx.strokeStyle = circuitColor;
                 ctx.beginPath();
                let x1 = Math.random() * size, y1 = Math.random() * size;
                let x2, y2;
                 if(Math.random() < 0.7) {
                     if(Math.random() < 0.5) { x2 = Math.random() * size; y2 = y1; }
                    else { x1 = Math.random() * size; x2 = x1; y2 = Math.random() * size; }
                 } else {
                    x2 = x1 + (Math.random() - 0.5) * 100; y2 = y1 + (Math.random() - 0.5) * 100;
                 }
                 ctx.moveTo(x1, y1);
                 ctx.lineTo(x2, y2);
                ctx.stroke();
             }
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = circuitColor;
                 ctx.beginPath();
                 let cx = Math.random() * size, cy = Math.random() * size;
                 let r = Math.random() * 1.5 + 0.5;
                 ctx.arc(cx, cy, r, 0, Math.PI * 2);
                 ctx.fill();
             }
             return new THREE.CanvasTexture(canvas);
         }

        function createGlyphSprite(letter) {
            try {
                const canvas = document.createElement("canvas");
                canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext("2d");
                if (!ctx) { console.error("Failed to get 2D context for glyph sprite"); return null; }

                ctx.clearRect(0, 0, 128, 128);
                ctx.shadowColor = "rgba(0, 204, 255, 0.8)";
                ctx.shadowBlur = 15;
                ctx.font = "90px 'Orbitron', sans-serif";
                ctx.fillStyle = "rgba(200, 255, 255, 1.0)";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(letter, 64, 64);
                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    alphaTest: 0.05,
                    sizeAttenuation: true,
                    depthWrite: false
                });
                const sprite = new THREE.Sprite(material);
                sprite.renderOrder = 2;
                return sprite;
            } catch (error) {
                console.error("Error creating glyph sprite:", error);
                return null;
            }
         }


         function updateGlyphs(time) {
             // Add checks for camera existence
            if (!camera || !glyphs || glyphs.length === 0) return;

             const cameraPos = camera.position;

             glyphs.forEach(sprite => {
                // Check if sprite and its core properties are valid
                if (!sprite?.userData || !sprite?.material || !sprite?.position || !sprite?.scale) return;

                sprite.userData.lifetime = (sprite.userData.lifetime ?? 0) + 1 / 60;
                 const lifeRatio = sprite.userData.lifetime / (sprite.userData.maxLifetime || 1);
                 const fade = Math.sin(Math.min(lifeRatio, 1.0) * Math.PI);
                sprite.material.opacity = Math.max(fade, 0) * (globalGlyphFade || 0);

                 // Respawn logic
                 if (lifeRatio >= 1.0) {
                    sprite.userData.lifetime = 0;
                     const radius = 1000 + Math.random() * 800;
                     const angle = Math.random() * Math.PI * 2;
                     const height = Math.random() * 1800 - 800;
                     const depth = - (CORRIDOR_SIZE * 0.5) - Math.random() * (CORRIDOR_SIZE * 0.5);
                     sprite.position.set(Math.cos(angle) * radius, height, depth);
                    if(sprite.userData.basePosition) sprite.userData.basePosition.copy(sprite.position);
                     if(sprite.userData.velocity) sprite.userData.velocity.set(0, 0, 0);
                }

                // Base Oscillation
                 if (sprite.userData.basePosition) {
                     const t = time * (sprite.userData.oscillationSpeed || 0.5);
                     const ox = Math.sin(t * 0.8) * 10;
                     const oy = Math.cos(t * 1.2) * 8;
                    sprite.position.x = sprite.userData.basePosition.x + ox;
                    sprite.position.y = sprite.userData.basePosition.y + oy;
                 }

                // Mouse Repulsion
                 try {
                    const spriteScreenPos = sprite.position.clone().project(camera);
                    const glyphScreenX = (spriteScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const glyphScreenY = (-spriteScreenPos.y * 0.5 + 0.5) * window.innerHeight;
                    const mouseScreenX = (mouse.x * 0.5 + 0.5) * window.innerWidth;
                    const mouseScreenY = (-mouse.y * 0.5 + 0.5) * window.innerHeight;
                    const dist = Math.hypot(glyphScreenX - mouseScreenX, glyphScreenY - mouseScreenY);
                    let pushX = 0, pushY = 0;

                    if (dist < repulsionDistance && dist > 1) {
                        const dx = glyphScreenX - mouseScreenX;
                        const dy = glyphScreenY - mouseScreenY;
                        const angle = Math.atan2(dy, dx);
                        const force = (repulsionDistance / dist - 1) * repulsionForce * 0.5;
                        pushX = Math.cos(angle) * force;
                         pushY = Math.sin(angle) * force;
                    }

                    if(sprite.userData.velocity){
                        sprite.userData.velocity.x = (sprite.userData.velocity.x || 0) + pushX * 0.1;
                        sprite.userData.velocity.y = (sprite.userData.velocity.y || 0) + pushY * 0.1;
                        sprite.userData.velocity.multiplyScalar(friction);
                        sprite.position.addScaledVector(sprite.userData.velocity, 0.1);
                     }
                 } catch (e) {
                    console.warn("Error during glyph projection/repulsion:", e, sprite);
                 }

                 // --- Size Attenuation based on Distance ---
                 try {
                     const d = cameraPos.distanceTo(sprite.position);
                     const minDist = 300, maxDist = 2500;
                    const scaleClose = 280, scaleFar = 140;
                    const clampDist = THREE.MathUtils.clamp(d, minDist, maxDist);
                    const alpha = (clampDist - minDist) / (maxDist - minDist);
                     const finalScale = THREE.MathUtils.lerp(scaleClose, scaleFar, alpha);
                    sprite.scale.set(finalScale, finalScale, 1);
                } catch (e) {
                    console.warn("Error during glyph scaling:", e, sprite);
                }
            });
         }

         // Note: spawnGlyphOnWall is defined but not currently used in the respawn logic. Kept for potential future use.
        function spawnGlyphOnWall(sprite) {
             if (!sprite?.position) return;
            const wallDistX = CORRIDOR_SIZE / 2 - 50;
            const heightRange = 1600;
            const heightOffset = -600;
             const depthRange = CORRIDOR_SIZE * 0.8;
            const depthOffset = -CORRIDOR_SIZE * 0.1;
            let x, y, z = depthOffset - Math.random() * depthRange;
             y = heightOffset + Math.random() * heightRange;
             if(Math.random() < 0.5) { x = -wallDistX; } else { x = wallDistX; }
             sprite.position.set(x, y, z);
        }


        function onWindowResize() {
             if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
         }

         function onDocumentMouseMove(event) {
             // mouse object should always exist if declared globally
             mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
             mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const maxRotation = 0.06;
             targetRotationY = mouse.x * maxRotation;
             targetRotationX = mouse.y * maxRotation * 0.5;
         }

     </script>

</body>

</html>
