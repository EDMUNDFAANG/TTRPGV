<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Animus Corridor Simulation [Refined v2]</title>
    <!-- Load Orbitron font -->
    <link href="https://fonts.googleapis.com/css?family=Orbitron" rel="stylesheet">
    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg-color: #0d1b2a;
            --accent-color: #00ccff;
            --text-color: rgba(0, 204, 255, 0.9);
            --panel-bg: rgba(0, 10, 20, 0.5); /* Slightly darker, bluer panel bg */
            --border-color: rgba(0, 204, 255, 0.3);
            --hover-border-color: rgba(0, 204, 255, 0.6);
            --active-bg: rgba(0, 204, 255, 0.2);
            --pulse-color: rgba(0, 204, 255, 0.7); /* For activation pulses */
            --scrollbar-thumb: var(--accent-color);
            --scrollbar-track: rgba(0, 0, 0, 0.2);
        }

        /* ===== Reset & Base Styles ===== */
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: var(--bg-color);
            font-family: 'Orbitron', sans-serif;
            color: var(--text-color);
        }

        canvas {
            display: block;
             /* Keep canvas visible, behind other elements */
             position: fixed;
             top: 0;
             left: 0;
             z-index: -1; /* Place behind all UI */
        }

        /* ===== Holographic Text Style ===== */
        .holo-text {
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-shadow: 0 0 4px rgba(0, 204, 255, 0.8), 0 0 8px rgba(0, 204, 255, 0.5);
            color: var(--text-color);
            animation: textPulse 4s infinite ease-in-out alternate; /* Subtle pulse */
        }
        @keyframes textPulse {
             from { text-shadow: 0 0 4px rgba(0, 204, 255, 0.7), 0 0 8px rgba(0, 204, 255, 0.4); }
             to { text-shadow: 0 0 6px rgba(0, 204, 255, 0.9), 0 0 12px rgba(0, 204, 255, 0.6); }
        }
        /* Less intense pulse for general text */
        p.holo-text, span.holo-text, li .holo-text {
            animation: none; /* Remove default pulse from paragraphs/spans */
            text-shadow: 0 0 3px rgba(0, 204, 255, 0.8), 0 0 6px rgba(0, 204, 255, 0.5);
        }


        /* ===== Login Panel Styling & Boot-Up Animation ===== */
        #loginPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95); /* Start slightly smaller */
            width: 320px; /* Slightly wider */
            padding: 35px;
            border: 2px solid var(--border-color);
            border-radius: 18px;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            text-align: center;
            z-index: 400;
            opacity: 0; /* Start hidden */
            transition: opacity 1.2s ease-out, transform 1.2s ease-out;
            pointer-events: none; /* Not interactive until visible */
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.1);
            overflow: hidden; /* Contain pseudo-elements */
            /* Add pseudo-element for scan line effect */
        }
        #loginPanel::before {
             content: '';
             position: absolute;
             top: 0;
             left: 10%; /* Start off-center */
             width: 2px; /* Thin line */
             height: 100%;
             background: linear-gradient(
                 to bottom,
                 transparent 0%,
                 rgba(0, 204, 255, 0.3) 50%,
                 transparent 100%
             );
             opacity: 0;
             animation: loginScan 5s linear infinite alternate;
             animation-delay: 0.5s; /* Start after fade-in begins */
        }

        @keyframes loginScan {
            0% { left: 10%; opacity: 0.3; }
            100% { left: 90%; opacity: 0.6; } /* Move across and slightly brighten */
        }

        #loginPanel.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1); /* Scale to full size */
            pointer-events: auto;
        }
        #loginPanel.hidden {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
            pointer-events: none;
            transition: opacity 0.6s ease-in, transform 0.6s ease-in; /* Faster fade out */
        }
        #loginPanel h1.holo-text { /* Make title stand out more */
             font-size: 1.6em;
             margin-bottom: 25px;
         }
        #loginPanel input {
            width: 90%;
            margin: 12px 0;
            padding: 10px;
            border: 1px solid var(--accent-color);
            border-radius: 5px;
            background: rgba(0,0,0, 0.2); /* Slightly visible background */
            color: var(--accent-color);
            font-family: 'Orbitron', sans-serif;
            font-size: 1em;
            text-align: center;
            transition: box-shadow 0.3s;
        }
         #loginPanel input:focus {
             outline: none;
             box-shadow: 0 0 8px var(--accent-color);
         }

        #loginPanel button {
            margin-top: 20px;
            padding: 10px 20px;
            border: 2px solid var(--accent-color);
            background: transparent;
            color: var(--accent-color);
            cursor: pointer;
            transition: background 0.3s, transform 0.2s, box-shadow 0.3s;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1em;
            border-radius: 5px;
        }

        #loginPanel button:hover {
            background: var(--active-bg);
             box-shadow: 0 0 10px var(--accent-color);
             transform: translateY(-2px);
        }
         #loginPanel button:active {
              transform: translateY(0px); /* Click down effect */
         }

        /* ===== Main Content ===== */
        #mainContent {
            display: block;
            opacity: 0;
            transform: translateY(20px); /* Start slightly down */
            transition: opacity 1.5s ease-out, transform 1.5s ease-out;
            transition-delay: 0.3s; /* Start fade slightly after login panel starts hiding */
            pointer-events: none;
        }

        #mainContent.visible {
            opacity: 1;
             transform: translateY(0px); /* Slide up to position */
            pointer-events: auto;
        }

        /* ===== Intro Message Overlay ===== */
        #introMessage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.8em; /* Slightly larger */
            z-index: 300;
            opacity: 0;
            /* Starts animating after mainContent becomes visible */
            animation: introAnim 3.5s forwards ease-out; /* Slightly longer */
            animation-delay: 1.0s; /* Delay more to sync better with mainContent appearance */
        }

        @keyframes introAnim { /* Refined easing and scale */
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.7);
            }
             20% { /* Faster rise */
                  opacity: 1;
                  transform: translate(-50%, -50%) scale(1.05);
             }
            80% { /* Hold longer */
                 opacity: 1;
                 transform: translate(-50%, -50%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
        }


        /* ===== Navigation Bar ===== */
        nav {
            position: fixed;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.5); /* Enhanced shadow */
            backdrop-filter: blur(8px); /* More blur */
            opacity: 0;
            transform: translateY(-30px); /* Start further up */
            /* Animation starts after intro message begins fading out */
            animation: navFadeSlideIn 1.2s forwards ease-out;
            animation-delay: 3.0s; /* Matches approx end of introMessage hold */
        }

        @keyframes navFadeSlideIn {
            from {
                opacity: 0;
                 transform: translateY(-30px);
            }
            to {
                opacity: 1;
                 transform: translateY(0);
            }
        }


        nav button {
            background: transparent;
            border: 2px solid var(--accent-color);
            margin: 0 10px;
            padding: 8px 16px;
            cursor: pointer;
            text-transform: uppercase;
            transition: background 0.3s ease, color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
            outline: none;
            opacity: 0; /* Start hidden */
            transform: translateY(-20px); /* Start up */
            color: var(--text-color); /* Inherit text color */
             border-radius: 4px;
             box-shadow: 0 0 5px transparent; /* Placeholder for transition */
            /* Animation Keyframes applied directly */
            animation: buttonFadeSlideIn 0.8s forwards ease-out;
        }

        /* Staggered Delays for Nav Buttons (Relative to Nav Fade-In) */
        nav button[data-section="inventory"] { animation-delay: 3.2s; }
        nav button[data-section="map"]       { animation-delay: 3.35s; }
        nav button[data-section="email"]     { animation-delay: 3.5s; }
        nav button[data-section="codex"]     { animation-delay: 3.65s; }
        nav button[data-section="scanner"]   { animation-delay: 3.8s; }
        nav button[data-section="vitals"]    { animation-delay: 3.95s; }

        @keyframes buttonFadeSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        nav button:hover,
        nav button.active {
            background: var(--active-bg);
            color: #FFF; /* Brighter text */
             box-shadow: 0 0 12px var(--accent-color); /* Glow effect */
            /* Combine transforms smoothly */
            transform: translateY(-2px) scale(1.03);
        }
         nav button:active {
              transform: translateY(0) scale(1); /* Click down effect */
         }


        /* ===== Floating UI Panels ===== */
        .content-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.98); /* Start slightly small */
            width: 75%; /* Wider */
            max-width: 950px;
            height: 65vh; /* Slightly taller */
            max-height: 650px;
            padding: 25px;
            border: 2px solid var(--border-color);
            border-radius: 15px;
            box-shadow: 0 0 25px rgba(0, 204, 255, 0.25); /* Softer, larger shadow */
            background: var(--panel-bg);
            backdrop-filter: blur(12px); /* Increased blur */
            z-index: 100;
            opacity: 0;
            pointer-events: none;
             /* Animate opacity, transform, and add border/shadow pulse */
             transition: opacity 0.5s ease-out, transform 0.5s ease-out;
             /* Prepare for activation animation */
            border-color: var(--border-color);
            box-shadow: 0 0 25px rgba(0, 204, 255, 0.25);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .content-card.active {
            opacity: 1;
            pointer-events: auto;
            /* Run scale animation and pulse animation */
             animation: panelActivate 0.5s ease-out forwards, panelPulse 0.6s ease-out forwards;
        }

        @keyframes panelActivate { /* Scale up slightly more dynamically */
            from { transform: translate(-50%, -50%) scale(0.98); }
             70% { transform: translate(-50%, -50%) scale(1.01); } /* Overshoot slightly */
            to   { transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes panelPulse { /* Brief bright border/shadow */
            0% { border-color: var(--border-color); box-shadow: 0 0 25px rgba(0, 204, 255, 0.25); }
            50% { border-color: var(--pulse-color); box-shadow: 0 0 35px var(--pulse-color); }
             100% { border-color: var(--border-color); box-shadow: 0 0 25px rgba(0, 204, 255, 0.25); }
         }

        /* Staggered content appearance inside active panel */
        .content-card.active h1,
        .content-card.active .panel-content {
            opacity: 0;
             transform: translateY(10px);
            animation: panelContentFadeIn 0.5s ease-out forwards;
            animation-delay: 0.2s; /* Delay after panel activation animation starts */
         }
         @keyframes panelContentFadeIn {
             to { opacity: 1; transform: translateY(0); }
         }


        .content-card h1 {
            margin: 0 0 20px 0; /* More space below title */
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            flex-shrink: 0;
            font-size: 1.8em; /* Larger title */
        }

        .content-card .panel-content {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 15px; /* Space for scrollbar */
        }

        /* ===== Custom Scrollbar ===== */
        .panel-content::-webkit-scrollbar,
        .inventory-grid::-webkit-scrollbar,
        .item-details::-webkit-scrollbar,
        #emailList::-webkit-scrollbar,
        #emailContent::-webkit-scrollbar {
            width: 8px;
        }
        .panel-content::-webkit-scrollbar-track,
        .inventory-grid::-webkit-scrollbar-track,
        .item-details::-webkit-scrollbar-track,
        #emailList::-webkit-scrollbar-track,
        #emailContent::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
            border-radius: 4px;
        }
        .panel-content::-webkit-scrollbar-thumb,
        .inventory-grid::-webkit-scrollbar-thumb,
        .item-details::-webkit-scrollbar-thumb,
        #emailList::-webkit-scrollbar-thumb,
        #emailContent::-webkit-scrollbar-thumb {
            background-color: var(--scrollbar-thumb);
            border-radius: 4px;
            border: 2px solid var(--panel-bg); /* Match panel bg */
        }
         .panel-content::-webkit-scrollbar-thumb:hover,
         .inventory-grid::-webkit-scrollbar-thumb:hover,
         .item-details::-webkit-scrollbar-thumb:hover,
         #emailList::-webkit-scrollbar-thumb:hover,
         #emailContent::-webkit-scrollbar-thumb:hover {
              background-color: var(--pulse-color); /* Highlight on hover */
          }


        /* ===== Inventory Container Styling ===== */
        #inventoryContainer {
             /* Inherits base panel styles via JS adding .content-card class conceptually */
             /* Specific overrides: */
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.98);
            z-index: 150;
             width: 850px; /* Slightly wider */
             height: 600px; /* Match other panels */
             padding: 20px;
             background: var(--panel-bg);
             backdrop-filter: blur(12px);
             border: 2px solid var(--border-color);
             border-radius: 15px;
             box-shadow: 0 0 25px rgba(0, 204, 255, 0.25);
             display: flex; /* Changed from none to flex by JS */
             flex-direction: row;
             gap: 25px; /* More gap */
             opacity: 0;
             pointer-events: none;
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            /* Will also use panelActivate and panelPulse via active class */
        }

        #inventoryContainer.active {
            display: flex;
            opacity: 1;
            pointer-events: auto;
            animation: panelActivate 0.5s ease-out forwards, panelPulse 0.6s ease-out forwards;
         }
         /* Staggered content appearance inside active inventory */
        #inventoryContainer.active .inventory-grid,
        #inventoryContainer.active .item-info {
            opacity: 0;
             transform: translateY(10px);
             animation: panelContentFadeIn 0.5s ease-out forwards;
            animation-delay: 0.2s;
        }


        .inventory-grid {
            flex: 2; /* Grid takes more space */
            display: grid;
             grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); /* Slightly larger minimum */
             grid-auto-rows: 100px; /* Square slots */
            gap: 12px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow-y: auto;
            align-content: start;
             background: rgba(0,0,0, 0.1); /* Subtle grid background */
        }


        .inventory-slot {
            width: 100%;
            height: 100%;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.4); /* Darker slots */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: border-color 0.3s, background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            cursor: pointer;
            position: relative;
             box-shadow: 0 0 4px transparent; /* for transition */
             transform: scale(1);
        }

        .inventory-slot:hover {
            border-color: var(--hover-border-color);
            background-color: rgba(0, 204, 255, 0.1);
             transform: scale(1.03); /* Subtle pop */
             box-shadow: 0 0 8px var(--hover-border-color);
        }

        .inventory-slot.selected {
            border-color: var(--accent-color);
            background-color: rgba(0, 204, 255, 0.18);
            box-shadow: 0 0 12px var(--accent-color);
             transform: scale(1.02); /* Slightly scaled when selected */
        }

        .inventory-slot img {
             max-width: 80%; /* Adjust size */
             max-height: 80%;
            object-fit: contain;
             filter: drop-shadow(0 0 3px var(--accent-color)); /* Add slight glow to item image */
            opacity: 0.9; /* Placeholder slightly faded */
        }

        /* Item Info Panel Styling */
        .item-info {
            flex: 1;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.15);
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .item-details {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 20px;
             padding-right: 10px; /* scrollbar space */
        }

        .item-info h2 {
             /* Inherits .holo-text pulse */
            margin: 0 0 15px 0;
             font-size: 1.4em;
             color: var(--accent-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        .item-info p {
             font-size: 1em;
             line-height: 1.6;
             color: var(--text-color);
         }
         .item-info p.holo-text { animation: none; } /* No pulse on description */

        .item-actions {
            flex-shrink: 0;
            text-align: right;
             border-top: 1px solid var(--border-color); /* Separator line */
             padding-top: 15px;
        }

        .item-actions button {
             /* Inherits base nav button styles conceptually, override/add specific */
            background: transparent;
            border: 2px solid var(--accent-color);
             color: var(--accent-color);
            margin-left: 10px;
            padding: 8px 18px; /* Wider */
            cursor: pointer;
            text-transform: uppercase;
             transition: background 0.3s, color 0.3s, transform 0.2s, box-shadow 0.3s;
            font-family: 'Orbitron', sans-serif;
             border-radius: 4px;
             box-shadow: 0 0 5px transparent;
         }

        .item-actions button:hover:not(:disabled) {
            background: var(--active-bg);
             color: #FFF;
             box-shadow: 0 0 10px var(--accent-color);
             transform: translateY(-2px);
        }
         .item-actions button:active:not(:disabled) {
              transform: translateY(0px);
         }

        .item-actions button:disabled {
            border-color: rgba(0, 204, 255, 0.2);
             color: rgba(0, 204, 255, 0.3);
             cursor: not-allowed;
             background: transparent;
             box-shadow: none;
             transform: none;
        }

         /* ===== Email Section Styling ===== */
        #email .panel-content {
             display: flex;
             gap: 20px; /* Increased gap */
             padding: 15px 0 0 0;
             /* Ensure it animates in */
              opacity: 1; transform: translateY(0);
        }

        #emailList {
            flex: 1;
            list-style: none;
            padding: 0 20px 0 0; /* Increased right padding */
            margin: 0;
             border-right: 1px solid var(--border-color);
             overflow-y: auto;
            max-height: calc(65vh - 120px); /* Adjust based on panel height/padding */
        }

        #emailList li {
             padding: 12px 15px;
             border: 1px solid transparent;
            border-bottom: 1px solid rgba(0, 204, 255, 0.1); /* Lighter separator */
             margin-bottom: 6px;
             border-radius: 5px;
             cursor: pointer;
             transition: background-color 0.3s, border-color 0.3s, transform 0.2s ease-out;
             position: relative; /* For pseudo-elements */
             overflow: hidden; /* Contain potential hover effects */
        }

        #emailList li::before { /* Subtle left border indicator on hover/active */
             content: '';
             position: absolute;
             left: 0;
             top: 0;
             bottom: 0;
             width: 3px;
             background-color: var(--accent-color);
             transform: scaleY(0);
             transition: transform 0.3s ease;
             transform-origin: bottom;
         }

        #emailList li:hover {
            background-color: rgba(0, 204, 255, 0.08);
             border-color: transparent; /* Use pseudo-element for highlight */
             transform: translateX(5px);
         }
         #emailList li:hover::before {
              transform: scaleY(1);
              transform-origin: top;
          }

        #emailList li.active {
            background-color: var(--active-bg);
            border-color: transparent; /* Active uses pseudo-element */
             transform: translateX(0px); /* Don't shift active item */
         }
         #emailList li.active::before {
              transform: scaleY(1); /* Keep highlight visible */
              transform-origin: center;
          }


        #emailList li .sender {
            font-weight: bold;
            display: block;
            margin-bottom: 4px;
            color: var(--accent-color);
             font-size: 1.05em;
        }

        #emailList li .subject {
            font-size: 0.9em;
            color: var(--text-color);
         }
         #emailList li .sender.holo-text,
         #emailList li .subject.holo-text {
              animation: none; /* Remove pulse from list items */
          }

        #emailList li.read .subject { opacity: 0.6; } /* Dim read subject more */
        #emailList li.read .sender { opacity: 0.8; } /* Slightly dim read sender */

        #emailList li.unread::after { /* More distinct unread indicator */
             content: '';
             position: absolute;
             right: 15px;
             top: 50%;
             transform: translateY(-50%);
             width: 8px;
             height: 8px;
             background-color: var(--accent-color);
             border-radius: 50%;
             box-shadow: 0 0 6px var(--accent-color);
        }

        #emailContent {
            flex: 2;
            padding: 0 15px 0 10px;
             overflow-y: auto;
            max-height: calc(65vh - 120px);
         }

        #emailContent h2 { /* Subject in content view */
             /* Inherits .holo-text pulse */
            font-size: 1.5em;
             color: var(--accent-color);
             margin: 0 0 10px 0;
             padding-bottom: 8px;
             border-bottom: 1px solid var(--border-color);
        }

        #emailContent .email-meta {
             font-size: 0.9em;
             color: rgba(0, 204, 255, 0.7);
             margin-bottom: 25px;
             border-bottom: 1px dashed var(--border-color); /* Dashed separator */
             padding-bottom: 15px;
        }
         #emailContent .email-meta span { display: block; margin-bottom: 5px; }

        #emailContent .email-body {
            font-size: 1em; /* Larger body text */
            line-height: 1.7; /* More spacing */
             white-space: pre-wrap;
            color: var(--text-color); /* Ensure uses standard text color */
            padding-bottom: 20px;
         }

        #emailPlaceholder {
             text-align: center;
             padding: 60px 20px;
             font-size: 1.2em;
             color: rgba(0, 204, 255, 0.6);
             border: 1px dashed var(--border-color);
             border-radius: 8px;
             margin-top: 20px;
         }


        /* ===== Refined Ripple Effect ===== */
        .ripple {
            position: absolute;
            border-radius: 50%;
             /* Sharper center, faster fade */
            background: radial-gradient(circle, rgba(0, 204, 255, 0.25) 2%, rgba(0, 204, 255, 0.1) 20%, rgba(0, 204, 255, 0) 50%);
            transform: scale(0);
            pointer-events: none;
             /* Faster, smaller ripple */
             animation: ripple-effect 0.6s ease-out;
             z-index: 50;
        }

        @keyframes ripple-effect {
            from { transform: scale(0); opacity: 0.7; }
            to   { transform: scale(1.8); opacity: 0; } /* Scale slightly less */
        }

        /* ===== Other Section Placeholders ===== */
        #map .panel-content p,
        #codex .panel-content p,
        #scanner .panel-content p,
        #vitals .panel-content p {
            padding: 40px 20px;
            font-size: 1.2em;
            text-align: center;
             color: rgba(0, 204, 255, 0.7);
            line-height: 1.6;
        }

    </style>
</head>

<body>
    <!-- ===== Login Panel (Starts hidden, made visible by JS) ===== -->
    <div id="loginPanel">
        <h1 class="holo-text">Access Required</h1>
        <input type="text" id="username" placeholder="Designation" value="Vesta" /> <!-- Changed placeholder -->
        <input type="password" id="passcode" placeholder="Auth Key" value="password" /> <!-- Changed placeholder -->
        <button id="loginButton" class="holo-text">Initiate Link</button>
    </div>

    <!-- ===== Main Content (hidden until login) ===== -->
    <div id="mainContent">
        <!-- ===== Intro Message ===== -->
        <div id="introMessage" class="holo-text">Syncing Neural Interface... Welcome, Vesta.</div> <!-- Updated text -->

        <!-- ===== Navigation ===== -->
        <nav>
            <button data-section="inventory" class="holo-text">Inventory</button>
            <button data-section="map" class="holo-text">Nav-Grid</button> <!-- Renamed -->
            <button data-section="email" class="holo-text">Comms</button> <!-- Renamed -->
            <button data-section="codex" class="holo-text">Codex</button>
            <button data-section="scanner" class="holo-text">Scanner</button>
            <button data-section="vitals" class="holo-text">Biometrics</button> <!-- Renamed -->
        </nav>

        <!-- ===== Content Panels Wrapper ===== -->
        <div id="contentWrapper">
            <!-- MAP -->
            <div id="map" class="content-card">
                <h1 class="holo-text">Navigation Grid</h1>
                <div class="panel-content">
                    <p class="holo-text">Stellar Cartography Data Unavailable.<br>Awaiting Triangulation Lock.</p>
                </div>
            </div>
            <!-- EMAIL -->
            <div id="email" class="content-card">
                <h1 class="holo-text">Comms Terminal</h1>
                <div class="panel-content">
                    <ul id="emailList"></ul>
                    <div id="emailContent">
                        <div id="emailPlaceholder" class="holo-text">Select encrypted transmission...</div>
                        <h2 id="emailSubject" class="holo-text" style="display: none;"></h2>
                        <div id="emailMeta" style="display: none;">
                            <span id="emailSender" class="holo-text"></span>
                            <span id="emailDate" class="holo-text"></span>
                        </div>
                        <div id="emailBody" style="display: none;"></div>
                    </div>
                </div>
            </div>
             <!-- CODEX -->
            <div id="codex" class="content-card">
                <h1 class="holo-text">Data Codex</h1>
                <div class="panel-content">
                    <p class="holo-text">Codex database empty.<br>Connect to external Archive Node or utilize Scanner for entries.</p>
                </div>
            </div>
            <!-- SCANNER -->
            <div id="scanner" class="content-card">
                <h1 class="holo-text">Environmental Scanner</h1>
                <div class="panel-content">
                    <p class="holo-text">Scanner systems initializing...<br>Awaiting target lock or environmental input.</p>
                </div>
            </div>
             <!-- VITALS -->
            <div id="vitals" class="content-card">
                <h1 class="holo-text">Biometrics Interface</h1>
                <div class="panel-content">
                    <p class="holo-text">Neural link telemetry unstable.<br>Recalibrating biometric feed... Stand by.</p>
                </div>
            </div>
        </div>

        <!-- ===== New Inventory Container ===== -->
        <div id="inventoryContainer">
            <div class="inventory-grid">
                 <!-- Slots will be populated / updated by JS -->
                 <!-- Example with placeholder -->
                 <div class="inventory-slot" data-itemid="health_potion_1"><img src="placeholder.png" alt="Item"></div>
                 <div class="inventory-slot" data-itemid="keycard_alpha"><img src="placeholder.png" alt="Item"></div>
                 <!-- More empty slots -->
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
                 <div class="inventory-slot"><img src="placeholder.png" alt=""></div>
             </div>
            <div class="item-info">
                <div class="item-details">
                    <h2 class="holo-text" id="itemInfoTitle">Analysis Grid</h2>
                     <p class="holo-text" id="itemInfoDesc">Designate inventory object for detailed scan.</p>
                </div>
                <div class="item-actions">
                     <button id="itemUseButton" class="holo-text" disabled>Interface</button> <!-- Renamed -->
                     <button id="itemDropButton" class="holo-text" disabled>Jettison</button> <!-- Renamed -->
                 </div>
            </div>
        </div>
    </div>

    <script>
        // ----- Global DOM Elements -----
        const loginPanel = document.getElementById("loginPanel");
        const loginButton = document.getElementById("loginButton");
        const mainContent = document.getElementById("mainContent");
        const navButtons = document.querySelectorAll("nav button[data-section]");
        const contentCards = document.querySelectorAll("#contentWrapper .content-card");
        const inventoryContainer = document.getElementById("inventoryContainer");
         const inventoryGrid = document.querySelector(".inventory-grid"); // Get grid parent
         // Select slots dynamically later or ensure they exist initially
        let inventorySlots; // Will be populated after generating placeholders
         const itemInfoTitle = document.getElementById("itemInfoTitle");
        const itemInfoDesc = document.getElementById("itemInfoDesc");
        const itemUseButton = document.getElementById("itemUseButton");
        const itemDropButton = document.getElementById("itemDropButton");
        const emailList = document.getElementById("emailList");
        const emailContent = document.getElementById("emailContent");
        const emailPlaceholder = document.getElementById("emailPlaceholder");
        const emailSubjectEl = document.getElementById("emailSubject");
        const emailMetaEl = document.getElementById("emailMeta");
        const emailSenderEl = document.getElementById("emailSender");
        const emailDateEl = document.getElementById("emailDate");
        const emailBodyEl = document.getElementById("emailBody");
        let loadingStartTime;
         let selectedSlot = null; // Track selected inventory slot

        // ----- Dummy Data -----
        const inventoryItems = {
            "health_potion_1": { name: "Medi-Gel Injector", description: "Automated injector containing concentrated regenerative nano-solution. Effective on moderate tissue trauma. Auto-disposes after use.", usable: true, img: "medi_gel.svg" }, // Example using SVG
             "keycard_alpha": { name: "Access Credential: Sector Alpha", description: "Standard issue clearance chip embedded in polymer substrate. Grants level 1 access within designated Alpha Sector zones.", usable: false, img: "keycard.svg" },
             // Add more items
         };
        const emails = [{ id: 1, sender: "SysCore AI", subject: ":: Corridor Sync Established ::", date: "Cycle 34.1 REV 8", body: "Unit Designate: VST-VYN [Vesta]\n\nConfirmed connection to the Animus Corridor Simulation construct.\nBio-Neural Interface: STABLE\nCore Systems: NOMINAL [Confidence: 99.8%]\n\nData Codex access granted. Safety protocols engaged.\nReport detected spatio-temporal anomalies via secure comms channel immediately.\n\n++ SysCore Operational Branch ++", read: false }, { id: 2, sender: "Supply Chain AI [QM-7 Designation]", subject: "Equipment Dispatch Confirmation", date: "Cycle 34.0 REV 5", body: "Recipient: V. Vyntarion (VST-VYN)\n\nStandard Issue Loadout dispatched to designated access point:\n- Integrated Sidearm Unit [Check Scanner Interface]\n- Medi-Gel Injector x2\n- Access Credential: Sector Alpha x1\n\nInventory verification requested upon retrieval.\n\n-- QM-7 Logistical Matrix --", read: false }, { id: 3, sender: "Automated Hazard Monitor", subject: "ALERT: Unstable Energy Signature - Sector Gamma", date: "Cycle 33.9 REV 12", body: "PRIORITY ALERT ::\n\nUnidentified high-energy resonance pattern detected.\nOrigin Point: Sector Gamma / Grid Reference 7G-Delta-9.\nMagnitude exceeds standard variance thresholds by 4 sigmas.\nPhenomenon signature inconsistent with known subspace events.\n\nACTION: Avoid designated zone. Hazard Containment Team en route.\n\nRECORD ID: AE-8873-G-HIGH", read: true }, { id: 4, sender: "Dr. Aris Thorne [Secured Channel]", subject: "Query Follow-up // Urgent Data Request", date: "Cycle 33.8 REV 2", body: "Vesta,\n\nThe chroniton field flux patterns you logged... they defy current models. My quantum simulations are producing paradoxical outcomes, pointing towards an external 'observer' effect or a causal loop. Cannot confirm without hard data.\n\nYour scanner array is key. Focus on *any* anomalous energy readings, particularly those exhibiting temporal shear or non-linear decay signatures. Log everything and transmit directly via this secured channel ONLY. Designate Priority Alpha.\n\nMaintain vigilance. This research is critical.\n\n// Aris //", read: false }, ];

         // ----- Initial Setup -----
         document.addEventListener('DOMContentLoaded', () => {
             // Trigger login panel fade-in after a short delay
             setTimeout(() => {
                 loginPanel.classList.add('visible');
             }, 300); // Small delay for boot effect

            setupInventoryPlaceholders();
            addInventoryEventListeners(); // Add listeners after placeholders are set up
         });


         // ----- Login Handling -----
         loginButton.addEventListener("click", function() {
             const username = document.getElementById("username").value.trim();
             const passcode = document.getElementById("passcode").value.trim();
             if (username && passcode) {
                 loginPanel.classList.add("hidden");
                 loginPanel.addEventListener('transitionend', () => {
                     loginPanel.style.display = "none";
                     mainContent.classList.add("visible"); // Triggers its animation
                    loadingStartTime = Date.now() * 0.001;
                     if (typeof THREE !== 'undefined') { // Check if Three.js loaded
                         console.log("Three.js loaded, initializing scene...");
                         initThreeJS();
                         animateThreeJS();
                     } else {
                         console.error("Three.js failed to load.");
                         // Optionally show an error message to the user
                         alert("Error: Background visualization library failed to load.")
                     }
                }, { once: true });
            } else {
                alert("Access denied. Valid credentials required.");
                // Optional: Add visual feedback like shaking the login panel
            }
         });

        // ----- Navigation & Panel Switching Logic -----
        navButtons.forEach(btn => {
            btn.addEventListener("click", () => {
                const section = btn.getAttribute("data-section");
                 let currentlyActive = document.querySelector('.content-card.active, #inventoryContainer.active');
                let buttonActive = document.querySelector('nav button.active');

                 // If clicking the already active button, close the panel
                 if (buttonActive === btn && currentlyActive) {
                     currentlyActive.classList.remove('active');
                     btn.classList.remove('active');
                      resetItemInfo(); // Reset inventory info if closing
                      resetEmailContent(); // Reset email if closing
                      selectedSlot?.classList.remove('selected'); // Deselect inventory item
                     selectedSlot = null;
                      return; // Stop further processing
                 }


                 // Deactivate all buttons and panels first
                 navButtons.forEach(b => b.classList.remove("active"));
                 contentCards.forEach(card => card.classList.remove("active"));
                inventoryContainer.classList.remove("active");

                // Activate the clicked button
                btn.classList.add("active");

                 // Reset states before showing new panel
                resetItemInfo(); // Reset inventory info
                resetEmailContent(); // Reset email info

                // Show the correct panel
                if (section === "inventory") {
                    inventoryContainer.classList.add("active");
                 } else {
                     const targetCard = document.getElementById(section);
                     if (targetCard) {
                         targetCard.classList.add("active");
                         if (section === "email") {
                             populateEmailList();
                             resetEmailContent(); // Ensure placeholder shows first
                        }
                    }
                }
            });
         });

         // ----- Inventory Interaction Logic -----
         function setupInventoryPlaceholders() {
             const slots = inventoryGrid.querySelectorAll(".inventory-slot");
             slots.forEach(slot => {
                 const img = slot.querySelector('img');
                 const itemId = slot.getAttribute('data-itemid');
                 let itemImageSrc = 'placeholder'; // Default to placeholder logic

                if (itemId && inventoryItems[itemId] && inventoryItems[itemId].img) {
                     // Use defined image if available (could be SVG name or path)
                     // Assuming SVG for now - replace logic if using png paths
                    // Example: If inventoryItems[itemId].img is "keycard.svg", set src directly
                    // img.src = inventoryItems[itemId].img;
                     // For demo, we still use placeholders but could load real assets here
                     itemImageSrc = inventoryItems[itemId].img; // Use actual defined source
                     img.alt = inventoryItems[itemId].name;
                 }

                 // Only generate SVG placeholder if no specific item image is intended OR the src is placeholder.png/empty
                 // Modify this condition if you load actual image paths above
                if (!img || img.src.includes('placeholder.png') || img.src === '') {
                     // Generate placeholder only if no real image set/found
                    const placeholderSvg = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 100 100">
                             <rect width="100" height="100" fill="rgba(0,204,255,0.02)"/> // Very faint bg
                            <circle cx="50" cy="50" r="35" fill="none" stroke="rgba(0,204,255,0.2)" stroke-width="3" stroke-dasharray="10 5"/> // Dashed circle
                             <line x1="30" y1="50" x2="70" y2="50" stroke="rgba(0,204,255,0.15)" stroke-width="3"/> // Center line H
                             <line x1="50" y1="30" x2="50" y2="70" stroke="rgba(0,204,255,0.15)" stroke-width="3"/> // Center line V
                         </svg>`;
                    if (img) {
                         img.src = `data:image/svg+xml;base64,${btoa(placeholderSvg)}`;
                        img.style.opacity = "0.4"; // Make placeholder less prominent
                        img.alt = "Empty Slot";
                    }
                 } else if (img) {
                    // If using real images, ensure styling is appropriate
                    img.style.opacity = "1";
                 }
            });
            // Re-select slots after potential changes
            inventorySlots = inventoryGrid.querySelectorAll(".inventory-slot");
        }

        function addInventoryEventListeners() {
            if (!inventorySlots) {
                console.warn("Inventory slots not ready for event listeners.");
                return; // Guard if slots aren't ready
             }

             inventorySlots.forEach(slot => {
                 slot.addEventListener("click", () => {
                     handleInventorySlotClick(slot);
                 });
             });

             // Item action buttons
            itemUseButton.addEventListener("click", handleItemUse);
            itemDropButton.addEventListener("click", handleItemDrop);
         }

         function handleInventorySlotClick(slot) {
            const itemId = slot.getAttribute("data-itemid");

             // Deselect previous slot
            if (selectedSlot) {
                selectedSlot.classList.remove("selected");
             }
             // Reset info panel first
            resetItemInfo(false); // Don't set placeholder text yet

             if (itemId && inventoryItems[itemId]) {
                const item = inventoryItems[itemId];
                 itemInfoTitle.textContent = item.name;
                itemInfoDesc.textContent = item.description;
                itemUseButton.disabled = !item.usable;
                itemDropButton.disabled = false;
                slot.classList.add("selected");
                selectedSlot = slot;
             } else {
                 // Empty slot selected
                 itemInfoTitle.textContent = "Empty Slot Designation"; // Updated text
                 itemInfoDesc.textContent = "No object detected in this grid coordinate."; // Updated text
                 itemUseButton.disabled = true;
                 itemDropButton.disabled = true;
                 slot.classList.add("selected"); // Still visually select the empty slot
                 selectedSlot = slot;
             }
         }


         function handleItemUse() {
             if (selectedSlot && !itemUseButton.disabled) {
                 const itemId = selectedSlot.getAttribute("data-itemid");
                 if (itemId && inventoryItems[itemId]) {
                    console.log(`Attempting to use: ${inventoryItems[itemId].name}`); // Log action
                    alert(`Interfaced with ${inventoryItems[itemId].name}.`);
                    // Future: Add real use logic (e.g., consume, apply effect, remove item)
                    // If consumable: removeItemFromSlot(selectedSlot);
                }
            }
         }

         function handleItemDrop() {
             if (selectedSlot && !itemDropButton.disabled) {
                const itemId = selectedSlot.getAttribute("data-itemid");
                 const itemName = itemId ? inventoryItems[itemId].name : "the empty slot data";
                 if (confirm(`Confirm jettison command for: ${itemName}? This action is irreversible.`)) {
                     console.log(`Attempting to drop: ${itemName}`); // Log action
                     alert(`Jettisoned ${itemName}.`);
                     // Future: Add real drop logic
                    if (itemId) {
                         removeItemFromSlot(selectedSlot);
                     } else {
                          // Clear selection even if it was an empty slot clicked before dropping nothing
                         selectedSlot.classList.remove('selected');
                         resetItemInfo(); // Show default placeholder
                         selectedSlot = null;
                     }
                }
            }
         }

        function removeItemFromSlot(slot) {
            slot.removeAttribute("data-itemid");
            const img = slot.querySelector('img');
            if (img) { // Replace image with placeholder SVG
                const placeholderSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 100 100"><rect width="100" height="100" fill="rgba(0,204,255,0.02)"/><circle cx="50" cy="50" r="35" fill="none" stroke="rgba(0,204,255,0.2)" stroke-width="3" stroke-dasharray="10 5"/><line x1="30" y1="50" x2="70" y2="50" stroke="rgba(0,204,255,0.15)" stroke-width="3"/><line x1="50" y1="30" x2="50" y2="70" stroke="rgba(0,204,255,0.15)" stroke-width="3"/></svg>`;
                img.src = `data:image/svg+xml;base64,${btoa(placeholderSvg)}`;
                img.style.opacity = "0.4";
                 img.alt = "Empty Slot";
            }
            // Reset info panel and selection state
            slot.classList.remove('selected');
            resetItemInfo(); // Reset to placeholder text
            selectedSlot = null;
         }


        function resetItemInfo(showPlaceholderText = true) {
            if(showPlaceholderText) {
                 itemInfoTitle.textContent = "Analysis Grid";
                 itemInfoDesc.textContent = "Designate inventory object for detailed scan.";
            }
             itemUseButton.disabled = true;
             itemDropButton.disabled = true;
             // Do not deselect the visual slot here, only reset the text/buttons
         }


        // ----- Email Section Logic -----
        function populateEmailList() {
            emailList.innerHTML = '';
            emails.sort((a, b) => b.id - a.id);
             emails.forEach(email => {
                const li = document.createElement('li');
                li.setAttribute('data-email-id', email.id);
                li.classList.toggle('read', email.read);
                li.classList.toggle('unread', !email.read);

                const senderSpan = document.createElement('span');
                 senderSpan.className = 'sender holo-text'; // Apply class
                senderSpan.textContent = email.sender;

                 const subjectSpan = document.createElement('span');
                 subjectSpan.className = 'subject holo-text'; // Apply class
                subjectSpan.textContent = email.subject;

                 li.appendChild(senderSpan);
                 li.appendChild(subjectSpan);

                 li.addEventListener('click', () => {
                    // Deselect other emails visually first
                    emailList.querySelectorAll('li.active').forEach(item => item.classList.remove('active'));
                     // Select clicked email
                    li.classList.add('active');
                    displayEmailContent(email.id);
                 });
                 emailList.appendChild(li);
             });
         }

         function displayEmailContent(emailId) {
             const email = emails.find(e => e.id === emailId);
             if (email) {
                 emailPlaceholder.style.display = 'none';
                 emailSubjectEl.style.display = 'block';
                 emailMetaEl.style.display = 'block';
                 emailBodyEl.style.display = 'block';

                 emailSubjectEl.textContent = email.subject;
                 emailSenderEl.textContent = `Origin Signal: ${email.sender}`; // Updated label
                 emailDateEl.textContent = `Timestamp: ${email.date}`; // Updated label
                 emailBodyEl.textContent = email.body;

                if (!email.read) {
                     email.read = true;
                     const listItem = emailList.querySelector(`li[data-email-id="${emailId}"]`);
                     if (listItem) {
                         listItem.classList.remove('unread');
                         listItem.classList.add('read');
                     }
                 }
                emailContent.scrollTop = 0; // Scroll to top of message
            }
         }

         function resetEmailContent() {
             emailPlaceholder.style.display = 'block';
             emailSubjectEl.style.display = 'none';
             emailMetaEl.style.display = 'none';
             emailBodyEl.style.display = 'none';
            // Remove active class from list items if any
            emailList.querySelectorAll('li.active').forEach(item => item.classList.remove('active'));
         }

        // ----- Ripple Effect on Click -----
        document.addEventListener("click", function (e) {
            if (e.target.closest('button, .inventory-slot, #emailList li, input')) { // Prevent on interactive elements
                return;
            }
             // Also check if the click is inside any active panel to avoid background ripples when interacting with panels
             if (e.target.closest('.content-card.active, #inventoryContainer.active')) {
                 return;
             }

             const ripple = document.createElement("div");
            ripple.classList.add("ripple");
            const size = Math.min(window.innerWidth, window.innerHeight) * 0.5; // Slightly smaller ripple base
             ripple.style.width = ripple.style.height = size + "px";
             ripple.style.left = e.clientX - size / 2 + "px";
             ripple.style.top = e.clientY - size / 2 + "px";
            document.body.appendChild(ripple);
            ripple.addEventListener("animationend", () => {
                ripple.remove();
            });
         });

         // ----- Three.js Scene & Animation Code -----
        let scene, camera, renderer;
        let corridor;
        let ceilingMesh, leftWallMesh, rightWallMesh;
        let glyphs = [];
        let globalGlyphFade = 0;
        const CORRIDOR_SIZE = 2500;
        let mouse = new THREE.Vector2(0, 0);
        let targetRotationX = 0, targetRotationY = 0;
        let floorTexture, ceilingTexture, leftWallTexture, rightWallTexture;
        const SCROLL_SPEED_FLOOR = 0.0007;
        const SCROLL_SPEED_CODE = 0.0005;
        let plexusGroup;
        const repulsionDistance = 130; // Slightly increased interaction distance
        const repulsionForce = 1.8;   // Slightly stronger push
        const friction = 0.92;        // Slightly less friction (moves longer)

        // Renamed init/animate functions
         function initThreeJS() {
             try { // Add a try...catch block for robust initialization
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0d1b2a);
                scene.fog = new THREE.FogExp2(0x0d1b2a, 0.0007); // Keep fog

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
                camera.position.set(0, 0, 1800); // Initial camera position
                camera.lookAt(0, 0, 0);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                 // Ensure canvas is styled correctly by CSS (position: fixed, z-index: -1)
                 document.body.insertBefore(renderer.domElement, document.body.firstChild); // Add canvas to body start

                // --- Lights ---
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.45); // Slightly brighter ambient
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xADD8E6, 0.35); // Lighter blue directional
                directionalLight.position.set(1, 1.5, 1).normalize();
                scene.add(directionalLight);

                // --- Corridor ---
                corridor = new THREE.Group();
                scene.add(corridor);

                // --- Textures ---
                leftWallTexture = createCodeTexture(512);
                leftWallTexture.wrapS = leftWallTexture.wrapT = THREE.RepeatWrapping;
                leftWallTexture.repeat.set(4, 5);
                rightWallTexture = createCodeTexture(512); // Could create variation if needed
                rightWallTexture.wrapS = rightWallTexture.wrapT = THREE.RepeatWrapping;
                rightWallTexture.repeat.set(4, 5);
                floorTexture = createCodeTexture(512); // Floor uses same code texture
                floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
                floorTexture.repeat.set(4, 10);
                ceilingTexture = createCircuitTexture(512);
                ceilingTexture.wrapS = ceilingTexture.wrapT = THREE.RepeatWrapping;
                ceilingTexture.repeat.set(3, 3); // Slightly denser ceiling circuits

                // --- Materials ---
                const wallMat = new THREE.MeshPhongMaterial({ // Shared material for walls
                    map: leftWallTexture, // Use left texture for both initially (can be different)
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.65, // Slightly less opaque walls
                    specular: 0x111111, // Dull specular
                    shininess: 10
                });
                const floorMat = new THREE.MeshPhongMaterial({ map: floorTexture, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
                const ceilingMat = new THREE.MeshPhongMaterial({ map: ceilingTexture, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });

                // --- Geometry ---
                const planeGeo = new THREE.PlaneGeometry(CORRIDOR_SIZE, CORRIDOR_SIZE);

                // --- Meshes ---
                ceilingMesh = new THREE.Mesh(planeGeo, ceilingMat);
                ceilingMesh.rotation.x = Math.PI / 2;
                ceilingMesh.position.y = CORRIDOR_SIZE / 2;
                corridor.add(ceilingMesh);

                leftWallMesh = new THREE.Mesh(planeGeo, wallMat.clone()); // Clone material
                leftWallMesh.material.map = leftWallTexture; // Assign correct texture map
                leftWallMesh.rotation.y = Math.PI / 2;
                leftWallMesh.position.x = -CORRIDOR_SIZE / 2 - 500; // Start off-screen
                corridor.add(leftWallMesh);

                rightWallMesh = new THREE.Mesh(planeGeo, wallMat.clone()); // Clone material
                rightWallMesh.material.map = rightWallTexture; // Assign correct texture map
                rightWallMesh.rotation.y = -Math.PI / 2;
                rightWallMesh.position.x = CORRIDOR_SIZE / 2 + 500; // Start off-screen
                corridor.add(rightWallMesh);

                // --- Plexus ---
                 plexusGroup = createScrollingPlexus(); // Corrected function called here
                 if (!plexusGroup) { // Check if plexus creation failed
                     console.error("Plexus creation failed. Skipping add.");
                     // Handle error appropriately - maybe show simpler background?
                 } else {
                    plexusGroup.rotation.x = -0.2;
                     plexusGroup.scale.set(0, 0, 0); // Start scaled down
                     plexusGroup.renderOrder = 1; // Ensure rendered correctly relative to sprites
                    scene.add(plexusGroup);
                }

                 // --- Glyphs ---
                const glyphLetters = ["⍀", "⍁", "⍂", "⍃", "⍄", "⍅", "⍆", "⍇", "⍈", "⍉", "⌿", "⍀", "⎍", "⏚", "⌘", "⌥", "⌶"]; // More abstract/tech symbols
                 glyphs = []; // Clear glyphs array before creating new ones
                for (let i = 0; i < 40; i++) { // Increase glyph count slightly
                     const letter = glyphLetters[Math.floor(Math.random() * glyphLetters.length)];
                     const sprite = createGlyphSprite(letter);
                     // Initialize position (more spread out)
                     const radius = 800 + Math.random() * 1000;
                     const angle = Math.random() * Math.PI * 2;
                     const height = Math.random() * 1950 - 700;
                     const depth = -Math.random() * (CORRIDOR_SIZE * 0.8); // More depth range
                     sprite.position.set(Math.cos(angle) * radius, height, depth);

                    sprite.userData = {
                         basePosition: sprite.position.clone(),
                         oscillationSpeed: Math.random() * 0.4 + 0.3, // Slower oscillation
                         velocity: new THREE.Vector3(0, 0, 0),
                         lifetime: Math.random() * 15, // Start at random lifetime phase
                         maxLifetime: 15 + Math.random() * 10 // Longer life variance
                     };
                     glyphs.push(sprite);
                     scene.add(sprite);
                 }

                 // --- Event Listeners ---
                 window.addEventListener("resize", onWindowResize, false);
                 document.addEventListener("mousemove", onDocumentMouseMove, false);

                 console.log("Three.js scene initialized successfully.");

             } catch (error) {
                 console.error("Error during Three.js initialization:", error);
                 alert("Failed to initialize 3D background. Please check console for errors.");
                 // Disable further animation attempts if init fails
                 renderer = null; // Flag that initialization failed
             }
         }


         function animateThreeJS() {
            // Stop animation if renderer failed to initialize
             if (!renderer) return;

             requestAnimationFrame(animateThreeJS);
            const time = Date.now() * 0.001;
             // Ensure loadingStartTime is set before calculating elapsedTime
             if (typeof loadingStartTime === 'undefined') return;
             const elapsedTime = time - loadingStartTime;
            if (isNaN(elapsedTime)) return; // Additional safety check


            // --- Animations Based on Elapsed Time Since Login ---

            // Global glyph fade-in (matches main content appearance)
             const glyphStartDelay = 0.5; // Start fading slightly earlier
            const glyphFadeDuration = 2.0; // Slower fade in
             // Update glyph fade calculation (check if glyphs array exists)
             if(glyphs && glyphs.length > 0) {
                 globalGlyphFade = (elapsedTime < glyphStartDelay) ? 0 : Math.min((elapsedTime - glyphStartDelay) / glyphFadeDuration, 0.7); // Max opacity lower
             } else {
                globalGlyphFade = 0;
             }

             // Corridor rotation based on mouse
            if (corridor) { // Check if corridor exists
                 corridor.rotation.y += (targetRotationY - corridor.rotation.y) * 0.04; // Smoother follow
                 corridor.rotation.x += (targetRotationX - corridor.rotation.x) * 0.04;
            }

             // Animate walls sliding in (sync with mainContent fade)
             // Check if wall meshes exist before animating them
            if (leftWallMesh && rightWallMesh) {
                 const wallAnimDuration = 2.5; // Slightly longer slide
                 const wallStartDelay = 0.4; // Start slightly earlier to overlap content fade
                 if (elapsedTime >= wallStartDelay && elapsedTime < wallStartDelay + wallAnimDuration) {
                    const progress = (elapsedTime - wallStartDelay) / wallAnimDuration;
                    const easeProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI); // Ease-in-out remains good
                    leftWallMesh.position.x = THREE.MathUtils.lerp(-CORRIDOR_SIZE / 2 - 500, -CORRIDOR_SIZE / 2, easeProgress);
                    rightWallMesh.position.x = THREE.MathUtils.lerp(CORRIDOR_SIZE / 2 + 500, CORRIDOR_SIZE / 2, easeProgress);
                 } else if (elapsedTime >= wallStartDelay + wallAnimDuration) {
                     // Ensure final position is exact after animation
                     leftWallMesh.position.x = -CORRIDOR_SIZE / 2;
                     rightWallMesh.position.x = CORRIDOR_SIZE / 2;
                 }
            }

            // Texture scrolling (Check if textures exist)
             if(floorTexture) floorTexture.offset.y += SCROLL_SPEED_FLOOR;
             if(leftWallTexture) leftWallTexture.offset.y += SCROLL_SPEED_CODE;
             if(rightWallTexture) rightWallTexture.offset.y += SCROLL_SPEED_CODE;
             if(ceilingTexture) ceilingTexture.offset.y -= SCROLL_SPEED_FLOOR * 0.5;


             // Animate plexus appearance (sync with nav appearance)
            if(plexusGroup) { // Check if plexusGroup exists
                 const plexusStartDelay = 3.0; // Start when nav starts animating
                 const plexusAnimDuration = 1.8; // Slower scale up
                 if (elapsedTime < plexusStartDelay) {
                    plexusGroup.scale.set(0, 0, 0);
                 } else if (elapsedTime < plexusStartDelay + plexusAnimDuration) {
                     const s = (elapsedTime - plexusStartDelay) / plexusAnimDuration;
                     const easeS = 1 - Math.pow(1 - s, 3); // Ease-out cubic (faster start, slow end)
                     plexusGroup.scale.set(easeS, easeS, easeS);
                 } else {
                     plexusGroup.scale.set(1, 1, 1); // Ensure final scale is 1
                 }
            }


            // Update dynamic elements
            // Check if plexus exists and is scaled up before updating
             if (plexusGroup && plexusGroup.children.length > 0 && plexusGroup.scale.x > 0.01) {
                 updateScrollingPlexus(plexusGroup.children[0], time);
             }
             // Check if glyphs array exists and has items before updating
             if (glyphs && glyphs.length > 0) {
                 updateGlyphs(time);
             }

            // Render scene
             if (scene && camera) { // Check scene and camera exist
                 renderer.render(scene, camera);
             }
         }

         // --- Helper functions for Three.js ---

        // ** THIS IS THE CORRECTED FUNCTION **
         function createScrollingPlexus() {
             const group = new THREE.Group();
             const nodeCount = 180, threshold = 450, scrollSpeed = 0.8;
             const regionMinX = -1200, regionMaxX = 1200, regionMinY = -1150, regionMaxY = -650;
             const regionMinZ = -3200, regionMaxZ = 1300;
             const regionWidth = regionMaxX - regionMinX, regionDepth = regionMaxZ - regionMinZ;

             const nodes = [];
             for (let i = 0; i < nodeCount; i++) {
                 nodes.push(
                     new THREE.Vector3(
                         THREE.MathUtils.randFloat(regionMinX, regionMaxX),
                         THREE.MathUtils.randFloat(regionMinY, regionMaxY),
                         THREE.MathUtils.randFloat(regionMinZ, regionMaxZ)
                     ) // CORRECTED LINE - Removed ". PADDING_TOP"
                 );
             }

             const geometry = new THREE.BufferGeometry();
             const material = new THREE.LineBasicMaterial({
                 color: 0x00aaff,
                 transparent: true,
                 opacity: 0.45,
                 depthWrite: false
             });

             const plexusLines = new THREE.LineSegments(geometry, material);
             plexusLines.frustumCulled = false;
             plexusLines.renderOrder = 1;
             plexusLines.userData = { nodes, regionMinZ, regionMaxZ, regionDepth, threshold, scrollSpeed };
             group.add(plexusLines);
             return group;
         }


         function updateScrollingPlexus(plexusLines, time) {
            // Add check if plexusLines geometry exists
            if (!plexusLines || !plexusLines.geometry) return;

             const geometry = plexusLines.geometry;
             // Add check if userData exists
             if (!plexusLines.userData) return;
            const { nodes, regionMinZ, regionMaxZ, regionDepth, threshold, scrollSpeed } = plexusLines.userData;
             // Check if nodes array exists
             if (!nodes) return;

            const positions = [];

             // Update node positions (simpler vertical drift)
             for (const n of nodes) {
                 // Basic check if n is a valid Vector3 object
                 if (!n || typeof n.z === 'undefined' || typeof n.y === 'undefined') continue;

                 // Simple scroll based on time delta (better than fixed frame rate assumption)
                 n.z += scrollSpeed; // Simple constant speed, adjust multiplier if needed
                 n.y += (Math.random() - 0.5) * 0.5; // Subtle vertical jitter
                if (n.z > regionMaxZ + 100) n.z = regionMinZ - THREE.MathUtils.randFloat(0, 100);
                 // Keep Y within bounds somewhat
                 n.y = THREE.MathUtils.clamp(n.y, -1150, -650);
            }

             // Calculate line segments
             if(nodes.length > 1) { // Need at least 2 nodes to make a line
                 for (let i = 0; i < nodes.length; i++) {
                    if(!nodes[i]) continue; // Skip if node is undefined somehow
                     for (let j = i + 1; j < nodes.length; j++) {
                         if(!nodes[j]) continue; // Skip if node is undefined
                         try { // Add try-catch around distance calculation
                             const distSq = nodes[i].distanceToSquared(nodes[j]); // Use squared distance
                            if (distSq < threshold * threshold) { // Compare with squared threshold
                                positions.push(nodes[i].x, nodes[i].y, nodes[i].z);
                                 positions.push(nodes[j].x, nodes[j].y, nodes[j].z);
                            }
                         } catch(e) {
                            console.warn("Error calculating distance in plexus:", e, nodes[i], nodes[j]);
                         }
                    }
                 }
             }

            // Update geometry attributes only if positions array has data
            if (positions.length > 0 && geometry.setAttribute) {
                 geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.attributes.position.needsUpdate = true;
             } else if (geometry.getAttribute('position') && geometry.getAttribute('position').count > 0) {
                 // If no lines should be drawn, clear the existing buffer
                geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
                geometry.attributes.position.needsUpdate = true;
             }

             // No need to compute bounding sphere frequently unless scale changes dramatically
             // geometry.computeBoundingSphere();
         }


        function createCodeTexture(size) {
            const canvas = document.createElement("canvas");
             canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext("2d");
             if (!ctx) return null; // Handle canvas context failure
            ctx.fillStyle = "#08141E"; // Darker base for code texture
            ctx.fillRect(0, 0, size, size);
             ctx.fillStyle = "rgba(0, 180, 220, 0.5)"; // Adjusted alpha and color
            ctx.font = "11px monospace"; // Slightly larger font
             // More technical/symbolic chars
            const codeChars = ["0","1","░","▒","▓","<",">","/","{","}","[","]","λ","μ","Σ","Δ","∫","∬","∂","∇","±","∈","∩","∪","∀","∃","∵","∴", ":", ";"];
            const columns = 35, rows = 45;
            const colWidth = size / columns, rowHeight = size / rows;
            for (let c = 0; c < columns; c++) {
                for (let r = 0; r < rows; r++) {
                     if (Math.random() > 0.2) { // Skip some cells for sparseness
                        const char = codeChars[Math.floor(Math.random() * codeChars.length)];
                         ctx.fillText(char, c * colWidth + Math.random()*5, r * rowHeight + rowHeight * 0.8 + Math.random()*5); // Add slight jitter
                     }
                 }
             }
             return new THREE.CanvasTexture(canvas);
         }

         function createCircuitTexture(size) {
             const canvas = document.createElement("canvas");
             canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext("2d");
             if (!ctx) return null; // Handle canvas context failure
            ctx.fillStyle = "#0A1825"; // Slightly different dark bg for ceiling
             ctx.fillRect(0, 0, size, size);
            const circuitColor = "rgba(0, 204, 255, 0.25)"; // More faded color
            // Straight Lines (Traces)
            ctx.lineWidth = 1.5;
             for (let i = 0; i < 35; i++) { // More traces
                ctx.strokeStyle = circuitColor;
                 ctx.beginPath();
                let x1 = Math.random() * size, y1 = Math.random() * size;
                 // Prefer horizontal/vertical traces
                let x2, y2;
                 if(Math.random() < 0.7) { // Higher chance of axis-aligned
                     if(Math.random() < 0.5) { x2 = Math.random() * size; y2 = y1; } // Horizontal
                    else { x1 = Math.random() * size; x2 = x1; y2 = Math.random() * size; } // Vertical
                 } else { // Diagonal traces less common
                    x2 = x1 + (Math.random() - 0.5) * 100; y2 = y1 + (Math.random() - 0.5) * 100;
                 }
                ctx.moveTo(x1, y1);
                 ctx.lineTo(x2, y2);
                ctx.stroke();
             }
             // Small Circles (Pads/Vias)
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = circuitColor; // Use fill for pads
                 ctx.beginPath();
                 let cx = Math.random() * size, cy = Math.random() * size;
                 let r = Math.random() * 1.5 + 0.5; // Smaller pads
                 ctx.arc(cx, cy, r, 0, Math.PI * 2);
                 ctx.fill();
             }
             return new THREE.CanvasTexture(canvas);
         }

        function createGlyphSprite(letter) {
            const canvas = document.createElement("canvas");
             canvas.width = 128; canvas.height = 128;
             const ctx = canvas.getContext("2d");
             if (!ctx) return null; // Handle context failure

            ctx.clearRect(0, 0, 128, 128);

             // Add a subtle outer glow effect on the canvas itself
            ctx.shadowColor = "rgba(0, 204, 255, 0.8)";
            ctx.shadowBlur = 15;

             ctx.font = "90px 'Orbitron', sans-serif"; // Use Orbitron if possible, fallback needed
             ctx.fillStyle = "rgba(200, 255, 255, 1.0)"; // Slightly desaturated white/blue
             ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(letter, 64, 64);

            // Clear shadow for next draws if any
            ctx.shadowColor = "transparent";
             ctx.shadowBlur = 0;

             const texture = new THREE.CanvasTexture(canvas);
             const material = new THREE.SpriteMaterial({
                 map: texture,
                 transparent: true,
                 alphaTest: 0.05, // Lower alphaTest for softer edges
                 sizeAttenuation: true,
                 depthWrite: false // Prevent depth conflicts
             });
            const sprite = new THREE.Sprite(material);
             sprite.renderOrder = 2; // Render above plexus
            // Initial scale is handled by updateGlyphs based on distance
             return sprite;
         }


         function updateGlyphs(time) {
             // Add checks for camera existence
            if (!camera || !glyphs) return;

             const cameraPos = camera.position;

             glyphs.forEach(sprite => {
                // Check if sprite and its properties are valid
                if (!sprite || !sprite.userData || !sprite.material || !sprite.position || !sprite.scale) return;

                sprite.userData.lifetime = (sprite.userData.lifetime ?? 0) + 1 / 60; // Approximate delta time, with nullish coalescing for safety
                 const lifeRatio = sprite.userData.lifetime / (sprite.userData.maxLifetime || 1); // Avoid division by zero/undefined
                 const fade = Math.sin(Math.min(lifeRatio, 1.0) * Math.PI); // Ensure lifeRatio doesn't exceed 1 for sin curve
                sprite.material.opacity = Math.max(fade, 0) * (globalGlyphFade || 0); // Use global fade and sin fade

                 // Respawn logic
                 if (lifeRatio >= 1.0) {
                    sprite.userData.lifetime = 0; // Reset lifetime
                    // Respawn (Use the random function or a specific wall function)
                    // Example: Simple random respawn further away
                     const radius = 1000 + Math.random() * 800;
                     const angle = Math.random() * Math.PI * 2;
                     const height = Math.random() * 1800 - 800;
                     const depth = - (CORRIDOR_SIZE * 0.5) - Math.random() * (CORRIDOR_SIZE * 0.5);
                     sprite.position.set(Math.cos(angle) * radius, height, depth);
                    if(sprite.userData.basePosition) sprite.userData.basePosition.copy(sprite.position);
                     if(sprite.userData.velocity) sprite.userData.velocity.set(0, 0, 0);
                    // Opacity will naturally fade back in via the sin curve and global fade
                }

                // Base Oscillation (Subtler)
                 if (sprite.userData.basePosition) {
                     const t = time * (sprite.userData.oscillationSpeed || 0.5);
                     const ox = Math.sin(t * 0.8) * 10; // Less X movement
                     const oy = Math.cos(t * 1.2) * 8;  // Less Y movement
                    sprite.position.x = sprite.userData.basePosition.x + ox;
                    sprite.position.y = sprite.userData.basePosition.y + oy;
                 }

                // Mouse Repulsion
                 try { // Add try-catch for safety during projection/calculations
                    // Project sprite world position to screen space (normalized device coords)
                    const spriteScreenPos = sprite.position.clone().project(camera);

                    // Convert normalized device coords (-1 to 1) to screen coords (0 to width/height)
                    const glyphScreenX = (spriteScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                    const glyphScreenY = (-spriteScreenPos.y * 0.5 + 0.5) * window.innerHeight;
                    const mouseScreenX = (mouse.x * 0.5 + 0.5) * window.innerWidth; // Mouse coords are already -1 to 1
                    const mouseScreenY = (-mouse.y * 0.5 + 0.5) * window.innerHeight;

                    const dist = Math.hypot(glyphScreenX - mouseScreenX, glyphScreenY - mouseScreenY);
                    let pushX = 0, pushY = 0;

                    if (dist < repulsionDistance && dist > 1) { // Add minimum distance to avoid division by zero/extreme force
                        const dx = glyphScreenX - mouseScreenX;
                        const dy = glyphScreenY - mouseScreenY;
                        const angle = Math.atan2(dy, dx);
                         // Force diminishes with distance (1 / dist or 1 / dist^2)
                        const force = (repulsionDistance / dist - 1) * repulsionForce * 0.5; // Adjusted force calculation
                        pushX = Math.cos(angle) * force;
                         pushY = Math.sin(angle) * force;
                    }

                    // Apply velocity in world space (needs care - mapping screen push to world velocity)
                    // This is a simplified approach: applying push directly to velocity, assumes uniform depth scaling somewhat.
                    if(sprite.userData.velocity){
                        sprite.userData.velocity.x = (sprite.userData.velocity.x || 0) + pushX * 0.1; // Scale down screen push for world velocity
                        sprite.userData.velocity.y = (sprite.userData.velocity.y || 0) + pushY * 0.1;

                        // Apply Friction & Update Position
                        sprite.userData.velocity.multiplyScalar(friction);
                        sprite.position.addScaledVector(sprite.userData.velocity, 0.1); // Apply scaled velocity
                     }
                 } catch (e) {
                    console.warn("Error during glyph projection/repulsion:", e, sprite);
                 }

                 // --- Size Attenuation based on Distance ---
                 try { // Add try-catch for distance/scale calculation
                     const d = cameraPos.distanceTo(sprite.position);
                     const minDist = 300, maxDist = 2500; // Adjusted range for scaling
                    const scaleClose = 280, scaleFar = 140; // Adjusted sprite sizes

                    const clampDist = THREE.MathUtils.clamp(d, minDist, maxDist);
                     // Use smoother step or inverse square for scaling? Linear is simple.
                    const alpha = (clampDist - minDist) / (maxDist - minDist);
                     const finalScale = THREE.MathUtils.lerp(scaleClose, scaleFar, alpha);
                    sprite.scale.set(finalScale, finalScale, 1);
                } catch (e) {
                    console.warn("Error during glyph scaling:", e, sprite);
                }
            });
         }

         function spawnGlyphOnWall(sprite) { // Optional alternative spawn logic
             if (!sprite || !sprite.position) return; // Basic check
            const wallDistX = CORRIDOR_SIZE / 2 - 50; // X distance for walls
            const heightRange = 1600;
            const heightOffset = -600;
             const depthRange = CORRIDOR_SIZE * 0.8;
            const depthOffset = -CORRIDOR_SIZE * 0.1;

            let x, y, z = depthOffset - Math.random() * depthRange;
             y = heightOffset + Math.random() * heightRange;

             if(Math.random() < 0.5) { x = -wallDistX; } // Left Wall
            else { x = wallDistX; }                  // Right Wall
            // Could add ceiling spawn option here too
             sprite.position.set(x, y, z);
        }


        function onWindowResize() {
             if (!camera || !renderer) return; // Check if objects exist
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
         }

         function onDocumentMouseMove(event) {
             // mouse object should always exist if declared globally
             mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
             mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Map mouse position to target corridor rotation (subtler effect)
            const maxRotation = 0.06; // Reduced max rotation
             targetRotationY = mouse.x * maxRotation;
             targetRotationX = mouse.y * maxRotation * 0.5; // Even less X rotation
         }


     </script>

</body>

</html>
