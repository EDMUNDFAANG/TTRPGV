<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Plexus Corridor</title>
  <!-- Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    /* ===== Reset & Base Styles ===== */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0d1b2a;
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
    }

    /* ===== Navigation Bar ===== */
    nav {
      position: fixed;
      top: 0;
      width: 100%;
      background: rgba(0,0,0,0.4);
      padding: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0,204,255,0.5);
    }
    nav button {
      background: transparent;
      border: 2px solid rgba(0,204,255,0.7);
      color: #00ccff;
      margin: 0 10px;
      padding: 8px 16px;
      cursor: pointer;
      text-transform: uppercase;
      transition: background 0.3s, color 0.3s, transform 0.3s;
      outline: none;
    }
    nav button:hover,
    nav button.active {
      background: #00ccff;
      color: #000;
      transform: scale(1.05);
    }

    /* ===== Centered Content Card ===== */
    .content-card {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60%;
      max-width: 800px;
      padding: 30px;
      color: #fff;
      text-align: center;
      border: 2px solid rgba(0,204,255,0.3);
      border-radius: 20px;
      box-shadow: 0 0 20px rgba(0,204,255,0.2);
      background: rgba(0,0,0,0.3);
      backdrop-filter: blur(8px);
      z-index: 10;
    }
    .content-card h1 {
      font-size: 2em;
      margin-bottom: 0.5em;
      color: #00ccff;
    }
    .content-card p {
      font-size: 1.1em;
      line-height: 1.6em;
    }

    /* Only show Inventory by default */
    #map, #email, #codex, #scanner {
      display: none;
    }
  </style>
</head>
<body>
  <!-- ===== Navigation ===== -->
  <nav>
    <button data-section="inventory" class="active">Inventory</button>
    <button data-section="map">Map</button>
    <button data-section="email">Email</button>
    <button data-section="codex">Codex</button>
    <button data-section="scanner">Scanner</button>
  </nav>

  <!-- ===== Content Cards ===== -->
  <div id="inventory" class="content-card">
    <h1>Inventory</h1>
    <p>Inventory details go here.</p>
  </div>
  <div id="map" class="content-card">
    <h1>Map</h1>
    <p>Map details go here.</p>
  </div>
  <div id="email" class="content-card">
    <h1>Email</h1>
    <p>Email details go here.</p>
  </div>
  <div id="codex" class="content-card">
    <h1>Codex</h1>
    <p>Codex details go here.</p>
  </div>
  <div id="scanner" class="content-card">
    <h1>Scanner</h1>
    <p>Scanner details go here.</p>
  </div>

  <!-- ===== Three.js Scene ===== -->
  <script>
    let scene, camera, renderer;

    // We'll store four subdivided planes (floor, ceiling, left, right) => wireframe => corridor
    const corridorPlanes = [];
    // For wave distortion, we need to keep track of original geometry positions
    const originalPositions = []; // an array of arrays

    // Corridor config
    const CORRIDOR_SIZE = 3000;
    const SEGMENTS = 30; // subdivided segments for the plexus effect
    const WAVE_AMPLITUDE = 20; // how much the wave can move vertices
    const WAVE_SPEED = 0.5;    // speed factor for wave

    // Glyph config
    let glyphs = [];
    const GLYPH_COUNT = 30;
    const repulsionDistance = 120;
    const repulsionForce = 1.5;
    const friction = 0.93;

    // Scene & camera
    let mouse = new THREE.Vector2(0, 0);
    let targetRotationX = 0, targetRotationY = 0;

    init();
    animate();

    function init() {
      /* ===== Scene & Fog ===== */
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0d1b2a);
      scene.fog = new THREE.FogExp2(0x0d1b2a, 0.0007);

      /* ===== Camera ===== */
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 20000);
      camera.position.set(0, 0, 4000);
      camera.lookAt(0, 0, 0);

      /* ===== Renderer ===== */
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      /* ===== Lights ===== */
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
      directionalLight.position.set(1, 1, 1).normalize();
      scene.add(directionalLight);

      /* ===== Create Plexus Corridor (Floor, Ceiling, Left, Right) ===== */
      // We'll store them in a group for easy rotation
      const corridorGroup = new THREE.Group();
      scene.add(corridorGroup);

      // 1) Floor
      const floorPlane = createPlexusPlane(CORRIDOR_SIZE, CORRIDOR_SIZE, SEGMENTS, SEGMENTS, 0x00ccff);
      floorPlane.rotation.x = -Math.PI / 2;
      floorPlane.position.y = -CORRIDOR_SIZE / 2;
      corridorGroup.add(floorPlane.mesh);
      corridorPlanes.push(floorPlane);

      // 2) Ceiling
      const ceilingPlane = createPlexusPlane(CORRIDOR_SIZE, CORRIDOR_SIZE, SEGMENTS, SEGMENTS, 0x00ccff);
      ceilingPlane.rotation.x = Math.PI / 2;
      ceilingPlane.position.y = CORRIDOR_SIZE / 2;
      corridorGroup.add(ceilingPlane.mesh);
      corridorPlanes.push(ceilingPlane);

      // 3) Left Wall
      const leftWallPlane = createPlexusPlane(CORRIDOR_SIZE, CORRIDOR_SIZE, SEGMENTS, SEGMENTS, 0x00ccff);
      leftWallPlane.rotation.y = Math.PI / 2;
      leftWallPlane.position.x = -CORRIDOR_SIZE / 2;
      corridorGroup.add(leftWallPlane.mesh);
      corridorPlanes.push(leftWallPlane);

      // 4) Right Wall
      const rightWallPlane = createPlexusPlane(CORRIDOR_SIZE, CORRIDOR_SIZE, SEGMENTS, SEGMENTS, 0x00ccff);
      rightWallPlane.rotation.y = -Math.PI / 2;
      rightWallPlane.position.x = CORRIDOR_SIZE / 2;
      corridorGroup.add(rightWallPlane.mesh);
      corridorPlanes.push(rightWallPlane);

      // (No back wall => corridor recedes into fog)

      /* ===== Archaic Glyphs ===== */
      const glyphLetters = [
        "·ö†","·ö¢","·ö¶","·ö®","·ö±","·ö≤","·õâ","·õè","·õí","·õñ","·õû","·õü",
        "êé†","êé£","êé´"
      ];
      for (let i = 0; i < GLYPH_COUNT; i++) {
        const letter = glyphLetters[Math.floor(Math.random() * glyphLetters.length)];
        const sprite = createGlyphSprite(letter);
        // place them in a large volume
        sprite.position.set(
          (Math.random() - 0.5) * CORRIDOR_SIZE * 2,
          (Math.random() - 0.5) * CORRIDOR_SIZE * 2,
          -Math.random() * CORRIDOR_SIZE * 4
        );
        sprite.userData = {
          basePosition: sprite.position.clone(),
          oscillationSpeed: Math.random() * 0.5 + 0.5,
          velocity: new THREE.Vector3(0, 0, 0),
          lifetime: 0,
          maxLifetime: 12 + Math.random() * 12
        };
        glyphs.push(sprite);
        scene.add(sprite);
      }

      /* ===== Listeners ===== */
      window.addEventListener("resize", onWindowResize, false);
      document.addEventListener("mousemove", onDocumentMouseMove, false);

      // Nav button toggles
      const navButtons = document.querySelectorAll("nav button");
      const sections = ["inventory","map","email","codex","scanner"];
      navButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          const sectionId = btn.getAttribute("data-section");
          sections.forEach(s => {
            const el = document.getElementById(s);
            el.style.display = (s === sectionId) ? "block" : "none";
          });
          navButtons.forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
        });
      });
    }

    /* Create a subdivided plane geometry & store references for wave distortion. */
    function createPlexusPlane(width, height, widthSegments, heightSegments, color) {
      // 1) Create the subdivided plane geometry (oriented in XY by default)
      const planeGeo = new THREE.PlaneGeometry(width, height, widthSegments, heightSegments);

      // 2) Store original vertex positions for wave animation
      const posAttr = planeGeo.attributes.position;
      const originalPos = new Float32Array(posAttr.array.length);
      for (let i = 0; i < posAttr.array.length; i++) {
        originalPos[i] = posAttr.array[i];
      }
      originalPositions.push(originalPos);

      // 3) Convert plane geometry to wireframe
      const wireGeo = new THREE.WireframeGeometry(planeGeo);
      const mat = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
      const wireMesh = new THREE.LineSegments(wireGeo, mat);

      // We'll store references so we can animate it
      return {
        mesh: wireMesh,
        geometry: planeGeo,
        rotation: wireMesh.rotation,
        position: wireMesh.position
      };
    }

    /* Create a glyph sprite with archaic letter */
    function createGlyphSprite(letter) {
      const canvas = document.createElement("canvas");
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, 128, 128);
      ctx.font = "100px Arial";
      ctx.fillStyle = "rgba(0,204,255,1.0)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(letter, 64, 64);

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
      material.sizeAttenuation = true;
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(120, 120, 1);
      return sprite;
    }

    /* Window & Mouse Handlers */
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function onDocumentMouseMove(e) {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      const maxRotation = 0.06;
      targetRotationY = mouse.x * maxRotation;
      targetRotationX = mouse.y * maxRotation;
    }

    /* Main Animation Loop */
    function animate() {
      requestAnimationFrame(animate);

      const time = Date.now() * 0.001 * WAVE_SPEED;

      // Animate corridor planes with wave distortion
      corridorPlanes.forEach((planeObj, index) => {
        const planeGeo = planeObj.geometry;
        const posAttr = planeGeo.attributes.position;
        const orig = originalPositions[index]; // the original positions array
        // Rebuild the wire geometry after we shift the vertices
        for (let i = 0; i < posAttr.count; i++) {
          // x, y, z in the original array
          const ox = orig[i * 3 + 0];
          const oy = orig[i * 3 + 1];
          const oz = orig[i * 3 + 2];

          // We'll do a sin wave based on x,y => shift z or y
          // Because the plane is oriented in XY, let's shift the "Z" for wave
          // for floor/ceiling. For walls, it's the "X" or "Y" that changes, etc.
          // Simpler approach: we can just do a uniform wave in local coords:
          const wave = Math.sin((ox + oy) * 0.05 + time) * WAVE_AMPLITUDE;
          // Shift out of plane => local Z
          posAttr.setZ(i, wave);
        }
        posAttr.needsUpdate = true;

        // Rebuild wire geometry so lines update
        planeObj.mesh.geometry = new THREE.WireframeGeometry(planeGeo);
      });

      // Smoothly rotate corridor based on mouse
      corridorPlanes.forEach(planeObj => {
        planeObj.mesh.rotation.y += (targetRotationY - planeObj.mesh.rotation.y) * 0.05;
        planeObj.mesh.rotation.x += (targetRotationX - planeObj.mesh.rotation.x) * 0.05;
      });

      // Update glyphs
      glyphs.forEach(sprite => {
        sprite.userData.lifetime += 0.016;
        const fade = 1 - (sprite.userData.lifetime / sprite.userData.maxLifetime);
        sprite.material.opacity = Math.max(fade, 0);
        // Reset if nearly invisible
        if (fade <= 0.05) {
          sprite.userData.lifetime = 0;
          sprite.userData.maxLifetime = 12 + Math.random() * 12;
          sprite.position.set(
            (Math.random() - 0.5) * CORRIDOR_SIZE * 2,
            (Math.random() - 0.5) * CORRIDOR_SIZE * 2,
            -Math.random() * CORRIDOR_SIZE * 4
          );
          sprite.userData.basePosition.copy(sprite.position);
          sprite.userData.velocity.set(0, 0, 0);
          sprite.material.opacity = 1.0;
        }

        // Gentle oscillation around basePosition
        const t = Date.now() * 0.001 * sprite.userData.oscillationSpeed;
        sprite.position.x = sprite.userData.basePosition.x + Math.sin(t) * 15;
        sprite.position.y = sprite.userData.basePosition.y + Math.cos(t) * 15;

        // Mouse push in screen space
        const pos = sprite.position.clone();
        pos.project(camera);
        const glyphScreenX = (pos.x * 0.5 + 0.5) * window.innerWidth;
        const glyphScreenY = (-pos.y * 0.5 + 0.5) * window.innerHeight;
        const mouseScreenX = (mouse.x + 1) * 0.5 * window.innerWidth;
        const mouseScreenY = (-mouse.y + 1) * 0.5 * window.innerHeight;
        const dist = Math.hypot(glyphScreenX - mouseScreenX, glyphScreenY - mouseScreenY);
        if (dist < repulsionDistance) {
          const dx = glyphScreenX - mouseScreenX;
          const dy = glyphScreenY - mouseScreenY;
          const angle = Math.atan2(dy, dx);
          const pushX = Math.cos(angle) * repulsionForce;
          const pushY = Math.sin(angle) * repulsionForce;
          sprite.userData.velocity.x += pushX;
          sprite.userData.velocity.y += pushY;
        }
        sprite.userData.velocity.multiplyScalar(friction);
        sprite.position.x += sprite.userData.velocity.x;
        sprite.position.y += sprite.userData.velocity.y;

        // Distance-based scaling: bigger when close, smaller when far
        const d = camera.position.distanceTo(sprite.position);
        const minDist = 500, maxDist = 3000;
        const scaleClose = 400, scaleFar = 150;
        const clampDist = THREE.MathUtils.clamp(d, minDist, maxDist);
        const alpha = (clampDist - minDist) / (maxDist - minDist);
        const finalScale = scaleClose * (1 - alpha) + scaleFar * alpha;
        sprite.scale.set(finalScale, finalScale, 1);
      });

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
